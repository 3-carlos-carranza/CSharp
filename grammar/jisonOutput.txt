Processing grammar.
$accept(0)
$end(1)
error(2)
compilationUnit(3)
es(4)
EOF(5)
e(6)
IF(7)
OPEN_BRACE(8)
DOT(9)
IDENTIFIER(10)
literal(11)
BOOLEAN_LITERAL(12)
REAL_LITERAL(13)
INTEGER_LITERAL(14)
STRING_LITERAL(15)
CHARACTER_LITERAL(16)
NULL(17)
namespace-name(18)
namespace-or-type-name(19)
type-name(20)
type(21)
value-type(22)
reference-type(23)
struct-type(24)
enum-type(25)
simple-type(26)
numeric-type(27)
BOOL(28)
integral-type(29)
floating-point-type(30)
DECIMAL(31)
SBYTE(32)
BYTE(33)
SHORT(34)
USHORT(35)
INT(36)
UINT(37)
LONG(38)
ULONG(39)
CHAR(40)
FLOAT(41)
DOUBLE(42)
class-type(43)
interface-type(44)
array-type(45)
delegate-type(46)
OBJECT(47)
STRING(48)
non-array-type(49)
rank-specifiers(50)
rank-specifier(51)
OPEN_BRACKET(52)
dim-separators(53)
CLOSE_BRACKET(54)
COMMA(55)
variable-reference(56)
expression(57)
argument-list(58)
argument(59)
REF(60)
OUT(61)
primary-expression(62)
primary-no-array-creation-expression(63)
array-creation-expression(64)
simple-name(65)
parenthesized-expression(66)
member-access(67)
invocation-expression(68)
element-access(69)
this-access(70)
base-access(71)
post-increment-expression(72)
post-decrement-expression(73)
object-creation-expression(74)
delegate-creation-expression(75)
typeof-expression(76)
sizeof-expression(77)
checked-expression(78)
unchecked-expression(79)
OPEN_PARENS(80)
CLOSE_PARENS(81)
predefined-type(82)
expression-list(83)
THIS(84)
base(85)
OP_INC(86)
OP_DEC(87)
NEW(88)
array-initializer(89)
TYPEOF(90)
VOID(91)
CHECKED(92)
UNCHECKED(93)
unary-expression(94)
PLUS(95)
MINUS(96)
BANG(97)
TILDE(98)
STAR(99)
pre-increment-expression(100)
pre-decrement-expression(101)
cast-expression(102)
multiplicative-expression(103)
DIV(104)
PERCENT(105)
additive-expression(106)
shift-expression(107)
OP_LEFT_SHIFT(108)
RIGHT_SHIFT(109)
relational-expression(110)
LT(111)
GT(112)
OP_LE(113)
OP_GE(114)
IS(115)
AS(116)
equality-expression(117)
OP_EQ(118)
OP_NE(119)
and-expression(120)
AMP(121)
exclusive-or-expression(122)
CARET(123)
inclusive-or-expression(124)
BITWISE_OR(125)
conditional-and-expression(126)
OP_AND(127)
conditional-or-expression(128)
OP_OR(129)
conditional-expression(130)
INTERR(131)
COLON(132)
assignment(133)
assignment-operator(134)
ASSIGNMENT(135)
OP_ADD_ASSIGNMENT(136)
OP_SUB_ASSIGNMENT(137)
OP_MULT_ASSIGNMENT(138)
OP_DIV_ASSIGNMENT(139)
OP_MOD_ASSIGNMENT(140)
OP_AND_ASSIGNMENT(141)
OP_OR_ASSIGNMENT(142)
OP_XOR_ASSIGNMENT(143)
OP_LEFT_SHIFT_ASSIGNMENT(144)
RIGHT_SHIFT_ASSIGNMENT(145)
constant-expression(146)
boolean-expression(147)

Item sets
------

item set 0 
$accept -> .compilationUnit $end #lookaheads= $end
compilationUnit -> .es EOF
es -> .e
es -> .es e
e -> .IF
e -> .OPEN_BRACE
e -> .DOT
e -> .IDENTIFIER
e -> . 
transitions ->  {"compilationUnit":1,"es":2,"e":3,"IF":4,"OPEN_BRACE":5,"DOT":6,"IDENTIFIER":7}

item set 1 
$accept -> compilationUnit .$end #lookaheads= $end 
transitions ->  {}

item set 2 
compilationUnit -> es .EOF
es -> es .e
e -> .IF
e -> .OPEN_BRACE
e -> .DOT
e -> .IDENTIFIER
e -> . 
transitions ->  {"EOF":8,"e":9,"IF":4,"OPEN_BRACE":5,"DOT":6,"IDENTIFIER":7}

item set 3 
es -> e . 
transitions ->  {}

item set 4 
e -> IF . 
transitions ->  {}

item set 5 
e -> OPEN_BRACE . 
transitions ->  {}

item set 6 
e -> DOT . 
transitions ->  {}

item set 7 
e -> IDENTIFIER . 
transitions ->  {}

item set 8 
compilationUnit -> es EOF . 
transitions ->  {}

item set 9 
es -> es e . 
transitions ->  {}
10 states.
Building lookahead grammar.
Computing lookaheads.
Building parse table.
Conflict at state: 0, token: IDENTIFIER
  reduce by rule: e -> 
  shift token (then go to state 7)
Conflict at state: 0, token: DOT
  reduce by rule: e -> 
  shift token (then go to state 6)
Conflict at state: 0, token: OPEN_BRACE
  reduce by rule: e -> 
  shift token (then go to state 5)
Conflict at state: 0, token: IF
  reduce by rule: e -> 
  shift token (then go to state 4)
Conflict at state: 2, token: IDENTIFIER
  reduce by rule: e -> 
  shift token (then go to state 7)
Conflict at state: 2, token: DOT
  reduce by rule: e -> 
  shift token (then go to state 6)
Conflict at state: 2, token: OPEN_BRACE
  reduce by rule: e -> 
  shift token (then go to state 5)
Conflict at state: 2, token: IF
  reduce by rule: e -> 
  shift token (then go to state 4)
Conflict at state: 2, token: EOF
  reduce by rule: e -> 
  shift token (then go to state 8)

9 Conflict(s) found in grammar.
Done.
