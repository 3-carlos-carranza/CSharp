Processing grammar.
$accept(0)
$end(1)
error(2)
compilationUnit(3)
es(4)
EOF(5)
e(6)
IF(7)
REAL_LITERAL(8)
INTEGER_LITERAL(9)
STRING_LITERAL(10)
CHARACTER_LITERAL(11)
Unicode_escape_sequence(12)
OPEN_BRACE(13)
DOT(14)
IDENTIFIER(15)

Item sets
------

item set 0 
$accept -> .compilationUnit $end #lookaheads= $end
compilationUnit -> .es EOF
es -> .e
es -> .es e
e -> .IF
e -> .REAL_LITERAL
e -> .INTEGER_LITERAL
e -> .STRING_LITERAL
e -> .CHARACTER_LITERAL
e -> .Unicode_escape_sequence
e -> .OPEN_BRACE
e -> .DOT
e -> .IDENTIFIER
e -> . 
transitions ->  {"compilationUnit":1,"es":2,"e":3,"IF":4,"REAL_LITERAL":5,"INTEGER_LITERAL":6,"STRING_LITERAL":7,"CHARACTER_LITERAL":8,"Unicode_escape_sequence":9,"OPEN_BRACE":10,"DOT":11,"IDENTIFIER":12}

item set 1 
$accept -> compilationUnit .$end #lookaheads= $end 
transitions ->  {}

item set 2 
compilationUnit -> es .EOF
es -> es .e
e -> .IF
e -> .REAL_LITERAL
e -> .INTEGER_LITERAL
e -> .STRING_LITERAL
e -> .CHARACTER_LITERAL
e -> .Unicode_escape_sequence
e -> .OPEN_BRACE
e -> .DOT
e -> .IDENTIFIER
e -> . 
transitions ->  {"EOF":13,"e":14,"IF":4,"REAL_LITERAL":5,"INTEGER_LITERAL":6,"STRING_LITERAL":7,"CHARACTER_LITERAL":8,"Unicode_escape_sequence":9,"OPEN_BRACE":10,"DOT":11,"IDENTIFIER":12}

item set 3 
es -> e . 
transitions ->  {}

item set 4 
e -> IF . 
transitions ->  {}

item set 5 
e -> REAL_LITERAL . 
transitions ->  {}

item set 6 
e -> INTEGER_LITERAL . 
transitions ->  {}

item set 7 
e -> STRING_LITERAL . 
transitions ->  {}

item set 8 
e -> CHARACTER_LITERAL . 
transitions ->  {}

item set 9 
e -> Unicode_escape_sequence . 
transitions ->  {}

item set 10 
e -> OPEN_BRACE . 
transitions ->  {}

item set 11 
e -> DOT . 
transitions ->  {}

item set 12 
e -> IDENTIFIER . 
transitions ->  {}

item set 13 
compilationUnit -> es EOF . 
transitions ->  {}

item set 14 
es -> es e . 
transitions ->  {}
15 states.
Building lookahead grammar.
Computing lookaheads.
Building parse table.
Conflict at state: 0, token: IDENTIFIER
  reduce by rule: e -> 
  shift token (then go to state 12)
Conflict at state: 0, token: DOT
  reduce by rule: e -> 
  shift token (then go to state 11)
Conflict at state: 0, token: OPEN_BRACE
  reduce by rule: e -> 
  shift token (then go to state 10)
Conflict at state: 0, token: Unicode_escape_sequence
  reduce by rule: e -> 
  shift token (then go to state 9)
Conflict at state: 0, token: CHARACTER_LITERAL
  reduce by rule: e -> 
  shift token (then go to state 8)
Conflict at state: 0, token: STRING_LITERAL
  reduce by rule: e -> 
  shift token (then go to state 7)
Conflict at state: 0, token: INTEGER_LITERAL
  reduce by rule: e -> 
  shift token (then go to state 6)
Conflict at state: 0, token: REAL_LITERAL
  reduce by rule: e -> 
  shift token (then go to state 5)
Conflict at state: 0, token: IF
  reduce by rule: e -> 
  shift token (then go to state 4)
Conflict at state: 2, token: IDENTIFIER
  reduce by rule: e -> 
  shift token (then go to state 12)
Conflict at state: 2, token: DOT
  reduce by rule: e -> 
  shift token (then go to state 11)
Conflict at state: 2, token: OPEN_BRACE
  reduce by rule: e -> 
  shift token (then go to state 10)
Conflict at state: 2, token: Unicode_escape_sequence
  reduce by rule: e -> 
  shift token (then go to state 9)
Conflict at state: 2, token: CHARACTER_LITERAL
  reduce by rule: e -> 
  shift token (then go to state 8)
Conflict at state: 2, token: STRING_LITERAL
  reduce by rule: e -> 
  shift token (then go to state 7)
Conflict at state: 2, token: INTEGER_LITERAL
  reduce by rule: e -> 
  shift token (then go to state 6)
Conflict at state: 2, token: REAL_LITERAL
  reduce by rule: e -> 
  shift token (then go to state 5)
Conflict at state: 2, token: IF
  reduce by rule: e -> 
  shift token (then go to state 4)
Conflict at state: 2, token: EOF
  reduce by rule: e -> 
  shift token (then go to state 13)

19 Conflict(s) found in grammar.
Done.
