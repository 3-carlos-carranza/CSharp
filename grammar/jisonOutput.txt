Processing grammar.
$accept(0)
$end(1)
error(2)
compilationUnit(3)
es(4)
EOF(5)
e(6)
IF(7)
INTEGER_LITERAL(8)
IDENTIFIER(9)

Item sets
------

item set 0 
$accept -> .compilationUnit $end #lookaheads= $end
compilationUnit -> .es EOF
es -> .e
es -> .es e
e -> .IF
e -> .INTEGER_LITERAL
e -> .IDENTIFIER
e -> . 
transitions ->  {"compilationUnit":1,"es":2,"e":3,"IF":4,"INTEGER_LITERAL":5,"IDENTIFIER":6}

item set 1 
$accept -> compilationUnit .$end #lookaheads= $end 
transitions ->  {}

item set 2 
compilationUnit -> es .EOF
es -> es .e
e -> .IF
e -> .INTEGER_LITERAL
e -> .IDENTIFIER
e -> . 
transitions ->  {"EOF":7,"e":8,"IF":4,"INTEGER_LITERAL":5,"IDENTIFIER":6}

item set 3 
es -> e . 
transitions ->  {}

item set 4 
e -> IF . 
transitions ->  {}

item set 5 
e -> INTEGER_LITERAL . 
transitions ->  {}

item set 6 
e -> IDENTIFIER . 
transitions ->  {}

item set 7 
compilationUnit -> es EOF . 
transitions ->  {}

item set 8 
es -> es e . 
transitions ->  {}
9 states.
Building lookahead grammar.
Computing lookaheads.
Building parse table.
Conflict at state: 0, token: IDENTIFIER
  reduce by rule: e -> 
  shift token (then go to state 6)
Conflict at state: 0, token: INTEGER_LITERAL
  reduce by rule: e -> 
  shift token (then go to state 5)
Conflict at state: 0, token: IF
  reduce by rule: e -> 
  shift token (then go to state 4)
Conflict at state: 2, token: IDENTIFIER
  reduce by rule: e -> 
  shift token (then go to state 6)
Conflict at state: 2, token: INTEGER_LITERAL
  reduce by rule: e -> 
  shift token (then go to state 5)
Conflict at state: 2, token: IF
  reduce by rule: e -> 
  shift token (then go to state 4)
Conflict at state: 2, token: EOF
  reduce by rule: e -> 
  shift token (then go to state 7)

7 Conflict(s) found in grammar.
Done.
