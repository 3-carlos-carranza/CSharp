Processing grammar.
$accept(0)
$end(1)
error(2)
compilationUnit(3)
packageDeclaration(4)
EOF(5)
importDeclarations(6)
typeDeclarations(7)
SEMI(8)
annotationl(9)
PACKAGE(10)
qualifiedName(11)
importDeclaration(12)
IMPORT(13)
STATIC(14)
DOT(15)
MUL(16)
typeDeclarationWithPrefixes(17)
modifierL(18)
typeDeclaration(19)
classDeclaration(20)
interfaceDeclaration(21)
enumDeclaration(22)
annotationTypeDeclaration(23)
CLASS(24)
Identifier(25)
classInheritance(26)
interfaceImplentation(27)
commentReturn(28)
classBody(29)
typeParameters(30)
EXTENDS(31)
type(32)
IMPLEMENTS(33)
typeList(34)
TEMPLATE(35)
ENUM(36)
enumBody(37)
LBRACE(38)
RBRACE(39)
enumBodyDeclaration(40)
enumConstants(41)
COMMA(42)
classBodyDeclarationl(43)
annotations(44)
enumConstantArguments(45)
enumConstantClassBody(46)
arguments(47)
INTERFACE(48)
optionalTypeParameters(49)
interfaceBody(50)
classBodyDeclarations(51)
classBodyDeclaration(52)
classStaticBlock(53)
block(54)
interfaceBodyDeclarationl(55)
interfaceBodyDeclarations(56)
interfaceBodyDeclaration(57)
classMemberDeclaration(58)
staticBlock(59)
modifier(60)
FINAL(61)
ABSTRACT(62)
STRICTFP(63)
TRANSIENT(64)
VOLATILE(65)
PUBLIC(66)
PRIVATE(67)
PROTECTED(68)
NATIVE(69)
SYNCHRONIZED(70)
modifiers(71)
VOID(72)
formalParameters(73)
arrayDimensionBracks(74)
throwsList(75)
variableDeclarators(76)
THROWS(77)
qualifiedNameList(78)
interfaceMemberDeclaration(79)
constDelarators(80)
constDeclaration(81)
constantDeclarator(82)
ASSIGN(83)
variableInitializer(84)
arrayDimensionBrackl(85)
variableDeclarator(86)
variableDeclaratorId(87)
arrayInitializer(88)
expression(89)
variableInitializerL(90)
enumConstantName(91)
primitiveType(92)
arrayDimensionBrack(93)
LBRACK(94)
RBRACK(95)
classOrInterfaceType(96)
BOOLEAN(97)
CHAR(98)
BYTE(99)
SHORT(100)
INT(101)
LONG(102)
FLOAT(103)
DOUBLE(104)
typeArguments(105)
LT(106)
typeArgumentList(107)
GT(108)
typeArgument(109)
QUESTION(110)
SUPER(111)
typeArgument_(112)
LPAREN(113)
RPAREN(114)
formalParameterList(115)
usualParameterList(116)
lastFormalParameter(117)
usualParameter(118)
variableModifiers(119)
variableModifierL(120)
variableModifier(121)
ELLIPSIS(122)
methodBody(123)
constructorBody(124)
literal(125)
IntegerLiteral(126)
FloatingPointLiteral(127)
CharacterLiteral(128)
StringLiteral(129)
BooleanLiteral(130)
NullLiteral(131)
annotation(132)
AT(133)
elementValueList(134)
elementValuePairs(135)
annotationOptValues(136)
annotationElement(137)
elementValue(138)
annotationName(139)
elementValuePair(140)
elementValueArrayInitializer(141)
elementValueListOpt(142)
annotationTypeBody(143)
annotationTypeElementDeclarations(144)
annotationTypeElementDeclaration(145)
annotationTypeElementRest(146)
annotationConstantRest(147)
annotationMethodRest(148)
semiOpt(149)
defaultValue(150)
defaultValueOpt(151)
DEFAULT(152)
blockStatementList(153)
blockStatements(154)
blockStatement(155)
statement(156)
localVariableDeclarationStatement(157)
localVariableDeclaration(158)
assertExpression(159)
COLON(160)
optionalElseStatement(161)
ELSE(162)
ASSERT(163)
IF(164)
FOR(165)
forControl(166)
WHILE(167)
DO(168)
TRY(169)
catchFinallyOrOnlyFinally(170)
resourceSpecification(171)
catchClauses(172)
optionalFinallyBlock(173)
SWITCH(174)
switchBlockStatementGroups(175)
emptySwitchLabels(176)
RETURN(177)
THROW(178)
BREAK(179)
optionalIdentifier(180)
CONTINUE(181)
variableDeclaratorsWithPrefixes(182)
simpleExpressionStatement(183)
finallyBlock(184)
catchClause(185)
CATCH(186)
catchType(187)
BITOR(188)
FINALLY(189)
resources(190)
resource(191)
switchBlockStatementGroupL(192)
switchBlockStatementGroup(193)
switchLabelL(194)
switchLabel(195)
CASE(196)
enhancedForControl(197)
forInit(198)
optionalExpression(199)
optionalForUpdate(200)
optionalForInit(201)
forUpdate(202)
expressionList(203)
parExpression(204)
optionalExpressionList(205)
statementExpression(206)
constantExpression(207)
optionalNonWildcardTypeArguments(208)
nonWildcardTypeArguments(209)
incrementOrDecrement(210)
INC(211)
DEC(212)
plusMinusIncOrDec(213)
ADD(214)
SUB(215)
prefixTildeOrBang(216)
TILDE(217)
BANG(218)
mulDivOrMod(219)
DIV(220)
MOD(221)
addOrSub(222)
bitShiftOperator(223)
lE_GE_LT_GT(224)
LE(225)
GE(226)
equals_NotEqual(227)
EQUAL(228)
NOTEQUAL(229)
assignmentToken(230)
ADD_ASSIGN(231)
SUB_ASSIGN(232)
MUL_ASSIGN(233)
DIV_ASSIGN(234)
AND_ASSIGN(235)
OR_ASSIGN(236)
XOR_ASSIGN(237)
RSHIFT_ASSIGN(238)
URSHIFT_ASSIGN(239)
LSHIFT_ASSIGN(240)
MOD_ASSIGN(241)
newCreator(242)
NEW(243)
creator(244)
THIS(245)
innerCreator(246)
explicitGenericInvocation(247)
LSHIFT(248)
INSTANCEOF(249)
BITAND(250)
CARET(251)
AND(252)
OR(253)
explicitGenericInvocationSuffixOrThisArgs(254)
explicitGenericInvocationSuffix(255)
createdName(256)
classCreatorRest(257)
arrayOrClassCreator(258)
arrayCreatorRest(259)
optionalTypeArgumentsOrDiamonds(260)
typeArgumentsOrDiamondList(261)
typeArgumentsOrDiamond(262)
optionalNonWildcardTypeArgumentsOrDiamond(263)
nonWildcardTypeArgumentsOrDiamond(264)
bracketedExpressions(265)
optionalClassBody(266)
superSuffix(267)
optionalArguments(268)
optionalCOMMA(269)

Item sets
------

item set 0 
$accept -> .compilationUnit $end #lookaheads= $end
compilationUnit -> .packageDeclaration EOF
compilationUnit -> .packageDeclaration importDeclarations EOF
compilationUnit -> .packageDeclaration importDeclarations typeDeclarations EOF
compilationUnit -> .packageDeclaration typeDeclarations EOF
compilationUnit -> .importDeclarations typeDeclarations EOF
compilationUnit -> .typeDeclarations EOF
compilationUnit -> .SEMI
packageDeclaration -> .annotationl packageDeclaration
packageDeclaration -> .packageDeclaration
packageDeclaration -> .PACKAGE qualifiedName SEMI
importDeclarations -> .importDeclaration
importDeclarations -> .importDeclarations importDeclaration
typeDeclarations -> .typeDeclarationWithPrefixes
typeDeclarations -> .typeDeclarations typeDeclarationWithPrefixes
annotationl -> .annotation
annotationl -> .annotationl annotation
importDeclaration -> .IMPORT STATIC qualifiedName DOT MUL SEMI
importDeclaration -> .IMPORT STATIC qualifiedName SEMI
importDeclaration -> .IMPORT qualifiedName DOT MUL SEMI
importDeclaration -> .IMPORT qualifiedName SEMI
typeDeclarationWithPrefixes -> .annotationl modifierL typeDeclaration
typeDeclarationWithPrefixes -> .modifierL annotationl typeDeclaration
typeDeclarationWithPrefixes -> .modifierL typeDeclaration
typeDeclarationWithPrefixes -> .annotationl typeDeclaration
typeDeclarationWithPrefixes -> .typeDeclaration
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifierL -> .modifier
modifierL -> .modifierL modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody 
transitions ->  {"compilationUnit":1,"packageDeclaration":2,"importDeclarations":3,"typeDeclarations":4,"SEMI":5,"annotationl":6,"PACKAGE":7,"importDeclaration":8,"typeDeclarationWithPrefixes":9,"annotation":10,"IMPORT":11,"modifierL":12,"typeDeclaration":13,"AT":14,"modifier":15,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 1 
$accept -> compilationUnit .$end #lookaheads= $end 
transitions ->  {}

item set 2 
compilationUnit -> packageDeclaration .EOF
compilationUnit -> packageDeclaration .importDeclarations EOF
compilationUnit -> packageDeclaration .importDeclarations typeDeclarations EOF
compilationUnit -> packageDeclaration .typeDeclarations EOF
packageDeclaration -> packageDeclaration .
importDeclarations -> .importDeclaration
importDeclarations -> .importDeclarations importDeclaration
typeDeclarations -> .typeDeclarationWithPrefixes
typeDeclarations -> .typeDeclarations typeDeclarationWithPrefixes
importDeclaration -> .IMPORT STATIC qualifiedName DOT MUL SEMI
importDeclaration -> .IMPORT STATIC qualifiedName SEMI
importDeclaration -> .IMPORT qualifiedName DOT MUL SEMI
importDeclaration -> .IMPORT qualifiedName SEMI
typeDeclarationWithPrefixes -> .annotationl modifierL typeDeclaration
typeDeclarationWithPrefixes -> .modifierL annotationl typeDeclaration
typeDeclarationWithPrefixes -> .modifierL typeDeclaration
typeDeclarationWithPrefixes -> .annotationl typeDeclaration
typeDeclarationWithPrefixes -> .typeDeclaration
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody 
transitions ->  {"EOF":34,"importDeclarations":35,"typeDeclarations":36,"importDeclaration":8,"typeDeclarationWithPrefixes":9,"IMPORT":11,"annotationl":37,"modifierL":12,"typeDeclaration":13,"annotation":10,"modifier":15,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 3 
compilationUnit -> importDeclarations .typeDeclarations EOF
importDeclarations -> importDeclarations .importDeclaration
typeDeclarations -> .typeDeclarationWithPrefixes
typeDeclarations -> .typeDeclarations typeDeclarationWithPrefixes
importDeclaration -> .IMPORT STATIC qualifiedName DOT MUL SEMI
importDeclaration -> .IMPORT STATIC qualifiedName SEMI
importDeclaration -> .IMPORT qualifiedName DOT MUL SEMI
importDeclaration -> .IMPORT qualifiedName SEMI
typeDeclarationWithPrefixes -> .annotationl modifierL typeDeclaration
typeDeclarationWithPrefixes -> .modifierL annotationl typeDeclaration
typeDeclarationWithPrefixes -> .modifierL typeDeclaration
typeDeclarationWithPrefixes -> .annotationl typeDeclaration
typeDeclarationWithPrefixes -> .typeDeclaration
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody 
transitions ->  {"typeDeclarations":39,"importDeclaration":40,"typeDeclarationWithPrefixes":9,"IMPORT":11,"annotationl":37,"modifierL":12,"typeDeclaration":13,"annotation":10,"modifier":15,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 4 
compilationUnit -> typeDeclarations .EOF
typeDeclarations -> typeDeclarations .typeDeclarationWithPrefixes
typeDeclarationWithPrefixes -> .annotationl modifierL typeDeclaration
typeDeclarationWithPrefixes -> .modifierL annotationl typeDeclaration
typeDeclarationWithPrefixes -> .modifierL typeDeclaration
typeDeclarationWithPrefixes -> .annotationl typeDeclaration
typeDeclarationWithPrefixes -> .typeDeclaration
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody 
transitions ->  {"EOF":41,"typeDeclarationWithPrefixes":42,"annotationl":37,"modifierL":12,"typeDeclaration":13,"annotation":10,"modifier":15,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 5 
compilationUnit -> SEMI .
typeDeclaration -> SEMI . 
transitions ->  {}

item set 6 
packageDeclaration -> annotationl .packageDeclaration
annotationl -> annotationl .annotation
typeDeclarationWithPrefixes -> annotationl .modifierL typeDeclaration
typeDeclarationWithPrefixes -> annotationl .typeDeclaration
packageDeclaration -> .annotationl packageDeclaration
packageDeclaration -> .packageDeclaration
packageDeclaration -> .PACKAGE qualifiedName SEMI
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifierL -> .modifier
modifierL -> .modifierL modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
annotationl -> .annotation
annotationl -> .annotationl annotation
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody 
transitions ->  {"packageDeclaration":43,"annotation":44,"modifierL":45,"typeDeclaration":46,"annotationl":47,"PACKAGE":7,"AT":14,"modifier":15,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 7 
packageDeclaration -> PACKAGE .qualifiedName SEMI
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters 
transitions ->  {"qualifiedName":48,"Identifier":49}

item set 8 
importDeclarations -> importDeclaration . 
transitions ->  {}

item set 9 
typeDeclarations -> typeDeclarationWithPrefixes . 
transitions ->  {}

item set 10 
annotationl -> annotation . 
transitions ->  {}

item set 11 
importDeclaration -> IMPORT .STATIC qualifiedName DOT MUL SEMI
importDeclaration -> IMPORT .STATIC qualifiedName SEMI
importDeclaration -> IMPORT .qualifiedName DOT MUL SEMI
importDeclaration -> IMPORT .qualifiedName SEMI
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters 
transitions ->  {"STATIC":50,"qualifiedName":51,"Identifier":49}

item set 12 
typeDeclarationWithPrefixes -> modifierL .annotationl typeDeclaration
typeDeclarationWithPrefixes -> modifierL .typeDeclaration
modifierL -> modifierL .modifier
annotationl -> .annotation
annotationl -> .annotationl annotation
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody 
transitions ->  {"annotationl":52,"typeDeclaration":53,"modifier":54,"annotation":10,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"AT":14,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 13 
typeDeclarationWithPrefixes -> typeDeclaration . 
transitions ->  {}

item set 14 
annotation -> AT .qualifiedName
annotation -> AT .qualifiedName LPAREN elementValueList RPAREN
annotation -> AT .qualifiedName LPAREN elementValuePairs RPAREN
annotationTypeDeclaration -> AT .INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> AT .INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters 
transitions ->  {"qualifiedName":55,"INTERFACE":56,"Identifier":49}

item set 15 
modifierL -> modifier . 
transitions ->  {}

item set 16 
typeDeclaration -> classDeclaration . 
transitions ->  {}

item set 17 
typeDeclaration -> interfaceDeclaration . 
transitions ->  {}

item set 18 
typeDeclaration -> enumDeclaration . 
transitions ->  {}

item set 19 
typeDeclaration -> annotationTypeDeclaration . 
transitions ->  {}

item set 20 
modifier -> STATIC . 
transitions ->  {}

item set 21 
modifier -> FINAL . 
transitions ->  {}

item set 22 
modifier -> ABSTRACT . 
transitions ->  {}

item set 23 
modifier -> STRICTFP . 
transitions ->  {}

item set 24 
modifier -> TRANSIENT . 
transitions ->  {}

item set 25 
modifier -> VOLATILE . 
transitions ->  {}

item set 26 
modifier -> PUBLIC . 
transitions ->  {}

item set 27 
modifier -> PRIVATE . 
transitions ->  {}

item set 28 
modifier -> PROTECTED . 
transitions ->  {}

item set 29 
modifier -> NATIVE . 
transitions ->  {}

item set 30 
modifier -> SYNCHRONIZED . 
transitions ->  {}

item set 31 
classDeclaration -> CLASS .Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> CLASS .Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody 
transitions ->  {"Identifier":57}

item set 32 
interfaceDeclaration -> INTERFACE .Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> INTERFACE .Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody 
transitions ->  {"Identifier":58}

item set 33 
enumDeclaration -> ENUM .Identifier interfaceImplentation commentReturn enumBody 
transitions ->  {"Identifier":59}

item set 34 
compilationUnit -> packageDeclaration EOF . 
transitions ->  {}

item set 35 
compilationUnit -> packageDeclaration importDeclarations .EOF
compilationUnit -> packageDeclaration importDeclarations .typeDeclarations EOF
importDeclarations -> importDeclarations .importDeclaration
typeDeclarations -> .typeDeclarationWithPrefixes
typeDeclarations -> .typeDeclarations typeDeclarationWithPrefixes
importDeclaration -> .IMPORT STATIC qualifiedName DOT MUL SEMI
importDeclaration -> .IMPORT STATIC qualifiedName SEMI
importDeclaration -> .IMPORT qualifiedName DOT MUL SEMI
importDeclaration -> .IMPORT qualifiedName SEMI
typeDeclarationWithPrefixes -> .annotationl modifierL typeDeclaration
typeDeclarationWithPrefixes -> .modifierL annotationl typeDeclaration
typeDeclarationWithPrefixes -> .modifierL typeDeclaration
typeDeclarationWithPrefixes -> .annotationl typeDeclaration
typeDeclarationWithPrefixes -> .typeDeclaration
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody 
transitions ->  {"EOF":60,"typeDeclarations":61,"importDeclaration":40,"typeDeclarationWithPrefixes":9,"IMPORT":11,"annotationl":37,"modifierL":12,"typeDeclaration":13,"annotation":10,"modifier":15,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 36 
compilationUnit -> packageDeclaration typeDeclarations .EOF
typeDeclarations -> typeDeclarations .typeDeclarationWithPrefixes
typeDeclarationWithPrefixes -> .annotationl modifierL typeDeclaration
typeDeclarationWithPrefixes -> .modifierL annotationl typeDeclaration
typeDeclarationWithPrefixes -> .modifierL typeDeclaration
typeDeclarationWithPrefixes -> .annotationl typeDeclaration
typeDeclarationWithPrefixes -> .typeDeclaration
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody 
transitions ->  {"EOF":62,"typeDeclarationWithPrefixes":42,"annotationl":37,"modifierL":12,"typeDeclaration":13,"annotation":10,"modifier":15,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 37 
typeDeclarationWithPrefixes -> annotationl .modifierL typeDeclaration
typeDeclarationWithPrefixes -> annotationl .typeDeclaration
annotationl -> annotationl .annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody 
transitions ->  {"modifierL":45,"typeDeclaration":46,"annotation":63,"modifier":15,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 38 
typeDeclaration -> SEMI . 
transitions ->  {}

item set 39 
compilationUnit -> importDeclarations typeDeclarations .EOF
typeDeclarations -> typeDeclarations .typeDeclarationWithPrefixes
typeDeclarationWithPrefixes -> .annotationl modifierL typeDeclaration
typeDeclarationWithPrefixes -> .modifierL annotationl typeDeclaration
typeDeclarationWithPrefixes -> .modifierL typeDeclaration
typeDeclarationWithPrefixes -> .annotationl typeDeclaration
typeDeclarationWithPrefixes -> .typeDeclaration
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody 
transitions ->  {"EOF":64,"typeDeclarationWithPrefixes":42,"annotationl":37,"modifierL":12,"typeDeclaration":13,"annotation":10,"modifier":15,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 40 
importDeclarations -> importDeclarations importDeclaration . 
transitions ->  {}

item set 41 
compilationUnit -> typeDeclarations EOF . 
transitions ->  {}

item set 42 
typeDeclarations -> typeDeclarations typeDeclarationWithPrefixes . 
transitions ->  {}

item set 43 
packageDeclaration -> annotationl packageDeclaration .
packageDeclaration -> packageDeclaration . 
transitions ->  {}

item set 44 
annotationl -> annotationl annotation .
annotationl -> annotation . 
transitions ->  {}

item set 45 
typeDeclarationWithPrefixes -> annotationl modifierL .typeDeclaration
modifierL -> modifierL .modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody 
transitions ->  {"typeDeclaration":65,"modifier":54,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"CLASS":31,"INTERFACE":32,"ENUM":33,"AT":66}

item set 46 
typeDeclarationWithPrefixes -> annotationl typeDeclaration . 
transitions ->  {}

item set 47 
packageDeclaration -> annotationl .packageDeclaration
annotationl -> annotationl .annotation
packageDeclaration -> .annotationl packageDeclaration
packageDeclaration -> .packageDeclaration
packageDeclaration -> .PACKAGE qualifiedName SEMI
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
annotationl -> .annotation
annotationl -> .annotationl annotation 
transitions ->  {"packageDeclaration":43,"annotation":44,"annotationl":47,"PACKAGE":7,"AT":67}

item set 48 
packageDeclaration -> PACKAGE qualifiedName .SEMI
qualifiedName -> qualifiedName .DOT Identifier
qualifiedName -> qualifiedName .DOT Identifier typeParameters 
transitions ->  {"SEMI":68,"DOT":69}

item set 49 
qualifiedName -> Identifier .
qualifiedName -> Identifier .typeParameters
typeParameters -> .TEMPLATE 
transitions ->  {"typeParameters":70,"TEMPLATE":71}

item set 50 
importDeclaration -> IMPORT STATIC .qualifiedName DOT MUL SEMI
importDeclaration -> IMPORT STATIC .qualifiedName SEMI
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters 
transitions ->  {"qualifiedName":72,"Identifier":49}

item set 51 
importDeclaration -> IMPORT qualifiedName .DOT MUL SEMI
importDeclaration -> IMPORT qualifiedName .SEMI
qualifiedName -> qualifiedName .DOT Identifier
qualifiedName -> qualifiedName .DOT Identifier typeParameters 
transitions ->  {"DOT":73,"SEMI":74}

item set 52 
typeDeclarationWithPrefixes -> modifierL annotationl .typeDeclaration
annotationl -> annotationl .annotation
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody 
transitions ->  {"typeDeclaration":75,"annotation":63,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"AT":14,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 53 
typeDeclarationWithPrefixes -> modifierL typeDeclaration . 
transitions ->  {}

item set 54 
modifierL -> modifierL modifier . 
transitions ->  {}

item set 55 
annotation -> AT qualifiedName .
annotation -> AT qualifiedName .LPAREN elementValueList RPAREN
annotation -> AT qualifiedName .LPAREN elementValuePairs RPAREN
qualifiedName -> qualifiedName .DOT Identifier
qualifiedName -> qualifiedName .DOT Identifier typeParameters 
transitions ->  {"LPAREN":76,"DOT":69}

item set 56 
annotationTypeDeclaration -> AT INTERFACE .Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> AT INTERFACE .Identifier EXTENDS typeList commentReturn annotationTypeBody 
transitions ->  {"Identifier":77}

item set 57 
classDeclaration -> CLASS Identifier .classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> CLASS Identifier .typeParameters classInheritance interfaceImplentation commentReturn classBody
classInheritance -> .
classInheritance -> .EXTENDS type
typeParameters -> .TEMPLATE 
transitions ->  {"classInheritance":78,"typeParameters":79,"EXTENDS":80,"TEMPLATE":71}

item set 58 
interfaceDeclaration -> INTERFACE Identifier .optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> INTERFACE Identifier .optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
optionalTypeParameters -> .
optionalTypeParameters -> .typeParameters
typeParameters -> .TEMPLATE 
transitions ->  {"optionalTypeParameters":81,"typeParameters":82,"TEMPLATE":71}

item set 59 
enumDeclaration -> ENUM Identifier .interfaceImplentation commentReturn enumBody
interfaceImplentation -> .
interfaceImplentation -> .IMPLEMENTS typeList 
transitions ->  {"interfaceImplentation":83,"IMPLEMENTS":84}

item set 60 
compilationUnit -> packageDeclaration importDeclarations EOF . 
transitions ->  {}

item set 61 
compilationUnit -> packageDeclaration importDeclarations typeDeclarations .EOF
typeDeclarations -> typeDeclarations .typeDeclarationWithPrefixes
typeDeclarationWithPrefixes -> .annotationl modifierL typeDeclaration
typeDeclarationWithPrefixes -> .modifierL annotationl typeDeclaration
typeDeclarationWithPrefixes -> .modifierL typeDeclaration
typeDeclarationWithPrefixes -> .annotationl typeDeclaration
typeDeclarationWithPrefixes -> .typeDeclaration
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody 
transitions ->  {"EOF":85,"typeDeclarationWithPrefixes":42,"annotationl":37,"modifierL":12,"typeDeclaration":13,"annotation":10,"modifier":15,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 62 
compilationUnit -> packageDeclaration typeDeclarations EOF . 
transitions ->  {}

item set 63 
annotationl -> annotationl annotation . 
transitions ->  {}

item set 64 
compilationUnit -> importDeclarations typeDeclarations EOF . 
transitions ->  {}

item set 65 
typeDeclarationWithPrefixes -> annotationl modifierL typeDeclaration . 
transitions ->  {}

item set 66 
annotationTypeDeclaration -> AT .INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> AT .INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody 
transitions ->  {"INTERFACE":56}

item set 67 
annotation -> AT .qualifiedName
annotation -> AT .qualifiedName LPAREN elementValueList RPAREN
annotation -> AT .qualifiedName LPAREN elementValuePairs RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters 
transitions ->  {"qualifiedName":55,"Identifier":49}

item set 68 
packageDeclaration -> PACKAGE qualifiedName SEMI . 
transitions ->  {}

item set 69 
qualifiedName -> qualifiedName DOT .Identifier
qualifiedName -> qualifiedName DOT .Identifier typeParameters 
transitions ->  {"Identifier":86}

item set 70 
qualifiedName -> Identifier typeParameters . 
transitions ->  {}

item set 71 
typeParameters -> TEMPLATE . 
transitions ->  {}

item set 72 
importDeclaration -> IMPORT STATIC qualifiedName .DOT MUL SEMI
importDeclaration -> IMPORT STATIC qualifiedName .SEMI
qualifiedName -> qualifiedName .DOT Identifier
qualifiedName -> qualifiedName .DOT Identifier typeParameters 
transitions ->  {"DOT":87,"SEMI":88}

item set 73 
importDeclaration -> IMPORT qualifiedName DOT .MUL SEMI
qualifiedName -> qualifiedName DOT .Identifier
qualifiedName -> qualifiedName DOT .Identifier typeParameters 
transitions ->  {"MUL":89,"Identifier":86}

item set 74 
importDeclaration -> IMPORT qualifiedName SEMI . 
transitions ->  {}

item set 75 
typeDeclarationWithPrefixes -> modifierL annotationl typeDeclaration . 
transitions ->  {}

item set 76 
annotation -> AT qualifiedName LPAREN .elementValueList RPAREN
annotation -> AT qualifiedName LPAREN .elementValuePairs RPAREN
elementValueList -> .elementValue
elementValueList -> .elementValueList COMMA elementValue
elementValuePairs -> .elementValuePair
elementValuePairs -> .elementValuePairs COMMA elementValuePair
elementValue -> .expression
elementValue -> .annotations
elementValue -> .LBRACE RBRACE
elementValue -> .LBRACE elementValueList RBRACE
elementValuePair -> .Identifier ASSIGN elementValue
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
annotations -> .
annotations -> .annotationl
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE
annotationl -> .annotation
annotationl -> .annotationl annotation
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN 
transitions ->  {"elementValueList":90,"elementValuePairs":91,"elementValue":92,"elementValuePair":93,"expression":94,"annotations":95,"LBRACE":96,"Identifier":97,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"annotationl":114,"LPAREN":115,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131,"annotation":10,"AT":67}

item set 77 
annotationTypeDeclaration -> AT INTERFACE Identifier .commentReturn annotationTypeBody
annotationTypeDeclaration -> AT INTERFACE Identifier .EXTENDS typeList commentReturn annotationTypeBody
commentReturn -> . 
transitions ->  {"commentReturn":132,"EXTENDS":133}

item set 78 
classDeclaration -> CLASS Identifier classInheritance .interfaceImplentation commentReturn classBody
interfaceImplentation -> .
interfaceImplentation -> .IMPLEMENTS typeList 
transitions ->  {"interfaceImplentation":134,"IMPLEMENTS":84}

item set 79 
classDeclaration -> CLASS Identifier typeParameters .classInheritance interfaceImplentation commentReturn classBody
classInheritance -> .
classInheritance -> .EXTENDS type 
transitions ->  {"classInheritance":135,"EXTENDS":80}

item set 80 
classInheritance -> EXTENDS .type
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"type":136,"qualifiedName":137,"primitiveType":138,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 81 
interfaceDeclaration -> INTERFACE Identifier optionalTypeParameters .commentReturn interfaceBody
interfaceDeclaration -> INTERFACE Identifier optionalTypeParameters .EXTENDS typeList commentReturn interfaceBody
commentReturn -> . 
transitions ->  {"commentReturn":139,"EXTENDS":140}

item set 82 
optionalTypeParameters -> typeParameters . 
transitions ->  {}

item set 83 
enumDeclaration -> ENUM Identifier interfaceImplentation .commentReturn enumBody
commentReturn -> . 
transitions ->  {"commentReturn":141}

item set 84 
interfaceImplentation -> IMPLEMENTS .typeList
typeList -> .type
typeList -> .typeList COMMA type
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"typeList":142,"type":143,"qualifiedName":137,"primitiveType":138,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 85 
compilationUnit -> packageDeclaration importDeclarations typeDeclarations EOF . 
transitions ->  {}

item set 86 
qualifiedName -> qualifiedName DOT Identifier .
qualifiedName -> qualifiedName DOT Identifier .typeParameters
typeParameters -> .TEMPLATE 
transitions ->  {"typeParameters":144,"TEMPLATE":71}

item set 87 
importDeclaration -> IMPORT STATIC qualifiedName DOT .MUL SEMI
qualifiedName -> qualifiedName DOT .Identifier
qualifiedName -> qualifiedName DOT .Identifier typeParameters 
transitions ->  {"MUL":145,"Identifier":86}

item set 88 
importDeclaration -> IMPORT STATIC qualifiedName SEMI . 
transitions ->  {}

item set 89 
importDeclaration -> IMPORT qualifiedName DOT MUL .SEMI 
transitions ->  {"SEMI":146}

item set 90 
annotation -> AT qualifiedName LPAREN elementValueList .RPAREN
elementValueList -> elementValueList .COMMA elementValue 
transitions ->  {"RPAREN":147,"COMMA":148}

item set 91 
annotation -> AT qualifiedName LPAREN elementValuePairs .RPAREN
elementValuePairs -> elementValuePairs .COMMA elementValuePair 
transitions ->  {"RPAREN":149,"COMMA":150}

item set 92 
elementValueList -> elementValue . 
transitions ->  {}

item set 93 
elementValuePairs -> elementValuePair . 
transitions ->  {}

item set 94 
elementValue -> expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":151,"LBRACK":152,"arguments":153,"LPAREN":154,"incrementOrDecrement":155,"mulDivOrMod":156,"addOrSub":157,"LSHIFT":158,"GT":159,"lE_GE_LT_GT":160,"INSTANCEOF":161,"equals_NotEqual":162,"BITAND":163,"CARET":164,"BITOR":165,"AND":166,"OR":167,"QUESTION":168,"assignmentToken":169,"INC":170,"DEC":171,"MUL":172,"DIV":173,"MOD":174,"ADD":175,"SUB":176,"LE":177,"GE":178,"LT":179,"EQUAL":180,"NOTEQUAL":181,"ASSIGN":182,"ADD_ASSIGN":183,"SUB_ASSIGN":184,"MUL_ASSIGN":185,"DIV_ASSIGN":186,"AND_ASSIGN":187,"OR_ASSIGN":188,"XOR_ASSIGN":189,"RSHIFT_ASSIGN":190,"URSHIFT_ASSIGN":191,"LSHIFT_ASSIGN":192,"MOD_ASSIGN":193}

item set 95 
elementValue -> annotations . 
transitions ->  {}

item set 96 
elementValue -> LBRACE .RBRACE
elementValue -> LBRACE .elementValueList RBRACE
elementValueList -> .elementValue
elementValueList -> .elementValueList COMMA elementValue
elementValue -> .expression
elementValue -> .annotations
elementValue -> .LBRACE RBRACE
elementValue -> .LBRACE elementValueList RBRACE
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
annotations -> .
annotations -> .annotationl
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE
annotationl -> .annotation
annotationl -> .annotationl annotation
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN 
transitions ->  {"RBRACE":194,"elementValueList":195,"elementValue":92,"expression":94,"annotations":95,"LBRACE":96,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"annotationl":114,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131,"annotation":10,"AT":67}

item set 97 
elementValuePair -> Identifier .ASSIGN elementValue
qualifiedName -> Identifier .
qualifiedName -> Identifier .typeParameters
typeParameters -> .TEMPLATE 
transitions ->  {"ASSIGN":196,"typeParameters":70,"TEMPLATE":71}

item set 98 
expression -> parExpression .
expression -> parExpression .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":197,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 99 
expression -> qualifiedName .
expression -> qualifiedName .DOT CLASS
expression -> qualifiedName .DOT SUPER
expression -> qualifiedName .DOT SUPER DOT expression
expression -> qualifiedName .DOT newCreator
expression -> qualifiedName .arrayDimensionBrackl DOT CLASS
expression -> qualifiedName .DOT THIS
expression -> qualifiedName .DOT explicitGenericInvocation
expression -> qualifiedName .LBRACK expression RBRACK
qualifiedName -> qualifiedName .DOT Identifier
qualifiedName -> qualifiedName .DOT Identifier typeParameters
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"DOT":198,"arrayDimensionBrackl":199,"LBRACK":200,"arrayDimensionBrack":201}

item set 100 
expression -> primitiveType .DOT CLASS
expression -> primitiveType .arrayDimensionBrackl DOT CLASS
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"DOT":202,"arrayDimensionBrackl":203,"arrayDimensionBrack":201,"LBRACK":204}

item set 101 
expression -> newCreator . 
transitions ->  {}

item set 102 
expression -> plusMinusIncOrDec .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":205,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 103 
expression -> prefixTildeOrBang .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":206,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 104 
expression -> THIS . 
transitions ->  {}

item set 105 
expression -> SUPER . 
transitions ->  {}

item set 106 
expression -> IntegerLiteral . 
transitions ->  {}

item set 107 
expression -> FloatingPointLiteral . 
transitions ->  {}

item set 108 
expression -> CharacterLiteral . 
transitions ->  {}

item set 109 
expression -> StringLiteral . 
transitions ->  {}

item set 110 
expression -> BooleanLiteral . 
transitions ->  {}

item set 111 
expression -> NullLiteral . 
transitions ->  {}

item set 112 
expression -> VOID .DOT CLASS 
transitions ->  {"DOT":207}

item set 113 
expression -> nonWildcardTypeArguments .explicitGenericInvocationSuffixOrThisArgs
explicitGenericInvocationSuffixOrThisArgs -> .explicitGenericInvocationSuffix
explicitGenericInvocationSuffixOrThisArgs -> .THIS arguments
explicitGenericInvocationSuffix -> .SUPER superSuffix
explicitGenericInvocationSuffix -> .Identifier arguments 
transitions ->  {"explicitGenericInvocationSuffixOrThisArgs":208,"explicitGenericInvocationSuffix":209,"THIS":210,"SUPER":211,"Identifier":212}

item set 114 
annotations -> annotationl .
annotationl -> annotationl .annotation
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN 
transitions ->  {"annotation":63,"AT":67}

item set 115 
parExpression -> LPAREN .expression RPAREN
parExpression -> LPAREN .primitiveType RPAREN
parExpression -> LPAREN .qualifiedName arrayDimensionBrackl RPAREN
parExpression -> LPAREN .qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> LPAREN .qualifiedName typeParameters RPAREN
parExpression -> LPAREN .primitiveType arrayDimensionBrackl RPAREN
parExpression -> LPAREN .expression RPAREN
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":213,"primitiveType":214,"qualifiedName":215,"parExpression":98,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"Identifier":49,"LPAREN":115,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 116 
primitiveType -> BOOLEAN . 
transitions ->  {}

item set 117 
primitiveType -> CHAR . 
transitions ->  {}

item set 118 
primitiveType -> BYTE . 
transitions ->  {}

item set 119 
primitiveType -> SHORT . 
transitions ->  {}

item set 120 
primitiveType -> INT . 
transitions ->  {}

item set 121 
primitiveType -> LONG . 
transitions ->  {}

item set 122 
primitiveType -> FLOAT . 
transitions ->  {}

item set 123 
primitiveType -> DOUBLE . 
transitions ->  {}

item set 124 
newCreator -> NEW .creator
creator -> .nonWildcardTypeArguments createdName classCreatorRest
creator -> .createdName arrayOrClassCreator
nonWildcardTypeArguments -> .TEMPLATE
createdName -> .qualifiedName optionalTypeArgumentsOrDiamonds
createdName -> .primitiveType
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"creator":216,"nonWildcardTypeArguments":217,"createdName":218,"TEMPLATE":131,"qualifiedName":219,"primitiveType":220,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 125 
plusMinusIncOrDec -> ADD . 
transitions ->  {}

item set 126 
plusMinusIncOrDec -> SUB . 
transitions ->  {}

item set 127 
plusMinusIncOrDec -> INC . 
transitions ->  {}

item set 128 
plusMinusIncOrDec -> DEC . 
transitions ->  {}

item set 129 
prefixTildeOrBang -> TILDE . 
transitions ->  {}

item set 130 
prefixTildeOrBang -> BANG . 
transitions ->  {}

item set 131 
nonWildcardTypeArguments -> TEMPLATE . 
transitions ->  {}

item set 132 
annotationTypeDeclaration -> AT INTERFACE Identifier commentReturn .annotationTypeBody
annotationTypeBody -> .LBRACE RBRACE
annotationTypeBody -> .LBRACE annotationTypeElementDeclarations RBRACE 
transitions ->  {"annotationTypeBody":221,"LBRACE":222}

item set 133 
annotationTypeDeclaration -> AT INTERFACE Identifier EXTENDS .typeList commentReturn annotationTypeBody
typeList -> .type
typeList -> .typeList COMMA type
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"typeList":223,"type":143,"qualifiedName":137,"primitiveType":138,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 134 
classDeclaration -> CLASS Identifier classInheritance interfaceImplentation .commentReturn classBody
commentReturn -> . 
transitions ->  {"commentReturn":224}

item set 135 
classDeclaration -> CLASS Identifier typeParameters classInheritance .interfaceImplentation commentReturn classBody
interfaceImplentation -> .
interfaceImplentation -> .IMPLEMENTS typeList 
transitions ->  {"interfaceImplentation":225,"IMPLEMENTS":84}

item set 136 
classInheritance -> EXTENDS type . 
transitions ->  {}

item set 137 
type -> qualifiedName .arrayDimensionBracks
qualifiedName -> qualifiedName .DOT Identifier
qualifiedName -> qualifiedName .DOT Identifier typeParameters
arrayDimensionBracks -> .
arrayDimensionBracks -> .arrayDimensionBrackl
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"arrayDimensionBracks":226,"DOT":69,"arrayDimensionBrackl":227,"arrayDimensionBrack":201,"LBRACK":204}

item set 138 
type -> primitiveType .arrayDimensionBracks
arrayDimensionBracks -> .
arrayDimensionBracks -> .arrayDimensionBrackl
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"arrayDimensionBracks":228,"arrayDimensionBrackl":227,"arrayDimensionBrack":201,"LBRACK":204}

item set 139 
interfaceDeclaration -> INTERFACE Identifier optionalTypeParameters commentReturn .interfaceBody
interfaceBody -> .LBRACE RBRACE
interfaceBody -> .LBRACE interfaceBodyDeclarationl RBRACE 
transitions ->  {"interfaceBody":229,"LBRACE":230}

item set 140 
interfaceDeclaration -> INTERFACE Identifier optionalTypeParameters EXTENDS .typeList commentReturn interfaceBody
typeList -> .type
typeList -> .typeList COMMA type
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"typeList":231,"type":143,"qualifiedName":137,"primitiveType":138,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 141 
enumDeclaration -> ENUM Identifier interfaceImplentation commentReturn .enumBody
enumBody -> .LBRACE RBRACE
enumBody -> .LBRACE enumBodyDeclaration RBRACE 
transitions ->  {"enumBody":232,"LBRACE":233}

item set 142 
interfaceImplentation -> IMPLEMENTS typeList .
typeList -> typeList .COMMA type 
transitions ->  {"COMMA":234}

item set 143 
typeList -> type . 
transitions ->  {}

item set 144 
qualifiedName -> qualifiedName DOT Identifier typeParameters . 
transitions ->  {}

item set 145 
importDeclaration -> IMPORT STATIC qualifiedName DOT MUL .SEMI 
transitions ->  {"SEMI":235}

item set 146 
importDeclaration -> IMPORT qualifiedName DOT MUL SEMI . 
transitions ->  {}

item set 147 
annotation -> AT qualifiedName LPAREN elementValueList RPAREN . 
transitions ->  {}

item set 148 
elementValueList -> elementValueList COMMA .elementValue
elementValue -> .expression
elementValue -> .annotations
elementValue -> .LBRACE RBRACE
elementValue -> .LBRACE elementValueList RBRACE
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
annotations -> .
annotations -> .annotationl
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE
annotationl -> .annotation
annotationl -> .annotationl annotation
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN 
transitions ->  {"elementValue":236,"expression":94,"annotations":95,"LBRACE":96,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"annotationl":114,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131,"annotation":10,"AT":67}

item set 149 
annotation -> AT qualifiedName LPAREN elementValuePairs RPAREN . 
transitions ->  {}

item set 150 
elementValuePairs -> elementValuePairs COMMA .elementValuePair
elementValuePair -> .Identifier ASSIGN elementValue 
transitions ->  {"elementValuePair":237,"Identifier":238}

item set 151 
expression -> expression DOT .qualifiedName
expression -> expression DOT .SUPER
expression -> expression DOT .SUPER DOT expression
expression -> expression DOT .SUPER arguments
expression -> expression DOT .SUPER LPAREN RPAREN
expression -> expression DOT .newCreator
expression -> expression DOT .THIS
expression -> expression DOT .NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression DOT .qualifiedName
expression -> expression DOT .typeParameters Identifier arguments
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
newCreator -> .NEW creator
typeParameters -> .TEMPLATE 
transitions ->  {"qualifiedName":239,"SUPER":240,"newCreator":241,"THIS":242,"NEW":243,"typeParameters":244,"Identifier":49,"TEMPLATE":71}

item set 152 
expression -> expression LBRACK .expression RBRACK
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":245,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 153 
expression -> expression arguments . 
transitions ->  {}

item set 154 
expression -> expression LPAREN .RPAREN
arguments -> LPAREN .RPAREN
arguments -> LPAREN .expressionList RPAREN
expressionList -> .expression
expressionList -> .expressionList COMMA expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"RPAREN":246,"expressionList":247,"expression":248,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 155 
expression -> expression incrementOrDecrement . 
transitions ->  {}

item set 156 
expression -> expression mulDivOrMod .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":249,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 157 
expression -> expression addOrSub .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":250,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 158 
expression -> expression LSHIFT .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":251,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 159 
expression -> expression GT .GT expression
expression -> expression GT .GT GT expression
lE_GE_LT_GT -> GT . 
transitions ->  {"GT":252}

item set 160 
expression -> expression lE_GE_LT_GT .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":253,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 161 
expression -> expression INSTANCEOF .type
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"type":254,"qualifiedName":137,"primitiveType":138,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 162 
expression -> expression equals_NotEqual .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":255,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 163 
expression -> expression BITAND .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":256,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 164 
expression -> expression CARET .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":257,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 165 
expression -> expression BITOR .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":258,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 166 
expression -> expression AND .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":259,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 167 
expression -> expression OR .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":260,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 168 
expression -> expression QUESTION .expression COLON expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":261,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 169 
expression -> expression assignmentToken .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":262,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 170 
incrementOrDecrement -> INC . 
transitions ->  {}

item set 171 
incrementOrDecrement -> DEC . 
transitions ->  {}

item set 172 
mulDivOrMod -> MUL . 
transitions ->  {}

item set 173 
mulDivOrMod -> DIV . 
transitions ->  {}

item set 174 
mulDivOrMod -> MOD . 
transitions ->  {}

item set 175 
addOrSub -> ADD . 
transitions ->  {}

item set 176 
addOrSub -> SUB . 
transitions ->  {}

item set 177 
lE_GE_LT_GT -> LE . 
transitions ->  {}

item set 178 
lE_GE_LT_GT -> GE . 
transitions ->  {}

item set 179 
lE_GE_LT_GT -> LT . 
transitions ->  {}

item set 180 
equals_NotEqual -> EQUAL . 
transitions ->  {}

item set 181 
equals_NotEqual -> NOTEQUAL . 
transitions ->  {}

item set 182 
assignmentToken -> ASSIGN . 
transitions ->  {}

item set 183 
assignmentToken -> ADD_ASSIGN . 
transitions ->  {}

item set 184 
assignmentToken -> SUB_ASSIGN . 
transitions ->  {}

item set 185 
assignmentToken -> MUL_ASSIGN . 
transitions ->  {}

item set 186 
assignmentToken -> DIV_ASSIGN . 
transitions ->  {}

item set 187 
assignmentToken -> AND_ASSIGN . 
transitions ->  {}

item set 188 
assignmentToken -> OR_ASSIGN . 
transitions ->  {}

item set 189 
assignmentToken -> XOR_ASSIGN . 
transitions ->  {}

item set 190 
assignmentToken -> RSHIFT_ASSIGN . 
transitions ->  {}

item set 191 
assignmentToken -> URSHIFT_ASSIGN . 
transitions ->  {}

item set 192 
assignmentToken -> LSHIFT_ASSIGN . 
transitions ->  {}

item set 193 
assignmentToken -> MOD_ASSIGN . 
transitions ->  {}

item set 194 
elementValue -> LBRACE RBRACE . 
transitions ->  {}

item set 195 
elementValue -> LBRACE elementValueList .RBRACE
elementValueList -> elementValueList .COMMA elementValue 
transitions ->  {"RBRACE":263,"COMMA":148}

item set 196 
elementValuePair -> Identifier ASSIGN .elementValue
elementValue -> .expression
elementValue -> .annotations
elementValue -> .LBRACE RBRACE
elementValue -> .LBRACE elementValueList RBRACE
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
annotations -> .
annotations -> .annotationl
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE
annotationl -> .annotation
annotationl -> .annotationl annotation
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN 
transitions ->  {"elementValue":264,"expression":94,"annotations":95,"LBRACE":96,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"annotationl":114,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131,"annotation":10,"AT":67}

item set 197 
expression -> parExpression expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":151,"LBRACK":152,"arguments":153,"LPAREN":154,"incrementOrDecrement":155,"mulDivOrMod":156,"addOrSub":157,"LSHIFT":158,"GT":159,"lE_GE_LT_GT":160,"INSTANCEOF":161,"equals_NotEqual":162,"BITAND":163,"CARET":164,"BITOR":165,"AND":166,"OR":167,"QUESTION":168,"assignmentToken":169,"INC":170,"DEC":171,"MUL":172,"DIV":173,"MOD":174,"ADD":175,"SUB":176,"LE":177,"GE":178,"LT":179,"EQUAL":180,"NOTEQUAL":181,"ASSIGN":182,"ADD_ASSIGN":183,"SUB_ASSIGN":184,"MUL_ASSIGN":185,"DIV_ASSIGN":186,"AND_ASSIGN":187,"OR_ASSIGN":188,"XOR_ASSIGN":189,"RSHIFT_ASSIGN":190,"URSHIFT_ASSIGN":191,"LSHIFT_ASSIGN":192,"MOD_ASSIGN":193}

item set 198 
expression -> qualifiedName DOT .CLASS
expression -> qualifiedName DOT .SUPER
expression -> qualifiedName DOT .SUPER DOT expression
expression -> qualifiedName DOT .newCreator
expression -> qualifiedName DOT .THIS
expression -> qualifiedName DOT .explicitGenericInvocation
qualifiedName -> qualifiedName DOT .Identifier
qualifiedName -> qualifiedName DOT .Identifier typeParameters
newCreator -> .NEW creator
explicitGenericInvocation -> .nonWildcardTypeArguments explicitGenericInvocationSuffix
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"CLASS":265,"SUPER":266,"newCreator":267,"THIS":268,"explicitGenericInvocation":269,"Identifier":86,"NEW":124,"nonWildcardTypeArguments":270,"TEMPLATE":131}

item set 199 
expression -> qualifiedName arrayDimensionBrackl .DOT CLASS
arrayDimensionBrackl -> arrayDimensionBrackl .arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"DOT":271,"arrayDimensionBrack":272,"LBRACK":204}

item set 200 
expression -> qualifiedName LBRACK .expression RBRACK
arrayDimensionBrack -> LBRACK .RBRACK
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":273,"RBRACK":274,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 201 
arrayDimensionBrackl -> arrayDimensionBrack . 
transitions ->  {}

item set 202 
expression -> primitiveType DOT .CLASS 
transitions ->  {"CLASS":275}

item set 203 
expression -> primitiveType arrayDimensionBrackl .DOT CLASS
arrayDimensionBrackl -> arrayDimensionBrackl .arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"DOT":276,"arrayDimensionBrack":272,"LBRACK":204}

item set 204 
arrayDimensionBrack -> LBRACK .RBRACK 
transitions ->  {"RBRACK":274}

item set 205 
expression -> plusMinusIncOrDec expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":151,"LBRACK":152,"arguments":153,"LPAREN":154,"incrementOrDecrement":155,"mulDivOrMod":156,"addOrSub":157,"LSHIFT":158,"GT":159,"lE_GE_LT_GT":160,"INSTANCEOF":161,"equals_NotEqual":162,"BITAND":163,"CARET":164,"BITOR":165,"AND":166,"OR":167,"QUESTION":168,"assignmentToken":169,"INC":170,"DEC":171,"MUL":172,"DIV":173,"MOD":174,"ADD":175,"SUB":176,"LE":177,"GE":178,"LT":179,"EQUAL":180,"NOTEQUAL":181,"ASSIGN":182,"ADD_ASSIGN":183,"SUB_ASSIGN":184,"MUL_ASSIGN":185,"DIV_ASSIGN":186,"AND_ASSIGN":187,"OR_ASSIGN":188,"XOR_ASSIGN":189,"RSHIFT_ASSIGN":190,"URSHIFT_ASSIGN":191,"LSHIFT_ASSIGN":192,"MOD_ASSIGN":193}

item set 206 
expression -> prefixTildeOrBang expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":151,"LBRACK":152,"arguments":153,"LPAREN":154,"incrementOrDecrement":155,"mulDivOrMod":156,"addOrSub":157,"LSHIFT":158,"GT":159,"lE_GE_LT_GT":160,"INSTANCEOF":161,"equals_NotEqual":162,"BITAND":163,"CARET":164,"BITOR":165,"AND":166,"OR":167,"QUESTION":168,"assignmentToken":169,"INC":170,"DEC":171,"MUL":172,"DIV":173,"MOD":174,"ADD":175,"SUB":176,"LE":177,"GE":178,"LT":179,"EQUAL":180,"NOTEQUAL":181,"ASSIGN":182,"ADD_ASSIGN":183,"SUB_ASSIGN":184,"MUL_ASSIGN":185,"DIV_ASSIGN":186,"AND_ASSIGN":187,"OR_ASSIGN":188,"XOR_ASSIGN":189,"RSHIFT_ASSIGN":190,"URSHIFT_ASSIGN":191,"LSHIFT_ASSIGN":192,"MOD_ASSIGN":193}

item set 207 
expression -> VOID DOT .CLASS 
transitions ->  {"CLASS":277}

item set 208 
expression -> nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs . 
transitions ->  {}

item set 209 
explicitGenericInvocationSuffixOrThisArgs -> explicitGenericInvocationSuffix . 
transitions ->  {}

item set 210 
explicitGenericInvocationSuffixOrThisArgs -> THIS .arguments
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN 
transitions ->  {"arguments":278,"LPAREN":279}

item set 211 
explicitGenericInvocationSuffix -> SUPER .superSuffix
superSuffix -> .arguments
superSuffix -> .DOT Identifier
superSuffix -> .DOT Identifier arguments
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN 
transitions ->  {"superSuffix":280,"arguments":281,"DOT":282,"LPAREN":279}

item set 212 
explicitGenericInvocationSuffix -> Identifier .arguments
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN 
transitions ->  {"arguments":283,"LPAREN":279}

item set 213 
parExpression -> LPAREN expression .RPAREN
parExpression -> LPAREN expression .RPAREN
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"RPAREN":284,"DOT":151,"LBRACK":152,"arguments":153,"LPAREN":154,"incrementOrDecrement":155,"mulDivOrMod":156,"addOrSub":157,"LSHIFT":158,"GT":159,"lE_GE_LT_GT":160,"INSTANCEOF":161,"equals_NotEqual":162,"BITAND":163,"CARET":164,"BITOR":165,"AND":166,"OR":167,"QUESTION":168,"assignmentToken":169,"INC":170,"DEC":171,"MUL":172,"DIV":173,"MOD":174,"ADD":175,"SUB":176,"LE":177,"GE":178,"LT":179,"EQUAL":180,"NOTEQUAL":181,"ASSIGN":182,"ADD_ASSIGN":183,"SUB_ASSIGN":184,"MUL_ASSIGN":185,"DIV_ASSIGN":186,"AND_ASSIGN":187,"OR_ASSIGN":188,"XOR_ASSIGN":189,"RSHIFT_ASSIGN":190,"URSHIFT_ASSIGN":191,"LSHIFT_ASSIGN":192,"MOD_ASSIGN":193}

item set 214 
parExpression -> LPAREN primitiveType .RPAREN
parExpression -> LPAREN primitiveType .arrayDimensionBrackl RPAREN
expression -> primitiveType .DOT CLASS
expression -> primitiveType .arrayDimensionBrackl DOT CLASS
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"RPAREN":285,"arrayDimensionBrackl":286,"DOT":202,"arrayDimensionBrack":201,"LBRACK":204}

item set 215 
parExpression -> LPAREN qualifiedName .arrayDimensionBrackl RPAREN
parExpression -> LPAREN qualifiedName .typeParameters arrayDimensionBrackl RPAREN
parExpression -> LPAREN qualifiedName .typeParameters RPAREN
expression -> qualifiedName .
expression -> qualifiedName .DOT CLASS
expression -> qualifiedName .DOT SUPER
expression -> qualifiedName .DOT SUPER DOT expression
expression -> qualifiedName .DOT newCreator
expression -> qualifiedName .arrayDimensionBrackl DOT CLASS
expression -> qualifiedName .DOT THIS
expression -> qualifiedName .DOT explicitGenericInvocation
expression -> qualifiedName .LBRACK expression RBRACK
qualifiedName -> qualifiedName .DOT Identifier
qualifiedName -> qualifiedName .DOT Identifier typeParameters
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
typeParameters -> .TEMPLATE
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"arrayDimensionBrackl":287,"typeParameters":288,"DOT":198,"LBRACK":200,"arrayDimensionBrack":201,"TEMPLATE":71}

item set 216 
newCreator -> NEW creator . 
transitions ->  {}

item set 217 
creator -> nonWildcardTypeArguments .createdName classCreatorRest
createdName -> .qualifiedName optionalTypeArgumentsOrDiamonds
createdName -> .primitiveType
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"createdName":289,"qualifiedName":219,"primitiveType":220,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 218 
creator -> createdName .arrayOrClassCreator
arrayOrClassCreator -> .arrayCreatorRest
arrayOrClassCreator -> .classCreatorRest
arrayCreatorRest -> .LBRACK RBRACK arrayDimensionBracks arrayInitializer
arrayCreatorRest -> .bracketedExpressions arrayDimensionBracks
classCreatorRest -> .arguments
classCreatorRest -> .LPAREN RPAREN
classCreatorRest -> .LPAREN RPAREN classBody
classCreatorRest -> .arguments classBody
bracketedExpressions -> .LBRACK expression RBRACK
bracketedExpressions -> .bracketedExpressions LBRACK expression RBRACK
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN 
transitions ->  {"arrayOrClassCreator":290,"arrayCreatorRest":291,"classCreatorRest":292,"LBRACK":293,"bracketedExpressions":294,"arguments":295,"LPAREN":296}

item set 219 
createdName -> qualifiedName .optionalTypeArgumentsOrDiamonds
qualifiedName -> qualifiedName .DOT Identifier
qualifiedName -> qualifiedName .DOT Identifier typeParameters
optionalTypeArgumentsOrDiamonds -> .
optionalTypeArgumentsOrDiamonds -> .typeArgumentsOrDiamondList
typeArgumentsOrDiamondList -> .typeArgumentsOrDiamond
typeArgumentsOrDiamondList -> .typeArgumentsOrDiamondList DOT Identifier typeArgumentsOrDiamond
typeArgumentsOrDiamond -> .LT GT
typeArgumentsOrDiamond -> .typeParameters
typeParameters -> .TEMPLATE 
transitions ->  {"optionalTypeArgumentsOrDiamonds":297,"DOT":69,"typeArgumentsOrDiamondList":298,"typeArgumentsOrDiamond":299,"LT":300,"typeParameters":301,"TEMPLATE":71}

item set 220 
createdName -> primitiveType . 
transitions ->  {}

item set 221 
annotationTypeDeclaration -> AT INTERFACE Identifier commentReturn annotationTypeBody . 
transitions ->  {}

item set 222 
annotationTypeBody -> LBRACE .RBRACE
annotationTypeBody -> LBRACE .annotationTypeElementDeclarations RBRACE
annotationTypeElementDeclarations -> .annotationTypeElementDeclaration
annotationTypeElementDeclarations -> .annotationTypeElementDeclarations annotationTypeElementDeclaration
annotationTypeElementDeclaration -> .modifierL annotationTypeElementRest
annotationTypeElementDeclaration -> .annotationl annotationTypeElementRest
annotationTypeElementDeclaration -> .annotationl modifierL annotationTypeElementRest
annotationTypeElementDeclaration -> .modifierL annotationl annotationTypeElementRest
annotationTypeElementDeclaration -> .annotationTypeElementRest
annotationTypeElementDeclaration -> .SEMI
modifierL -> .modifier
modifierL -> .modifierL modifier
annotationl -> .annotation
annotationl -> .annotationl annotation
annotationTypeElementRest -> .type annotationConstantRest commentReturn SEMI
annotationTypeElementRest -> .typeParameters type annotationMethodRest commentReturn SEMI
annotationTypeElementRest -> .type annotationMethodRest commentReturn SEMI
annotationTypeElementRest -> .classDeclaration
annotationTypeElementRest -> .interfaceDeclaration
annotationTypeElementRest -> .enumDeclaration
annotationTypeElementRest -> .annotationTypeDeclaration
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
typeParameters -> .TEMPLATE
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"RBRACE":302,"annotationTypeElementDeclarations":303,"annotationTypeElementDeclaration":304,"modifierL":305,"annotationl":306,"annotationTypeElementRest":307,"SEMI":308,"modifier":15,"annotation":10,"type":309,"typeParameters":310,"classDeclaration":311,"interfaceDeclaration":312,"enumDeclaration":313,"annotationTypeDeclaration":314,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"AT":14,"qualifiedName":137,"primitiveType":138,"TEMPLATE":71,"CLASS":31,"INTERFACE":32,"ENUM":33,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 223 
annotationTypeDeclaration -> AT INTERFACE Identifier EXTENDS typeList .commentReturn annotationTypeBody
typeList -> typeList .COMMA type
commentReturn -> . 
transitions ->  {"commentReturn":315,"COMMA":234}

item set 224 
classDeclaration -> CLASS Identifier classInheritance interfaceImplentation commentReturn .classBody
classBody -> .LBRACE RBRACE
classBody -> .LBRACE classBodyDeclarationl RBRACE 
transitions ->  {"classBody":316,"LBRACE":317}

item set 225 
classDeclaration -> CLASS Identifier typeParameters classInheritance interfaceImplentation .commentReturn classBody
commentReturn -> . 
transitions ->  {"commentReturn":318}

item set 226 
type -> qualifiedName arrayDimensionBracks . 
transitions ->  {}

item set 227 
arrayDimensionBracks -> arrayDimensionBrackl .
arrayDimensionBrackl -> arrayDimensionBrackl .arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"arrayDimensionBrack":272,"LBRACK":204}

item set 228 
type -> primitiveType arrayDimensionBracks . 
transitions ->  {}

item set 229 
interfaceDeclaration -> INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody . 
transitions ->  {}

item set 230 
interfaceBody -> LBRACE .RBRACE
interfaceBody -> LBRACE .interfaceBodyDeclarationl RBRACE
interfaceBodyDeclarationl -> .interfaceBodyDeclaration
interfaceBodyDeclarationl -> .interfaceBodyDeclarationl interfaceBodyDeclaration
interfaceBodyDeclaration -> .annotationl modifierL interfaceMemberDeclaration
interfaceBodyDeclaration -> .modifierL annotationl interfaceMemberDeclaration
interfaceBodyDeclaration -> .annotationl interfaceMemberDeclaration
interfaceBodyDeclaration -> .modifierL interfaceMemberDeclaration
interfaceBodyDeclaration -> .interfaceMemberDeclaration
interfaceBodyDeclaration -> .SEMI
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
interfaceMemberDeclaration -> .type constDelarators commentReturn SEMI
interfaceMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
interfaceMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks commentReturn SEMI
interfaceMemberDeclaration -> .VOID Identifier formalParameters commentReturn SEMI
interfaceMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
interfaceMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks commentReturn SEMI
interfaceMemberDeclaration -> .type Identifier formalParameters commentReturn SEMI
interfaceMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
interfaceMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks commentReturn SEMI
interfaceMemberDeclaration -> .typeParameters VOID Identifier formalParameters commentReturn SEMI
interfaceMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
interfaceMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks commentReturn SEMI
interfaceMemberDeclaration -> .typeParameters type Identifier formalParameters commentReturn SEMI
interfaceMemberDeclaration -> .classDeclaration
interfaceMemberDeclaration -> .interfaceDeclaration
interfaceMemberDeclaration -> .enumDeclaration
interfaceMemberDeclaration -> .annotationTypeDeclaration
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
typeParameters -> .TEMPLATE
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"RBRACE":319,"interfaceBodyDeclarationl":320,"interfaceBodyDeclaration":321,"annotationl":322,"modifierL":323,"interfaceMemberDeclaration":324,"SEMI":325,"annotation":10,"modifier":15,"type":326,"VOID":327,"typeParameters":328,"classDeclaration":329,"interfaceDeclaration":330,"enumDeclaration":331,"annotationTypeDeclaration":332,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"qualifiedName":137,"primitiveType":138,"TEMPLATE":71,"CLASS":31,"INTERFACE":32,"ENUM":33,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 231 
interfaceDeclaration -> INTERFACE Identifier optionalTypeParameters EXTENDS typeList .commentReturn interfaceBody
typeList -> typeList .COMMA type
commentReturn -> . 
transitions ->  {"commentReturn":333,"COMMA":234}

item set 232 
enumDeclaration -> ENUM Identifier interfaceImplentation commentReturn enumBody . 
transitions ->  {}

item set 233 
enumBody -> LBRACE .RBRACE
enumBody -> LBRACE .enumBodyDeclaration RBRACE
enumBodyDeclaration -> .enumConstants
enumBodyDeclaration -> .enumConstants COMMA
enumBodyDeclaration -> .enumConstants SEMI
enumBodyDeclaration -> .enumConstants COMMA SEMI
enumBodyDeclaration -> .enumConstants SEMI classBodyDeclarationl
enumBodyDeclaration -> .enumConstants COMMA SEMI classBodyDeclarationl
enumConstants -> .annotations Identifier enumConstantArguments commentReturn enumConstantClassBody
enumConstants -> .enumConstants COMMA annotations Identifier enumConstantArguments commentReturn enumConstantClassBody
annotations -> .
annotations -> .annotationl
annotationl -> .annotation
annotationl -> .annotationl annotation
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN 
transitions ->  {"RBRACE":334,"enumBodyDeclaration":335,"enumConstants":336,"annotations":337,"annotationl":114,"annotation":10,"AT":67}

item set 234 
typeList -> typeList COMMA .type
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"type":338,"qualifiedName":137,"primitiveType":138,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 235 
importDeclaration -> IMPORT STATIC qualifiedName DOT MUL SEMI . 
transitions ->  {}

item set 236 
elementValueList -> elementValueList COMMA elementValue . 
transitions ->  {}

item set 237 
elementValuePairs -> elementValuePairs COMMA elementValuePair . 
transitions ->  {}

item set 238 
elementValuePair -> Identifier .ASSIGN elementValue 
transitions ->  {"ASSIGN":196}

item set 239 
expression -> expression DOT qualifiedName .
expression -> expression DOT qualifiedName .
qualifiedName -> qualifiedName .DOT Identifier
qualifiedName -> qualifiedName .DOT Identifier typeParameters 
transitions ->  {"DOT":69}

item set 240 
expression -> expression DOT SUPER .
expression -> expression DOT SUPER .DOT expression
expression -> expression DOT SUPER .arguments
expression -> expression DOT SUPER .LPAREN RPAREN
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN 
transitions ->  {"DOT":339,"arguments":340,"LPAREN":341}

item set 241 
expression -> expression DOT newCreator . 
transitions ->  {}

item set 242 
expression -> expression DOT THIS . 
transitions ->  {}

item set 243 
expression -> expression DOT NEW .optionalNonWildcardTypeArguments innerCreator
newCreator -> NEW .creator
optionalNonWildcardTypeArguments -> .
optionalNonWildcardTypeArguments -> .nonWildcardTypeArguments
creator -> .nonWildcardTypeArguments createdName classCreatorRest
creator -> .createdName arrayOrClassCreator
nonWildcardTypeArguments -> .TEMPLATE
createdName -> .qualifiedName optionalTypeArgumentsOrDiamonds
createdName -> .primitiveType
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"optionalNonWildcardTypeArguments":342,"creator":216,"nonWildcardTypeArguments":343,"createdName":218,"TEMPLATE":131,"qualifiedName":219,"primitiveType":220,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 244 
expression -> expression DOT typeParameters .Identifier arguments 
transitions ->  {"Identifier":344}

item set 245 
expression -> expression LBRACK expression .RBRACK
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"RBRACK":345,"DOT":151,"LBRACK":152,"arguments":153,"LPAREN":154,"incrementOrDecrement":155,"mulDivOrMod":156,"addOrSub":157,"LSHIFT":158,"GT":159,"lE_GE_LT_GT":160,"INSTANCEOF":161,"equals_NotEqual":162,"BITAND":163,"CARET":164,"BITOR":165,"AND":166,"OR":167,"QUESTION":168,"assignmentToken":169,"INC":170,"DEC":171,"MUL":172,"DIV":173,"MOD":174,"ADD":175,"SUB":176,"LE":177,"GE":178,"LT":179,"EQUAL":180,"NOTEQUAL":181,"ASSIGN":182,"ADD_ASSIGN":183,"SUB_ASSIGN":184,"MUL_ASSIGN":185,"DIV_ASSIGN":186,"AND_ASSIGN":187,"OR_ASSIGN":188,"XOR_ASSIGN":189,"RSHIFT_ASSIGN":190,"URSHIFT_ASSIGN":191,"LSHIFT_ASSIGN":192,"MOD_ASSIGN":193}

item set 246 
expression -> expression LPAREN RPAREN .
arguments -> LPAREN RPAREN . 
transitions ->  {}

item set 247 
arguments -> LPAREN expressionList .RPAREN
expressionList -> expressionList .COMMA expression 
transitions ->  {"RPAREN":346,"COMMA":347}

item set 248 
expressionList -> expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":151,"LBRACK":152,"arguments":153,"LPAREN":154,"incrementOrDecrement":155,"mulDivOrMod":156,"addOrSub":157,"LSHIFT":158,"GT":159,"lE_GE_LT_GT":160,"INSTANCEOF":161,"equals_NotEqual":162,"BITAND":163,"CARET":164,"BITOR":165,"AND":166,"OR":167,"QUESTION":168,"assignmentToken":169,"INC":170,"DEC":171,"MUL":172,"DIV":173,"MOD":174,"ADD":175,"SUB":176,"LE":177,"GE":178,"LT":179,"EQUAL":180,"NOTEQUAL":181,"ASSIGN":182,"ADD_ASSIGN":183,"SUB_ASSIGN":184,"MUL_ASSIGN":185,"DIV_ASSIGN":186,"AND_ASSIGN":187,"OR_ASSIGN":188,"XOR_ASSIGN":189,"RSHIFT_ASSIGN":190,"URSHIFT_ASSIGN":191,"LSHIFT_ASSIGN":192,"MOD_ASSIGN":193}

item set 249 
expression -> expression mulDivOrMod expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":151,"LBRACK":152,"arguments":153,"LPAREN":154,"incrementOrDecrement":155,"mulDivOrMod":156,"addOrSub":157,"LSHIFT":158,"GT":159,"lE_GE_LT_GT":160,"INSTANCEOF":161,"equals_NotEqual":162,"BITAND":163,"CARET":164,"BITOR":165,"AND":166,"OR":167,"QUESTION":168,"assignmentToken":169,"INC":170,"DEC":171,"MUL":172,"DIV":173,"MOD":174,"ADD":175,"SUB":176,"LE":177,"GE":178,"LT":179,"EQUAL":180,"NOTEQUAL":181,"ASSIGN":182,"ADD_ASSIGN":183,"SUB_ASSIGN":184,"MUL_ASSIGN":185,"DIV_ASSIGN":186,"AND_ASSIGN":187,"OR_ASSIGN":188,"XOR_ASSIGN":189,"RSHIFT_ASSIGN":190,"URSHIFT_ASSIGN":191,"LSHIFT_ASSIGN":192,"MOD_ASSIGN":193}

item set 250 
expression -> expression addOrSub expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":151,"LBRACK":152,"arguments":153,"LPAREN":154,"incrementOrDecrement":155,"mulDivOrMod":156,"addOrSub":157,"LSHIFT":158,"GT":159,"lE_GE_LT_GT":160,"INSTANCEOF":161,"equals_NotEqual":162,"BITAND":163,"CARET":164,"BITOR":165,"AND":166,"OR":167,"QUESTION":168,"assignmentToken":169,"INC":170,"DEC":171,"MUL":172,"DIV":173,"MOD":174,"ADD":175,"SUB":176,"LE":177,"GE":178,"LT":179,"EQUAL":180,"NOTEQUAL":181,"ASSIGN":182,"ADD_ASSIGN":183,"SUB_ASSIGN":184,"MUL_ASSIGN":185,"DIV_ASSIGN":186,"AND_ASSIGN":187,"OR_ASSIGN":188,"XOR_ASSIGN":189,"RSHIFT_ASSIGN":190,"URSHIFT_ASSIGN":191,"LSHIFT_ASSIGN":192,"MOD_ASSIGN":193}

item set 251 
expression -> expression LSHIFT expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":151,"LBRACK":152,"arguments":153,"LPAREN":154,"incrementOrDecrement":155,"mulDivOrMod":156,"addOrSub":157,"LSHIFT":158,"GT":159,"lE_GE_LT_GT":160,"INSTANCEOF":161,"equals_NotEqual":162,"BITAND":163,"CARET":164,"BITOR":165,"AND":166,"OR":167,"QUESTION":168,"assignmentToken":169,"INC":170,"DEC":171,"MUL":172,"DIV":173,"MOD":174,"ADD":175,"SUB":176,"LE":177,"GE":178,"LT":179,"EQUAL":180,"NOTEQUAL":181,"ASSIGN":182,"ADD_ASSIGN":183,"SUB_ASSIGN":184,"MUL_ASSIGN":185,"DIV_ASSIGN":186,"AND_ASSIGN":187,"OR_ASSIGN":188,"XOR_ASSIGN":189,"RSHIFT_ASSIGN":190,"URSHIFT_ASSIGN":191,"LSHIFT_ASSIGN":192,"MOD_ASSIGN":193}

item set 252 
expression -> expression GT GT .expression
expression -> expression GT GT .GT expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":348,"GT":349,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 253 
expression -> expression lE_GE_LT_GT expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":151,"LBRACK":152,"arguments":153,"LPAREN":154,"incrementOrDecrement":155,"mulDivOrMod":156,"addOrSub":157,"LSHIFT":158,"GT":159,"lE_GE_LT_GT":160,"INSTANCEOF":161,"equals_NotEqual":162,"BITAND":163,"CARET":164,"BITOR":165,"AND":166,"OR":167,"QUESTION":168,"assignmentToken":169,"INC":170,"DEC":171,"MUL":172,"DIV":173,"MOD":174,"ADD":175,"SUB":176,"LE":177,"GE":178,"LT":179,"EQUAL":180,"NOTEQUAL":181,"ASSIGN":182,"ADD_ASSIGN":183,"SUB_ASSIGN":184,"MUL_ASSIGN":185,"DIV_ASSIGN":186,"AND_ASSIGN":187,"OR_ASSIGN":188,"XOR_ASSIGN":189,"RSHIFT_ASSIGN":190,"URSHIFT_ASSIGN":191,"LSHIFT_ASSIGN":192,"MOD_ASSIGN":193}

item set 254 
expression -> expression INSTANCEOF type . 
transitions ->  {}

item set 255 
expression -> expression equals_NotEqual expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":151,"LBRACK":152,"arguments":153,"LPAREN":154,"incrementOrDecrement":155,"mulDivOrMod":156,"addOrSub":157,"LSHIFT":158,"GT":159,"lE_GE_LT_GT":160,"INSTANCEOF":161,"equals_NotEqual":162,"BITAND":163,"CARET":164,"BITOR":165,"AND":166,"OR":167,"QUESTION":168,"assignmentToken":169,"INC":170,"DEC":171,"MUL":172,"DIV":173,"MOD":174,"ADD":175,"SUB":176,"LE":177,"GE":178,"LT":179,"EQUAL":180,"NOTEQUAL":181,"ASSIGN":182,"ADD_ASSIGN":183,"SUB_ASSIGN":184,"MUL_ASSIGN":185,"DIV_ASSIGN":186,"AND_ASSIGN":187,"OR_ASSIGN":188,"XOR_ASSIGN":189,"RSHIFT_ASSIGN":190,"URSHIFT_ASSIGN":191,"LSHIFT_ASSIGN":192,"MOD_ASSIGN":193}

item set 256 
expression -> expression BITAND expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":151,"LBRACK":152,"arguments":153,"LPAREN":154,"incrementOrDecrement":155,"mulDivOrMod":156,"addOrSub":157,"LSHIFT":158,"GT":159,"lE_GE_LT_GT":160,"INSTANCEOF":161,"equals_NotEqual":162,"BITAND":163,"CARET":164,"BITOR":165,"AND":166,"OR":167,"QUESTION":168,"assignmentToken":169,"INC":170,"DEC":171,"MUL":172,"DIV":173,"MOD":174,"ADD":175,"SUB":176,"LE":177,"GE":178,"LT":179,"EQUAL":180,"NOTEQUAL":181,"ASSIGN":182,"ADD_ASSIGN":183,"SUB_ASSIGN":184,"MUL_ASSIGN":185,"DIV_ASSIGN":186,"AND_ASSIGN":187,"OR_ASSIGN":188,"XOR_ASSIGN":189,"RSHIFT_ASSIGN":190,"URSHIFT_ASSIGN":191,"LSHIFT_ASSIGN":192,"MOD_ASSIGN":193}

item set 257 
expression -> expression CARET expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":151,"LBRACK":152,"arguments":153,"LPAREN":154,"incrementOrDecrement":155,"mulDivOrMod":156,"addOrSub":157,"LSHIFT":158,"GT":159,"lE_GE_LT_GT":160,"INSTANCEOF":161,"equals_NotEqual":162,"BITAND":163,"CARET":164,"BITOR":165,"AND":166,"OR":167,"QUESTION":168,"assignmentToken":169,"INC":170,"DEC":171,"MUL":172,"DIV":173,"MOD":174,"ADD":175,"SUB":176,"LE":177,"GE":178,"LT":179,"EQUAL":180,"NOTEQUAL":181,"ASSIGN":182,"ADD_ASSIGN":183,"SUB_ASSIGN":184,"MUL_ASSIGN":185,"DIV_ASSIGN":186,"AND_ASSIGN":187,"OR_ASSIGN":188,"XOR_ASSIGN":189,"RSHIFT_ASSIGN":190,"URSHIFT_ASSIGN":191,"LSHIFT_ASSIGN":192,"MOD_ASSIGN":193}

item set 258 
expression -> expression BITOR expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":151,"LBRACK":152,"arguments":153,"LPAREN":154,"incrementOrDecrement":155,"mulDivOrMod":156,"addOrSub":157,"LSHIFT":158,"GT":159,"lE_GE_LT_GT":160,"INSTANCEOF":161,"equals_NotEqual":162,"BITAND":163,"CARET":164,"BITOR":165,"AND":166,"OR":167,"QUESTION":168,"assignmentToken":169,"INC":170,"DEC":171,"MUL":172,"DIV":173,"MOD":174,"ADD":175,"SUB":176,"LE":177,"GE":178,"LT":179,"EQUAL":180,"NOTEQUAL":181,"ASSIGN":182,"ADD_ASSIGN":183,"SUB_ASSIGN":184,"MUL_ASSIGN":185,"DIV_ASSIGN":186,"AND_ASSIGN":187,"OR_ASSIGN":188,"XOR_ASSIGN":189,"RSHIFT_ASSIGN":190,"URSHIFT_ASSIGN":191,"LSHIFT_ASSIGN":192,"MOD_ASSIGN":193}

item set 259 
expression -> expression AND expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":151,"LBRACK":152,"arguments":153,"LPAREN":154,"incrementOrDecrement":155,"mulDivOrMod":156,"addOrSub":157,"LSHIFT":158,"GT":159,"lE_GE_LT_GT":160,"INSTANCEOF":161,"equals_NotEqual":162,"BITAND":163,"CARET":164,"BITOR":165,"AND":166,"OR":167,"QUESTION":168,"assignmentToken":169,"INC":170,"DEC":171,"MUL":172,"DIV":173,"MOD":174,"ADD":175,"SUB":176,"LE":177,"GE":178,"LT":179,"EQUAL":180,"NOTEQUAL":181,"ASSIGN":182,"ADD_ASSIGN":183,"SUB_ASSIGN":184,"MUL_ASSIGN":185,"DIV_ASSIGN":186,"AND_ASSIGN":187,"OR_ASSIGN":188,"XOR_ASSIGN":189,"RSHIFT_ASSIGN":190,"URSHIFT_ASSIGN":191,"LSHIFT_ASSIGN":192,"MOD_ASSIGN":193}

item set 260 
expression -> expression OR expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":151,"LBRACK":152,"arguments":153,"LPAREN":154,"incrementOrDecrement":155,"mulDivOrMod":156,"addOrSub":157,"LSHIFT":158,"GT":159,"lE_GE_LT_GT":160,"INSTANCEOF":161,"equals_NotEqual":162,"BITAND":163,"CARET":164,"BITOR":165,"AND":166,"OR":167,"QUESTION":168,"assignmentToken":169,"INC":170,"DEC":171,"MUL":172,"DIV":173,"MOD":174,"ADD":175,"SUB":176,"LE":177,"GE":178,"LT":179,"EQUAL":180,"NOTEQUAL":181,"ASSIGN":182,"ADD_ASSIGN":183,"SUB_ASSIGN":184,"MUL_ASSIGN":185,"DIV_ASSIGN":186,"AND_ASSIGN":187,"OR_ASSIGN":188,"XOR_ASSIGN":189,"RSHIFT_ASSIGN":190,"URSHIFT_ASSIGN":191,"LSHIFT_ASSIGN":192,"MOD_ASSIGN":193}

item set 261 
expression -> expression QUESTION expression .COLON expression
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"COLON":350,"DOT":151,"LBRACK":152,"arguments":153,"LPAREN":154,"incrementOrDecrement":155,"mulDivOrMod":156,"addOrSub":157,"LSHIFT":158,"GT":159,"lE_GE_LT_GT":160,"INSTANCEOF":161,"equals_NotEqual":162,"BITAND":163,"CARET":164,"BITOR":165,"AND":166,"OR":167,"QUESTION":168,"assignmentToken":169,"INC":170,"DEC":171,"MUL":172,"DIV":173,"MOD":174,"ADD":175,"SUB":176,"LE":177,"GE":178,"LT":179,"EQUAL":180,"NOTEQUAL":181,"ASSIGN":182,"ADD_ASSIGN":183,"SUB_ASSIGN":184,"MUL_ASSIGN":185,"DIV_ASSIGN":186,"AND_ASSIGN":187,"OR_ASSIGN":188,"XOR_ASSIGN":189,"RSHIFT_ASSIGN":190,"URSHIFT_ASSIGN":191,"LSHIFT_ASSIGN":192,"MOD_ASSIGN":193}

item set 262 
expression -> expression assignmentToken expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":151,"LBRACK":152,"arguments":153,"LPAREN":154,"incrementOrDecrement":155,"mulDivOrMod":156,"addOrSub":157,"LSHIFT":158,"GT":159,"lE_GE_LT_GT":160,"INSTANCEOF":161,"equals_NotEqual":162,"BITAND":163,"CARET":164,"BITOR":165,"AND":166,"OR":167,"QUESTION":168,"assignmentToken":169,"INC":170,"DEC":171,"MUL":172,"DIV":173,"MOD":174,"ADD":175,"SUB":176,"LE":177,"GE":178,"LT":179,"EQUAL":180,"NOTEQUAL":181,"ASSIGN":182,"ADD_ASSIGN":183,"SUB_ASSIGN":184,"MUL_ASSIGN":185,"DIV_ASSIGN":186,"AND_ASSIGN":187,"OR_ASSIGN":188,"XOR_ASSIGN":189,"RSHIFT_ASSIGN":190,"URSHIFT_ASSIGN":191,"LSHIFT_ASSIGN":192,"MOD_ASSIGN":193}

item set 263 
elementValue -> LBRACE elementValueList RBRACE . 
transitions ->  {}

item set 264 
elementValuePair -> Identifier ASSIGN elementValue . 
transitions ->  {}

item set 265 
expression -> qualifiedName DOT CLASS . 
transitions ->  {}

item set 266 
expression -> qualifiedName DOT SUPER .
expression -> qualifiedName DOT SUPER .DOT expression 
transitions ->  {"DOT":351}

item set 267 
expression -> qualifiedName DOT newCreator . 
transitions ->  {}

item set 268 
expression -> qualifiedName DOT THIS . 
transitions ->  {}

item set 269 
expression -> qualifiedName DOT explicitGenericInvocation . 
transitions ->  {}

item set 270 
explicitGenericInvocation -> nonWildcardTypeArguments .explicitGenericInvocationSuffix
explicitGenericInvocationSuffix -> .SUPER superSuffix
explicitGenericInvocationSuffix -> .Identifier arguments 
transitions ->  {"explicitGenericInvocationSuffix":352,"SUPER":211,"Identifier":212}

item set 271 
expression -> qualifiedName arrayDimensionBrackl DOT .CLASS 
transitions ->  {"CLASS":353}

item set 272 
arrayDimensionBrackl -> arrayDimensionBrackl arrayDimensionBrack . 
transitions ->  {}

item set 273 
expression -> qualifiedName LBRACK expression .RBRACK
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"RBRACK":354,"DOT":151,"LBRACK":152,"arguments":153,"LPAREN":154,"incrementOrDecrement":155,"mulDivOrMod":156,"addOrSub":157,"LSHIFT":158,"GT":159,"lE_GE_LT_GT":160,"INSTANCEOF":161,"equals_NotEqual":162,"BITAND":163,"CARET":164,"BITOR":165,"AND":166,"OR":167,"QUESTION":168,"assignmentToken":169,"INC":170,"DEC":171,"MUL":172,"DIV":173,"MOD":174,"ADD":175,"SUB":176,"LE":177,"GE":178,"LT":179,"EQUAL":180,"NOTEQUAL":181,"ASSIGN":182,"ADD_ASSIGN":183,"SUB_ASSIGN":184,"MUL_ASSIGN":185,"DIV_ASSIGN":186,"AND_ASSIGN":187,"OR_ASSIGN":188,"XOR_ASSIGN":189,"RSHIFT_ASSIGN":190,"URSHIFT_ASSIGN":191,"LSHIFT_ASSIGN":192,"MOD_ASSIGN":193}

item set 274 
arrayDimensionBrack -> LBRACK RBRACK . 
transitions ->  {}

item set 275 
expression -> primitiveType DOT CLASS . 
transitions ->  {}

item set 276 
expression -> primitiveType arrayDimensionBrackl DOT .CLASS 
transitions ->  {"CLASS":355}

item set 277 
expression -> VOID DOT CLASS . 
transitions ->  {}

item set 278 
explicitGenericInvocationSuffixOrThisArgs -> THIS arguments . 
transitions ->  {}

item set 279 
arguments -> LPAREN .RPAREN
arguments -> LPAREN .expressionList RPAREN
expressionList -> .expression
expressionList -> .expressionList COMMA expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"RPAREN":356,"expressionList":247,"expression":248,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 280 
explicitGenericInvocationSuffix -> SUPER superSuffix . 
transitions ->  {}

item set 281 
superSuffix -> arguments . 
transitions ->  {}

item set 282 
superSuffix -> DOT .Identifier
superSuffix -> DOT .Identifier arguments 
transitions ->  {"Identifier":357}

item set 283 
explicitGenericInvocationSuffix -> Identifier arguments . 
transitions ->  {}

item set 284 
parExpression -> LPAREN expression RPAREN .
parExpression -> LPAREN expression RPAREN . 
transitions ->  {}

item set 285 
parExpression -> LPAREN primitiveType RPAREN . 
transitions ->  {}

item set 286 
parExpression -> LPAREN primitiveType arrayDimensionBrackl .RPAREN
expression -> primitiveType arrayDimensionBrackl .DOT CLASS
arrayDimensionBrackl -> arrayDimensionBrackl .arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"RPAREN":358,"DOT":276,"arrayDimensionBrack":272,"LBRACK":204}

item set 287 
parExpression -> LPAREN qualifiedName arrayDimensionBrackl .RPAREN
expression -> qualifiedName arrayDimensionBrackl .DOT CLASS
arrayDimensionBrackl -> arrayDimensionBrackl .arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"RPAREN":359,"DOT":271,"arrayDimensionBrack":272,"LBRACK":204}

item set 288 
parExpression -> LPAREN qualifiedName typeParameters .arrayDimensionBrackl RPAREN
parExpression -> LPAREN qualifiedName typeParameters .RPAREN
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"arrayDimensionBrackl":360,"RPAREN":361,"arrayDimensionBrack":201,"LBRACK":204}

item set 289 
creator -> nonWildcardTypeArguments createdName .classCreatorRest
classCreatorRest -> .arguments
classCreatorRest -> .LPAREN RPAREN
classCreatorRest -> .LPAREN RPAREN classBody
classCreatorRest -> .arguments classBody
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN 
transitions ->  {"classCreatorRest":362,"arguments":295,"LPAREN":296}

item set 290 
creator -> createdName arrayOrClassCreator . 
transitions ->  {}

item set 291 
arrayOrClassCreator -> arrayCreatorRest . 
transitions ->  {}

item set 292 
arrayOrClassCreator -> classCreatorRest . 
transitions ->  {}

item set 293 
arrayCreatorRest -> LBRACK .RBRACK arrayDimensionBracks arrayInitializer
bracketedExpressions -> LBRACK .expression RBRACK
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"RBRACK":363,"expression":364,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 294 
arrayCreatorRest -> bracketedExpressions .arrayDimensionBracks
bracketedExpressions -> bracketedExpressions .LBRACK expression RBRACK
arrayDimensionBracks -> .
arrayDimensionBracks -> .arrayDimensionBrackl
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"arrayDimensionBracks":365,"LBRACK":366,"arrayDimensionBrackl":227,"arrayDimensionBrack":201}

item set 295 
classCreatorRest -> arguments .
classCreatorRest -> arguments .classBody
classBody -> .LBRACE RBRACE
classBody -> .LBRACE classBodyDeclarationl RBRACE 
transitions ->  {"classBody":367,"LBRACE":317}

item set 296 
classCreatorRest -> LPAREN .RPAREN
classCreatorRest -> LPAREN .RPAREN classBody
arguments -> LPAREN .RPAREN
arguments -> LPAREN .expressionList RPAREN
expressionList -> .expression
expressionList -> .expressionList COMMA expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"RPAREN":368,"expressionList":247,"expression":248,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 297 
createdName -> qualifiedName optionalTypeArgumentsOrDiamonds . 
transitions ->  {}

item set 298 
optionalTypeArgumentsOrDiamonds -> typeArgumentsOrDiamondList .
typeArgumentsOrDiamondList -> typeArgumentsOrDiamondList .DOT Identifier typeArgumentsOrDiamond 
transitions ->  {"DOT":369}

item set 299 
typeArgumentsOrDiamondList -> typeArgumentsOrDiamond . 
transitions ->  {}

item set 300 
typeArgumentsOrDiamond -> LT .GT 
transitions ->  {"GT":370}

item set 301 
typeArgumentsOrDiamond -> typeParameters . 
transitions ->  {}

item set 302 
annotationTypeBody -> LBRACE RBRACE . 
transitions ->  {}

item set 303 
annotationTypeBody -> LBRACE annotationTypeElementDeclarations .RBRACE
annotationTypeElementDeclarations -> annotationTypeElementDeclarations .annotationTypeElementDeclaration
annotationTypeElementDeclaration -> .modifierL annotationTypeElementRest
annotationTypeElementDeclaration -> .annotationl annotationTypeElementRest
annotationTypeElementDeclaration -> .annotationl modifierL annotationTypeElementRest
annotationTypeElementDeclaration -> .modifierL annotationl annotationTypeElementRest
annotationTypeElementDeclaration -> .annotationTypeElementRest
annotationTypeElementDeclaration -> .SEMI
modifierL -> .modifier
modifierL -> .modifierL modifier
annotationl -> .annotation
annotationl -> .annotationl annotation
annotationTypeElementRest -> .type annotationConstantRest commentReturn SEMI
annotationTypeElementRest -> .typeParameters type annotationMethodRest commentReturn SEMI
annotationTypeElementRest -> .type annotationMethodRest commentReturn SEMI
annotationTypeElementRest -> .classDeclaration
annotationTypeElementRest -> .interfaceDeclaration
annotationTypeElementRest -> .enumDeclaration
annotationTypeElementRest -> .annotationTypeDeclaration
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
typeParameters -> .TEMPLATE
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"RBRACE":371,"annotationTypeElementDeclaration":372,"modifierL":305,"annotationl":306,"annotationTypeElementRest":307,"SEMI":308,"modifier":15,"annotation":10,"type":309,"typeParameters":310,"classDeclaration":311,"interfaceDeclaration":312,"enumDeclaration":313,"annotationTypeDeclaration":314,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"AT":14,"qualifiedName":137,"primitiveType":138,"TEMPLATE":71,"CLASS":31,"INTERFACE":32,"ENUM":33,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 304 
annotationTypeElementDeclarations -> annotationTypeElementDeclaration . 
transitions ->  {}

item set 305 
annotationTypeElementDeclaration -> modifierL .annotationTypeElementRest
annotationTypeElementDeclaration -> modifierL .annotationl annotationTypeElementRest
modifierL -> modifierL .modifier
annotationTypeElementRest -> .type annotationConstantRest commentReturn SEMI
annotationTypeElementRest -> .typeParameters type annotationMethodRest commentReturn SEMI
annotationTypeElementRest -> .type annotationMethodRest commentReturn SEMI
annotationTypeElementRest -> .classDeclaration
annotationTypeElementRest -> .interfaceDeclaration
annotationTypeElementRest -> .enumDeclaration
annotationTypeElementRest -> .annotationTypeDeclaration
annotationl -> .annotation
annotationl -> .annotationl annotation
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
typeParameters -> .TEMPLATE
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"annotationTypeElementRest":373,"annotationl":374,"modifier":54,"type":309,"typeParameters":310,"classDeclaration":311,"interfaceDeclaration":312,"enumDeclaration":313,"annotationTypeDeclaration":314,"annotation":10,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"qualifiedName":137,"primitiveType":138,"TEMPLATE":71,"CLASS":31,"INTERFACE":32,"ENUM":33,"AT":14,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 306 
annotationTypeElementDeclaration -> annotationl .annotationTypeElementRest
annotationTypeElementDeclaration -> annotationl .modifierL annotationTypeElementRest
annotationl -> annotationl .annotation
annotationTypeElementRest -> .type annotationConstantRest commentReturn SEMI
annotationTypeElementRest -> .typeParameters type annotationMethodRest commentReturn SEMI
annotationTypeElementRest -> .type annotationMethodRest commentReturn SEMI
annotationTypeElementRest -> .classDeclaration
annotationTypeElementRest -> .interfaceDeclaration
annotationTypeElementRest -> .enumDeclaration
annotationTypeElementRest -> .annotationTypeDeclaration
modifierL -> .modifier
modifierL -> .modifierL modifier
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
typeParameters -> .TEMPLATE
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"annotationTypeElementRest":375,"modifierL":376,"annotation":63,"type":309,"typeParameters":310,"classDeclaration":311,"interfaceDeclaration":312,"enumDeclaration":313,"annotationTypeDeclaration":314,"modifier":15,"AT":14,"qualifiedName":137,"primitiveType":138,"TEMPLATE":71,"CLASS":31,"INTERFACE":32,"ENUM":33,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 307 
annotationTypeElementDeclaration -> annotationTypeElementRest . 
transitions ->  {}

item set 308 
annotationTypeElementDeclaration -> SEMI . 
transitions ->  {}

item set 309 
annotationTypeElementRest -> type .annotationConstantRest commentReturn SEMI
annotationTypeElementRest -> type .annotationMethodRest commentReturn SEMI
annotationConstantRest -> .variableDeclarators
annotationMethodRest -> .Identifier LPAREN RPAREN defaultValue
annotationMethodRest -> .Identifier LPAREN RPAREN
variableDeclarators -> .variableDeclarator
variableDeclarators -> .variableDeclarators COMMA variableDeclarator
variableDeclarator -> .variableDeclaratorId
variableDeclarator -> .variableDeclaratorId ASSIGN variableInitializer
variableDeclaratorId -> .Identifier arrayDimensionBracks 
transitions ->  {"annotationConstantRest":377,"annotationMethodRest":378,"variableDeclarators":379,"Identifier":380,"variableDeclarator":381,"variableDeclaratorId":382}

item set 310 
annotationTypeElementRest -> typeParameters .type annotationMethodRest commentReturn SEMI
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"type":383,"qualifiedName":137,"primitiveType":138,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 311 
annotationTypeElementRest -> classDeclaration . 
transitions ->  {}

item set 312 
annotationTypeElementRest -> interfaceDeclaration . 
transitions ->  {}

item set 313 
annotationTypeElementRest -> enumDeclaration . 
transitions ->  {}

item set 314 
annotationTypeElementRest -> annotationTypeDeclaration . 
transitions ->  {}

item set 315 
annotationTypeDeclaration -> AT INTERFACE Identifier EXTENDS typeList commentReturn .annotationTypeBody
annotationTypeBody -> .LBRACE RBRACE
annotationTypeBody -> .LBRACE annotationTypeElementDeclarations RBRACE 
transitions ->  {"annotationTypeBody":384,"LBRACE":222}

item set 316 
classDeclaration -> CLASS Identifier classInheritance interfaceImplentation commentReturn classBody . 
transitions ->  {}

item set 317 
classBody -> LBRACE .RBRACE
classBody -> LBRACE .classBodyDeclarationl RBRACE
classBodyDeclarationl -> .classBodyDeclaration
classBodyDeclarationl -> .classBodyDeclarationl classBodyDeclaration
classBodyDeclaration -> .SEMI
classBodyDeclaration -> .annotationl modifierL classMemberDeclaration
classBodyDeclaration -> .modifierL annotationl classMemberDeclaration
classBodyDeclaration -> .modifierL classMemberDeclaration
classBodyDeclaration -> .annotationl classMemberDeclaration
classBodyDeclaration -> .classMemberDeclaration
classBodyDeclaration -> .classStaticBlock
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> .VOID Identifier formalParameters commentReturn block
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> .type Identifier formalParameters commentReturn block
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> .VOID Identifier formalParameters commentReturn SEMI
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> .type Identifier formalParameters commentReturn SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters commentReturn block
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> .typeParameters type Identifier formalParameters commentReturn block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters commentReturn SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters commentReturn SEMI
classMemberDeclaration -> .type variableDeclarators commentReturn SEMI
classMemberDeclaration -> .Identifier formalParameters throwsList commentReturn block
classMemberDeclaration -> .typeParameters Identifier formalParameters throwsList commentReturn block
classMemberDeclaration -> .classDeclaration
classMemberDeclaration -> .interfaceDeclaration
classMemberDeclaration -> .enumDeclaration
classMemberDeclaration -> .annotationTypeDeclaration
classStaticBlock -> .STATIC block
classStaticBlock -> .block
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
typeParameters -> .TEMPLATE
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"RBRACE":385,"classBodyDeclarationl":386,"classBodyDeclaration":387,"SEMI":388,"annotationl":389,"modifierL":390,"classMemberDeclaration":391,"classStaticBlock":392,"annotation":10,"modifier":15,"VOID":393,"type":394,"typeParameters":395,"Identifier":396,"classDeclaration":397,"interfaceDeclaration":398,"enumDeclaration":399,"annotationTypeDeclaration":400,"STATIC":401,"block":402,"AT":14,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"qualifiedName":137,"primitiveType":138,"TEMPLATE":71,"CLASS":31,"INTERFACE":32,"ENUM":33,"LBRACE":403,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 318 
classDeclaration -> CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn .classBody
classBody -> .LBRACE RBRACE
classBody -> .LBRACE classBodyDeclarationl RBRACE 
transitions ->  {"classBody":404,"LBRACE":317}

item set 319 
interfaceBody -> LBRACE RBRACE . 
transitions ->  {}

item set 320 
interfaceBody -> LBRACE interfaceBodyDeclarationl .RBRACE
interfaceBodyDeclarationl -> interfaceBodyDeclarationl .interfaceBodyDeclaration
interfaceBodyDeclaration -> .annotationl modifierL interfaceMemberDeclaration
interfaceBodyDeclaration -> .modifierL annotationl interfaceMemberDeclaration
interfaceBodyDeclaration -> .annotationl interfaceMemberDeclaration
interfaceBodyDeclaration -> .modifierL interfaceMemberDeclaration
interfaceBodyDeclaration -> .interfaceMemberDeclaration
interfaceBodyDeclaration -> .SEMI
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
interfaceMemberDeclaration -> .type constDelarators commentReturn SEMI
interfaceMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
interfaceMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks commentReturn SEMI
interfaceMemberDeclaration -> .VOID Identifier formalParameters commentReturn SEMI
interfaceMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
interfaceMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks commentReturn SEMI
interfaceMemberDeclaration -> .type Identifier formalParameters commentReturn SEMI
interfaceMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
interfaceMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks commentReturn SEMI
interfaceMemberDeclaration -> .typeParameters VOID Identifier formalParameters commentReturn SEMI
interfaceMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
interfaceMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks commentReturn SEMI
interfaceMemberDeclaration -> .typeParameters type Identifier formalParameters commentReturn SEMI
interfaceMemberDeclaration -> .classDeclaration
interfaceMemberDeclaration -> .interfaceDeclaration
interfaceMemberDeclaration -> .enumDeclaration
interfaceMemberDeclaration -> .annotationTypeDeclaration
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
typeParameters -> .TEMPLATE
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"RBRACE":405,"interfaceBodyDeclaration":406,"annotationl":322,"modifierL":323,"interfaceMemberDeclaration":324,"SEMI":325,"annotation":10,"modifier":15,"type":326,"VOID":327,"typeParameters":328,"classDeclaration":329,"interfaceDeclaration":330,"enumDeclaration":331,"annotationTypeDeclaration":332,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"qualifiedName":137,"primitiveType":138,"TEMPLATE":71,"CLASS":31,"INTERFACE":32,"ENUM":33,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 321 
interfaceBodyDeclarationl -> interfaceBodyDeclaration . 
transitions ->  {}

item set 322 
interfaceBodyDeclaration -> annotationl .modifierL interfaceMemberDeclaration
interfaceBodyDeclaration -> annotationl .interfaceMemberDeclaration
annotationl -> annotationl .annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
interfaceMemberDeclaration -> .type constDelarators commentReturn SEMI
interfaceMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
interfaceMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks commentReturn SEMI
interfaceMemberDeclaration -> .VOID Identifier formalParameters commentReturn SEMI
interfaceMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
interfaceMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks commentReturn SEMI
interfaceMemberDeclaration -> .type Identifier formalParameters commentReturn SEMI
interfaceMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
interfaceMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks commentReturn SEMI
interfaceMemberDeclaration -> .typeParameters VOID Identifier formalParameters commentReturn SEMI
interfaceMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
interfaceMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks commentReturn SEMI
interfaceMemberDeclaration -> .typeParameters type Identifier formalParameters commentReturn SEMI
interfaceMemberDeclaration -> .classDeclaration
interfaceMemberDeclaration -> .interfaceDeclaration
interfaceMemberDeclaration -> .enumDeclaration
interfaceMemberDeclaration -> .annotationTypeDeclaration
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
typeParameters -> .TEMPLATE
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"modifierL":407,"interfaceMemberDeclaration":408,"annotation":63,"modifier":15,"type":326,"VOID":327,"typeParameters":328,"classDeclaration":329,"interfaceDeclaration":330,"enumDeclaration":331,"annotationTypeDeclaration":332,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"qualifiedName":137,"primitiveType":138,"TEMPLATE":71,"CLASS":31,"INTERFACE":32,"ENUM":33,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 323 
interfaceBodyDeclaration -> modifierL .annotationl interfaceMemberDeclaration
interfaceBodyDeclaration -> modifierL .interfaceMemberDeclaration
modifierL -> modifierL .modifier
annotationl -> .annotation
annotationl -> .annotationl annotation
interfaceMemberDeclaration -> .type constDelarators commentReturn SEMI
interfaceMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
interfaceMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks commentReturn SEMI
interfaceMemberDeclaration -> .VOID Identifier formalParameters commentReturn SEMI
interfaceMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
interfaceMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks commentReturn SEMI
interfaceMemberDeclaration -> .type Identifier formalParameters commentReturn SEMI
interfaceMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
interfaceMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks commentReturn SEMI
interfaceMemberDeclaration -> .typeParameters VOID Identifier formalParameters commentReturn SEMI
interfaceMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
interfaceMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks commentReturn SEMI
interfaceMemberDeclaration -> .typeParameters type Identifier formalParameters commentReturn SEMI
interfaceMemberDeclaration -> .classDeclaration
interfaceMemberDeclaration -> .interfaceDeclaration
interfaceMemberDeclaration -> .enumDeclaration
interfaceMemberDeclaration -> .annotationTypeDeclaration
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
typeParameters -> .TEMPLATE
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"annotationl":409,"interfaceMemberDeclaration":410,"modifier":54,"annotation":10,"type":326,"VOID":327,"typeParameters":328,"classDeclaration":329,"interfaceDeclaration":330,"enumDeclaration":331,"annotationTypeDeclaration":332,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"AT":14,"qualifiedName":137,"primitiveType":138,"TEMPLATE":71,"CLASS":31,"INTERFACE":32,"ENUM":33,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 324 
interfaceBodyDeclaration -> interfaceMemberDeclaration . 
transitions ->  {}

item set 325 
interfaceBodyDeclaration -> SEMI . 
transitions ->  {}

item set 326 
interfaceMemberDeclaration -> type .constDelarators commentReturn SEMI
interfaceMemberDeclaration -> type .Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
interfaceMemberDeclaration -> type .Identifier formalParameters arrayDimensionBracks commentReturn SEMI
interfaceMemberDeclaration -> type .Identifier formalParameters commentReturn SEMI
constDelarators -> .constantDeclarator
constDelarators -> .constDelarators COMMA constantDeclarator
constantDeclarator -> .Identifier ASSIGN variableInitializer
constantDeclarator -> .Identifier arrayDimensionBrackl ASSIGN variableInitializer 
transitions ->  {"constDelarators":411,"Identifier":412,"constantDeclarator":413}

item set 327 
interfaceMemberDeclaration -> VOID .Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
interfaceMemberDeclaration -> VOID .Identifier formalParameters arrayDimensionBracks commentReturn SEMI
interfaceMemberDeclaration -> VOID .Identifier formalParameters commentReturn SEMI 
transitions ->  {"Identifier":414}

item set 328 
interfaceMemberDeclaration -> typeParameters .VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
interfaceMemberDeclaration -> typeParameters .VOID Identifier formalParameters arrayDimensionBracks commentReturn SEMI
interfaceMemberDeclaration -> typeParameters .VOID Identifier formalParameters commentReturn SEMI
interfaceMemberDeclaration -> typeParameters .type Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
interfaceMemberDeclaration -> typeParameters .type Identifier formalParameters arrayDimensionBracks commentReturn SEMI
interfaceMemberDeclaration -> typeParameters .type Identifier formalParameters commentReturn SEMI
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"VOID":415,"type":416,"qualifiedName":137,"primitiveType":138,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 329 
interfaceMemberDeclaration -> classDeclaration . 
transitions ->  {}

item set 330 
interfaceMemberDeclaration -> interfaceDeclaration . 
transitions ->  {}

item set 331 
interfaceMemberDeclaration -> enumDeclaration . 
transitions ->  {}

item set 332 
interfaceMemberDeclaration -> annotationTypeDeclaration . 
transitions ->  {}

item set 333 
interfaceDeclaration -> INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn .interfaceBody
interfaceBody -> .LBRACE RBRACE
interfaceBody -> .LBRACE interfaceBodyDeclarationl RBRACE 
transitions ->  {"interfaceBody":417,"LBRACE":230}

item set 334 
enumBody -> LBRACE RBRACE . 
transitions ->  {}

item set 335 
enumBody -> LBRACE enumBodyDeclaration .RBRACE 
transitions ->  {"RBRACE":418}

item set 336 
enumBodyDeclaration -> enumConstants .
enumBodyDeclaration -> enumConstants .COMMA
enumBodyDeclaration -> enumConstants .SEMI
enumBodyDeclaration -> enumConstants .COMMA SEMI
enumBodyDeclaration -> enumConstants .SEMI classBodyDeclarationl
enumBodyDeclaration -> enumConstants .COMMA SEMI classBodyDeclarationl
enumConstants -> enumConstants .COMMA annotations Identifier enumConstantArguments commentReturn enumConstantClassBody 
transitions ->  {"COMMA":419,"SEMI":420}

item set 337 
enumConstants -> annotations .Identifier enumConstantArguments commentReturn enumConstantClassBody 
transitions ->  {"Identifier":421}

item set 338 
typeList -> typeList COMMA type . 
transitions ->  {}

item set 339 
expression -> expression DOT SUPER DOT .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":422,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 340 
expression -> expression DOT SUPER arguments . 
transitions ->  {}

item set 341 
expression -> expression DOT SUPER LPAREN .RPAREN
arguments -> LPAREN .RPAREN
arguments -> LPAREN .expressionList RPAREN
expressionList -> .expression
expressionList -> .expressionList COMMA expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"RPAREN":423,"expressionList":247,"expression":248,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 342 
expression -> expression DOT NEW optionalNonWildcardTypeArguments .innerCreator
innerCreator -> .Identifier optionalNonWildcardTypeArgumentsOrDiamond classCreatorRest 
transitions ->  {"innerCreator":424,"Identifier":425}

item set 343 
optionalNonWildcardTypeArguments -> nonWildcardTypeArguments .
creator -> nonWildcardTypeArguments .createdName classCreatorRest
createdName -> .qualifiedName optionalTypeArgumentsOrDiamonds
createdName -> .primitiveType
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"createdName":289,"qualifiedName":219,"primitiveType":220,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 344 
expression -> expression DOT typeParameters Identifier .arguments
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN 
transitions ->  {"arguments":426,"LPAREN":279}

item set 345 
expression -> expression LBRACK expression RBRACK . 
transitions ->  {}

item set 346 
arguments -> LPAREN expressionList RPAREN . 
transitions ->  {}

item set 347 
expressionList -> expressionList COMMA .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":427,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 348 
expression -> expression GT GT expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":151,"LBRACK":152,"arguments":153,"LPAREN":154,"incrementOrDecrement":155,"mulDivOrMod":156,"addOrSub":157,"LSHIFT":158,"GT":159,"lE_GE_LT_GT":160,"INSTANCEOF":161,"equals_NotEqual":162,"BITAND":163,"CARET":164,"BITOR":165,"AND":166,"OR":167,"QUESTION":168,"assignmentToken":169,"INC":170,"DEC":171,"MUL":172,"DIV":173,"MOD":174,"ADD":175,"SUB":176,"LE":177,"GE":178,"LT":179,"EQUAL":180,"NOTEQUAL":181,"ASSIGN":182,"ADD_ASSIGN":183,"SUB_ASSIGN":184,"MUL_ASSIGN":185,"DIV_ASSIGN":186,"AND_ASSIGN":187,"OR_ASSIGN":188,"XOR_ASSIGN":189,"RSHIFT_ASSIGN":190,"URSHIFT_ASSIGN":191,"LSHIFT_ASSIGN":192,"MOD_ASSIGN":193}

item set 349 
expression -> expression GT GT GT .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":428,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 350 
expression -> expression QUESTION expression COLON .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":429,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 351 
expression -> qualifiedName DOT SUPER DOT .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":430,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 352 
explicitGenericInvocation -> nonWildcardTypeArguments explicitGenericInvocationSuffix . 
transitions ->  {}

item set 353 
expression -> qualifiedName arrayDimensionBrackl DOT CLASS . 
transitions ->  {}

item set 354 
expression -> qualifiedName LBRACK expression RBRACK . 
transitions ->  {}

item set 355 
expression -> primitiveType arrayDimensionBrackl DOT CLASS . 
transitions ->  {}

item set 356 
arguments -> LPAREN RPAREN . 
transitions ->  {}

item set 357 
superSuffix -> DOT Identifier .
superSuffix -> DOT Identifier .arguments
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN 
transitions ->  {"arguments":431,"LPAREN":279}

item set 358 
parExpression -> LPAREN primitiveType arrayDimensionBrackl RPAREN . 
transitions ->  {}

item set 359 
parExpression -> LPAREN qualifiedName arrayDimensionBrackl RPAREN . 
transitions ->  {}

item set 360 
parExpression -> LPAREN qualifiedName typeParameters arrayDimensionBrackl .RPAREN
arrayDimensionBrackl -> arrayDimensionBrackl .arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"RPAREN":432,"arrayDimensionBrack":272,"LBRACK":204}

item set 361 
parExpression -> LPAREN qualifiedName typeParameters RPAREN . 
transitions ->  {}

item set 362 
creator -> nonWildcardTypeArguments createdName classCreatorRest . 
transitions ->  {}

item set 363 
arrayCreatorRest -> LBRACK RBRACK .arrayDimensionBracks arrayInitializer
arrayDimensionBracks -> .
arrayDimensionBracks -> .arrayDimensionBrackl
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"arrayDimensionBracks":433,"arrayDimensionBrackl":227,"arrayDimensionBrack":201,"LBRACK":204}

item set 364 
bracketedExpressions -> LBRACK expression .RBRACK
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"RBRACK":434,"DOT":151,"LBRACK":152,"arguments":153,"LPAREN":154,"incrementOrDecrement":155,"mulDivOrMod":156,"addOrSub":157,"LSHIFT":158,"GT":159,"lE_GE_LT_GT":160,"INSTANCEOF":161,"equals_NotEqual":162,"BITAND":163,"CARET":164,"BITOR":165,"AND":166,"OR":167,"QUESTION":168,"assignmentToken":169,"INC":170,"DEC":171,"MUL":172,"DIV":173,"MOD":174,"ADD":175,"SUB":176,"LE":177,"GE":178,"LT":179,"EQUAL":180,"NOTEQUAL":181,"ASSIGN":182,"ADD_ASSIGN":183,"SUB_ASSIGN":184,"MUL_ASSIGN":185,"DIV_ASSIGN":186,"AND_ASSIGN":187,"OR_ASSIGN":188,"XOR_ASSIGN":189,"RSHIFT_ASSIGN":190,"URSHIFT_ASSIGN":191,"LSHIFT_ASSIGN":192,"MOD_ASSIGN":193}

item set 365 
arrayCreatorRest -> bracketedExpressions arrayDimensionBracks . 
transitions ->  {}

item set 366 
bracketedExpressions -> bracketedExpressions LBRACK .expression RBRACK
arrayDimensionBrack -> LBRACK .RBRACK
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":435,"RBRACK":274,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 367 
classCreatorRest -> arguments classBody . 
transitions ->  {}

item set 368 
classCreatorRest -> LPAREN RPAREN .
classCreatorRest -> LPAREN RPAREN .classBody
arguments -> LPAREN RPAREN .
classBody -> .LBRACE RBRACE
classBody -> .LBRACE classBodyDeclarationl RBRACE 
transitions ->  {"classBody":436,"LBRACE":317}

item set 369 
typeArgumentsOrDiamondList -> typeArgumentsOrDiamondList DOT .Identifier typeArgumentsOrDiamond 
transitions ->  {"Identifier":437}

item set 370 
typeArgumentsOrDiamond -> LT GT . 
transitions ->  {}

item set 371 
annotationTypeBody -> LBRACE annotationTypeElementDeclarations RBRACE . 
transitions ->  {}

item set 372 
annotationTypeElementDeclarations -> annotationTypeElementDeclarations annotationTypeElementDeclaration . 
transitions ->  {}

item set 373 
annotationTypeElementDeclaration -> modifierL annotationTypeElementRest . 
transitions ->  {}

item set 374 
annotationTypeElementDeclaration -> modifierL annotationl .annotationTypeElementRest
annotationl -> annotationl .annotation
annotationTypeElementRest -> .type annotationConstantRest commentReturn SEMI
annotationTypeElementRest -> .typeParameters type annotationMethodRest commentReturn SEMI
annotationTypeElementRest -> .type annotationMethodRest commentReturn SEMI
annotationTypeElementRest -> .classDeclaration
annotationTypeElementRest -> .interfaceDeclaration
annotationTypeElementRest -> .enumDeclaration
annotationTypeElementRest -> .annotationTypeDeclaration
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
typeParameters -> .TEMPLATE
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"annotationTypeElementRest":438,"annotation":63,"type":309,"typeParameters":310,"classDeclaration":311,"interfaceDeclaration":312,"enumDeclaration":313,"annotationTypeDeclaration":314,"AT":14,"qualifiedName":137,"primitiveType":138,"TEMPLATE":71,"CLASS":31,"INTERFACE":32,"ENUM":33,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 375 
annotationTypeElementDeclaration -> annotationl annotationTypeElementRest . 
transitions ->  {}

item set 376 
annotationTypeElementDeclaration -> annotationl modifierL .annotationTypeElementRest
modifierL -> modifierL .modifier
annotationTypeElementRest -> .type annotationConstantRest commentReturn SEMI
annotationTypeElementRest -> .typeParameters type annotationMethodRest commentReturn SEMI
annotationTypeElementRest -> .type annotationMethodRest commentReturn SEMI
annotationTypeElementRest -> .classDeclaration
annotationTypeElementRest -> .interfaceDeclaration
annotationTypeElementRest -> .enumDeclaration
annotationTypeElementRest -> .annotationTypeDeclaration
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
typeParameters -> .TEMPLATE
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"annotationTypeElementRest":439,"modifier":54,"type":309,"typeParameters":310,"classDeclaration":311,"interfaceDeclaration":312,"enumDeclaration":313,"annotationTypeDeclaration":314,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"qualifiedName":137,"primitiveType":138,"TEMPLATE":71,"CLASS":31,"INTERFACE":32,"ENUM":33,"AT":66,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 377 
annotationTypeElementRest -> type annotationConstantRest .commentReturn SEMI
commentReturn -> . 
transitions ->  {"commentReturn":440}

item set 378 
annotationTypeElementRest -> type annotationMethodRest .commentReturn SEMI
commentReturn -> . 
transitions ->  {"commentReturn":441}

item set 379 
annotationConstantRest -> variableDeclarators .
variableDeclarators -> variableDeclarators .COMMA variableDeclarator 
transitions ->  {"COMMA":442}

item set 380 
annotationMethodRest -> Identifier .LPAREN RPAREN defaultValue
annotationMethodRest -> Identifier .LPAREN RPAREN
variableDeclaratorId -> Identifier .arrayDimensionBracks
arrayDimensionBracks -> .
arrayDimensionBracks -> .arrayDimensionBrackl
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"LPAREN":443,"arrayDimensionBracks":444,"arrayDimensionBrackl":227,"arrayDimensionBrack":201,"LBRACK":204}

item set 381 
variableDeclarators -> variableDeclarator . 
transitions ->  {}

item set 382 
variableDeclarator -> variableDeclaratorId .
variableDeclarator -> variableDeclaratorId .ASSIGN variableInitializer 
transitions ->  {"ASSIGN":445}

item set 383 
annotationTypeElementRest -> typeParameters type .annotationMethodRest commentReturn SEMI
annotationMethodRest -> .Identifier LPAREN RPAREN defaultValue
annotationMethodRest -> .Identifier LPAREN RPAREN 
transitions ->  {"annotationMethodRest":446,"Identifier":447}

item set 384 
annotationTypeDeclaration -> AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody . 
transitions ->  {}

item set 385 
classBody -> LBRACE RBRACE . 
transitions ->  {}

item set 386 
classBody -> LBRACE classBodyDeclarationl .RBRACE
classBodyDeclarationl -> classBodyDeclarationl .classBodyDeclaration
classBodyDeclaration -> .SEMI
classBodyDeclaration -> .annotationl modifierL classMemberDeclaration
classBodyDeclaration -> .modifierL annotationl classMemberDeclaration
classBodyDeclaration -> .modifierL classMemberDeclaration
classBodyDeclaration -> .annotationl classMemberDeclaration
classBodyDeclaration -> .classMemberDeclaration
classBodyDeclaration -> .classStaticBlock
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> .VOID Identifier formalParameters commentReturn block
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> .type Identifier formalParameters commentReturn block
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> .VOID Identifier formalParameters commentReturn SEMI
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> .type Identifier formalParameters commentReturn SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters commentReturn block
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> .typeParameters type Identifier formalParameters commentReturn block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters commentReturn SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters commentReturn SEMI
classMemberDeclaration -> .type variableDeclarators commentReturn SEMI
classMemberDeclaration -> .Identifier formalParameters throwsList commentReturn block
classMemberDeclaration -> .typeParameters Identifier formalParameters throwsList commentReturn block
classMemberDeclaration -> .classDeclaration
classMemberDeclaration -> .interfaceDeclaration
classMemberDeclaration -> .enumDeclaration
classMemberDeclaration -> .annotationTypeDeclaration
classStaticBlock -> .STATIC block
classStaticBlock -> .block
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
typeParameters -> .TEMPLATE
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"RBRACE":448,"classBodyDeclaration":449,"SEMI":388,"annotationl":389,"modifierL":390,"classMemberDeclaration":391,"classStaticBlock":392,"annotation":10,"modifier":15,"VOID":393,"type":394,"typeParameters":395,"Identifier":396,"classDeclaration":397,"interfaceDeclaration":398,"enumDeclaration":399,"annotationTypeDeclaration":400,"STATIC":401,"block":402,"AT":14,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"qualifiedName":137,"primitiveType":138,"TEMPLATE":71,"CLASS":31,"INTERFACE":32,"ENUM":33,"LBRACE":403,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 387 
classBodyDeclarationl -> classBodyDeclaration . 
transitions ->  {}

item set 388 
classBodyDeclaration -> SEMI . 
transitions ->  {}

item set 389 
classBodyDeclaration -> annotationl .modifierL classMemberDeclaration
classBodyDeclaration -> annotationl .classMemberDeclaration
annotationl -> annotationl .annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> .VOID Identifier formalParameters commentReturn block
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> .type Identifier formalParameters commentReturn block
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> .VOID Identifier formalParameters commentReturn SEMI
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> .type Identifier formalParameters commentReturn SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters commentReturn block
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> .typeParameters type Identifier formalParameters commentReturn block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters commentReturn SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters commentReturn SEMI
classMemberDeclaration -> .type variableDeclarators commentReturn SEMI
classMemberDeclaration -> .Identifier formalParameters throwsList commentReturn block
classMemberDeclaration -> .typeParameters Identifier formalParameters throwsList commentReturn block
classMemberDeclaration -> .classDeclaration
classMemberDeclaration -> .interfaceDeclaration
classMemberDeclaration -> .enumDeclaration
classMemberDeclaration -> .annotationTypeDeclaration
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
typeParameters -> .TEMPLATE
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"modifierL":450,"classMemberDeclaration":451,"annotation":63,"modifier":15,"VOID":393,"type":394,"typeParameters":395,"Identifier":396,"classDeclaration":397,"interfaceDeclaration":398,"enumDeclaration":399,"annotationTypeDeclaration":400,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"qualifiedName":137,"primitiveType":138,"TEMPLATE":71,"CLASS":31,"INTERFACE":32,"ENUM":33,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 390 
classBodyDeclaration -> modifierL .annotationl classMemberDeclaration
classBodyDeclaration -> modifierL .classMemberDeclaration
modifierL -> modifierL .modifier
annotationl -> .annotation
annotationl -> .annotationl annotation
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> .VOID Identifier formalParameters commentReturn block
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> .type Identifier formalParameters commentReturn block
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> .VOID Identifier formalParameters commentReturn SEMI
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> .type Identifier formalParameters commentReturn SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters commentReturn block
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> .typeParameters type Identifier formalParameters commentReturn block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters commentReturn SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters commentReturn SEMI
classMemberDeclaration -> .type variableDeclarators commentReturn SEMI
classMemberDeclaration -> .Identifier formalParameters throwsList commentReturn block
classMemberDeclaration -> .typeParameters Identifier formalParameters throwsList commentReturn block
classMemberDeclaration -> .classDeclaration
classMemberDeclaration -> .interfaceDeclaration
classMemberDeclaration -> .enumDeclaration
classMemberDeclaration -> .annotationTypeDeclaration
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
typeParameters -> .TEMPLATE
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"annotationl":452,"classMemberDeclaration":453,"modifier":54,"annotation":10,"VOID":393,"type":394,"typeParameters":395,"Identifier":396,"classDeclaration":397,"interfaceDeclaration":398,"enumDeclaration":399,"annotationTypeDeclaration":400,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"AT":14,"qualifiedName":137,"primitiveType":138,"TEMPLATE":71,"CLASS":31,"INTERFACE":32,"ENUM":33,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 391 
classBodyDeclaration -> classMemberDeclaration . 
transitions ->  {}

item set 392 
classBodyDeclaration -> classStaticBlock . 
transitions ->  {}

item set 393 
classMemberDeclaration -> VOID .Identifier formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> VOID .Identifier formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> VOID .Identifier formalParameters commentReturn block
classMemberDeclaration -> VOID .Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> VOID .Identifier formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> VOID .Identifier formalParameters commentReturn SEMI 
transitions ->  {"Identifier":454}

item set 394 
classMemberDeclaration -> type .Identifier formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> type .Identifier formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> type .Identifier formalParameters commentReturn block
classMemberDeclaration -> type .Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> type .Identifier formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> type .Identifier formalParameters commentReturn SEMI
classMemberDeclaration -> type .variableDeclarators commentReturn SEMI
variableDeclarators -> .variableDeclarator
variableDeclarators -> .variableDeclarators COMMA variableDeclarator
variableDeclarator -> .variableDeclaratorId
variableDeclarator -> .variableDeclaratorId ASSIGN variableInitializer
variableDeclaratorId -> .Identifier arrayDimensionBracks 
transitions ->  {"Identifier":455,"variableDeclarators":456,"variableDeclarator":381,"variableDeclaratorId":382}

item set 395 
classMemberDeclaration -> typeParameters .VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> typeParameters .VOID Identifier formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> typeParameters .VOID Identifier formalParameters commentReturn block
classMemberDeclaration -> typeParameters .type Identifier formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> typeParameters .type Identifier formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> typeParameters .type Identifier formalParameters commentReturn block
classMemberDeclaration -> typeParameters .VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> typeParameters .VOID Identifier formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> typeParameters .VOID Identifier formalParameters commentReturn SEMI
classMemberDeclaration -> typeParameters .type Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> typeParameters .type Identifier formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> typeParameters .type Identifier formalParameters commentReturn SEMI
classMemberDeclaration -> typeParameters .Identifier formalParameters throwsList commentReturn block
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"VOID":457,"type":458,"Identifier":459,"qualifiedName":137,"primitiveType":138,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 396 
classMemberDeclaration -> Identifier .formalParameters throwsList commentReturn block
qualifiedName -> Identifier .
qualifiedName -> Identifier .typeParameters
formalParameters -> .LPAREN RPAREN
formalParameters -> .LPAREN formalParameterList RPAREN
typeParameters -> .TEMPLATE 
transitions ->  {"formalParameters":460,"typeParameters":70,"LPAREN":461,"TEMPLATE":71}

item set 397 
classMemberDeclaration -> classDeclaration . 
transitions ->  {}

item set 398 
classMemberDeclaration -> interfaceDeclaration . 
transitions ->  {}

item set 399 
classMemberDeclaration -> enumDeclaration . 
transitions ->  {}

item set 400 
classMemberDeclaration -> annotationTypeDeclaration . 
transitions ->  {}

item set 401 
classStaticBlock -> STATIC .block
modifier -> STATIC .
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE 
transitions ->  {"block":462,"LBRACE":403}

item set 402 
classStaticBlock -> block . 
transitions ->  {}

item set 403 
block -> LBRACE .RBRACE
block -> LBRACE .blockStatementList RBRACE
blockStatementList -> .blockStatement
blockStatementList -> .blockStatementList blockStatement
blockStatement -> .statement
blockStatement -> .LBRACE RBRACE
blockStatement -> .LBRACE blockStatementList RBRACE
statement -> .ASSERT assertExpression SEMI
statement -> .IF LPAREN expression RPAREN blockStatement optionalElseStatement
statement -> .FOR LPAREN forControl RPAREN blockStatement
statement -> .WHILE LPAREN expression RPAREN blockStatement
statement -> .DO blockStatement WHILE LPAREN expression RPAREN SEMI
statement -> .TRY block catchFinallyOrOnlyFinally
statement -> .TRY resourceSpecification block catchClauses
statement -> .TRY resourceSpecification block optionalFinallyBlock
statement -> .TRY resourceSpecification block catchClauses optionalFinallyBlock
statement -> .SWITCH LPAREN expression RPAREN LBRACE switchBlockStatementGroups emptySwitchLabels RBRACE
statement -> .SYNCHRONIZED LPAREN expression RPAREN block
statement -> .RETURN SEMI
statement -> .RETURN expression SEMI
statement -> .THROW expression SEMI
statement -> .BREAK optionalIdentifier SEMI
statement -> .CONTINUE optionalIdentifier SEMI
statement -> .Identifier COLON blockStatement
statement -> .expression SEMI
statement -> .typeDeclarationWithPrefixes
statement -> .variableDeclaratorsWithPrefixes
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
typeDeclarationWithPrefixes -> .annotationl modifierL typeDeclaration
typeDeclarationWithPrefixes -> .modifierL annotationl typeDeclaration
typeDeclarationWithPrefixes -> .modifierL typeDeclaration
typeDeclarationWithPrefixes -> .annotationl typeDeclaration
typeDeclarationWithPrefixes -> .typeDeclaration
variableDeclaratorsWithPrefixes -> .annotationl modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .localVariableDeclaration
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
localVariableDeclaration -> .type variableDeclarators
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks 
transitions ->  {"RBRACE":463,"blockStatementList":464,"blockStatement":465,"statement":466,"LBRACE":467,"ASSERT":468,"IF":469,"FOR":470,"WHILE":471,"DO":472,"TRY":473,"SWITCH":474,"SYNCHRONIZED":475,"RETURN":476,"THROW":477,"BREAK":478,"CONTINUE":479,"Identifier":480,"expression":481,"typeDeclarationWithPrefixes":482,"variableDeclaratorsWithPrefixes":483,"parExpression":98,"qualifiedName":484,"primitiveType":485,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"annotationl":486,"modifierL":487,"typeDeclaration":13,"localVariableDeclaration":488,"LPAREN":115,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131,"annotation":10,"modifier":15,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"type":489,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 404 
classDeclaration -> CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody . 
transitions ->  {}

item set 405 
interfaceBody -> LBRACE interfaceBodyDeclarationl RBRACE . 
transitions ->  {}

item set 406 
interfaceBodyDeclarationl -> interfaceBodyDeclarationl interfaceBodyDeclaration . 
transitions ->  {}

item set 407 
interfaceBodyDeclaration -> annotationl modifierL .interfaceMemberDeclaration
modifierL -> modifierL .modifier
interfaceMemberDeclaration -> .type constDelarators commentReturn SEMI
interfaceMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
interfaceMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks commentReturn SEMI
interfaceMemberDeclaration -> .VOID Identifier formalParameters commentReturn SEMI
interfaceMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
interfaceMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks commentReturn SEMI
interfaceMemberDeclaration -> .type Identifier formalParameters commentReturn SEMI
interfaceMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
interfaceMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks commentReturn SEMI
interfaceMemberDeclaration -> .typeParameters VOID Identifier formalParameters commentReturn SEMI
interfaceMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
interfaceMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks commentReturn SEMI
interfaceMemberDeclaration -> .typeParameters type Identifier formalParameters commentReturn SEMI
interfaceMemberDeclaration -> .classDeclaration
interfaceMemberDeclaration -> .interfaceDeclaration
interfaceMemberDeclaration -> .enumDeclaration
interfaceMemberDeclaration -> .annotationTypeDeclaration
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
typeParameters -> .TEMPLATE
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"interfaceMemberDeclaration":490,"modifier":54,"type":326,"VOID":327,"typeParameters":328,"classDeclaration":329,"interfaceDeclaration":330,"enumDeclaration":331,"annotationTypeDeclaration":332,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"qualifiedName":137,"primitiveType":138,"TEMPLATE":71,"CLASS":31,"INTERFACE":32,"ENUM":33,"AT":66,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 408 
interfaceBodyDeclaration -> annotationl interfaceMemberDeclaration . 
transitions ->  {}

item set 409 
interfaceBodyDeclaration -> modifierL annotationl .interfaceMemberDeclaration
annotationl -> annotationl .annotation
interfaceMemberDeclaration -> .type constDelarators commentReturn SEMI
interfaceMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
interfaceMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks commentReturn SEMI
interfaceMemberDeclaration -> .VOID Identifier formalParameters commentReturn SEMI
interfaceMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
interfaceMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks commentReturn SEMI
interfaceMemberDeclaration -> .type Identifier formalParameters commentReturn SEMI
interfaceMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
interfaceMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks commentReturn SEMI
interfaceMemberDeclaration -> .typeParameters VOID Identifier formalParameters commentReturn SEMI
interfaceMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
interfaceMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks commentReturn SEMI
interfaceMemberDeclaration -> .typeParameters type Identifier formalParameters commentReturn SEMI
interfaceMemberDeclaration -> .classDeclaration
interfaceMemberDeclaration -> .interfaceDeclaration
interfaceMemberDeclaration -> .enumDeclaration
interfaceMemberDeclaration -> .annotationTypeDeclaration
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
typeParameters -> .TEMPLATE
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"interfaceMemberDeclaration":491,"annotation":63,"type":326,"VOID":327,"typeParameters":328,"classDeclaration":329,"interfaceDeclaration":330,"enumDeclaration":331,"annotationTypeDeclaration":332,"AT":14,"qualifiedName":137,"primitiveType":138,"TEMPLATE":71,"CLASS":31,"INTERFACE":32,"ENUM":33,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 410 
interfaceBodyDeclaration -> modifierL interfaceMemberDeclaration . 
transitions ->  {}

item set 411 
interfaceMemberDeclaration -> type constDelarators .commentReturn SEMI
constDelarators -> constDelarators .COMMA constantDeclarator
commentReturn -> . 
transitions ->  {"commentReturn":492,"COMMA":493}

item set 412 
interfaceMemberDeclaration -> type Identifier .formalParameters arrayDimensionBracks throwsList commentReturn SEMI
interfaceMemberDeclaration -> type Identifier .formalParameters arrayDimensionBracks commentReturn SEMI
interfaceMemberDeclaration -> type Identifier .formalParameters commentReturn SEMI
constantDeclarator -> Identifier .ASSIGN variableInitializer
constantDeclarator -> Identifier .arrayDimensionBrackl ASSIGN variableInitializer
formalParameters -> .LPAREN RPAREN
formalParameters -> .LPAREN formalParameterList RPAREN
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"formalParameters":494,"ASSIGN":495,"arrayDimensionBrackl":496,"LPAREN":461,"arrayDimensionBrack":201,"LBRACK":204}

item set 413 
constDelarators -> constantDeclarator . 
transitions ->  {}

item set 414 
interfaceMemberDeclaration -> VOID Identifier .formalParameters arrayDimensionBracks throwsList commentReturn SEMI
interfaceMemberDeclaration -> VOID Identifier .formalParameters arrayDimensionBracks commentReturn SEMI
interfaceMemberDeclaration -> VOID Identifier .formalParameters commentReturn SEMI
formalParameters -> .LPAREN RPAREN
formalParameters -> .LPAREN formalParameterList RPAREN 
transitions ->  {"formalParameters":497,"LPAREN":461}

item set 415 
interfaceMemberDeclaration -> typeParameters VOID .Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
interfaceMemberDeclaration -> typeParameters VOID .Identifier formalParameters arrayDimensionBracks commentReturn SEMI
interfaceMemberDeclaration -> typeParameters VOID .Identifier formalParameters commentReturn SEMI 
transitions ->  {"Identifier":498}

item set 416 
interfaceMemberDeclaration -> typeParameters type .Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
interfaceMemberDeclaration -> typeParameters type .Identifier formalParameters arrayDimensionBracks commentReturn SEMI
interfaceMemberDeclaration -> typeParameters type .Identifier formalParameters commentReturn SEMI 
transitions ->  {"Identifier":499}

item set 417 
interfaceDeclaration -> INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody . 
transitions ->  {}

item set 418 
enumBody -> LBRACE enumBodyDeclaration RBRACE . 
transitions ->  {}

item set 419 
enumBodyDeclaration -> enumConstants COMMA .
enumBodyDeclaration -> enumConstants COMMA .SEMI
enumBodyDeclaration -> enumConstants COMMA .SEMI classBodyDeclarationl
enumConstants -> enumConstants COMMA .annotations Identifier enumConstantArguments commentReturn enumConstantClassBody
annotations -> .
annotations -> .annotationl
annotationl -> .annotation
annotationl -> .annotationl annotation
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN 
transitions ->  {"SEMI":500,"annotations":501,"annotationl":114,"annotation":10,"AT":67}

item set 420 
enumBodyDeclaration -> enumConstants SEMI .
enumBodyDeclaration -> enumConstants SEMI .classBodyDeclarationl
classBodyDeclarationl -> .classBodyDeclaration
classBodyDeclarationl -> .classBodyDeclarationl classBodyDeclaration
classBodyDeclaration -> .SEMI
classBodyDeclaration -> .annotationl modifierL classMemberDeclaration
classBodyDeclaration -> .modifierL annotationl classMemberDeclaration
classBodyDeclaration -> .modifierL classMemberDeclaration
classBodyDeclaration -> .annotationl classMemberDeclaration
classBodyDeclaration -> .classMemberDeclaration
classBodyDeclaration -> .classStaticBlock
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> .VOID Identifier formalParameters commentReturn block
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> .type Identifier formalParameters commentReturn block
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> .VOID Identifier formalParameters commentReturn SEMI
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> .type Identifier formalParameters commentReturn SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters commentReturn block
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> .typeParameters type Identifier formalParameters commentReturn block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters commentReturn SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters commentReturn SEMI
classMemberDeclaration -> .type variableDeclarators commentReturn SEMI
classMemberDeclaration -> .Identifier formalParameters throwsList commentReturn block
classMemberDeclaration -> .typeParameters Identifier formalParameters throwsList commentReturn block
classMemberDeclaration -> .classDeclaration
classMemberDeclaration -> .interfaceDeclaration
classMemberDeclaration -> .enumDeclaration
classMemberDeclaration -> .annotationTypeDeclaration
classStaticBlock -> .STATIC block
classStaticBlock -> .block
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
typeParameters -> .TEMPLATE
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"classBodyDeclarationl":502,"classBodyDeclaration":387,"SEMI":388,"annotationl":389,"modifierL":390,"classMemberDeclaration":391,"classStaticBlock":392,"annotation":10,"modifier":15,"VOID":393,"type":394,"typeParameters":395,"Identifier":396,"classDeclaration":397,"interfaceDeclaration":398,"enumDeclaration":399,"annotationTypeDeclaration":400,"STATIC":401,"block":402,"AT":14,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"qualifiedName":137,"primitiveType":138,"TEMPLATE":71,"CLASS":31,"INTERFACE":32,"ENUM":33,"LBRACE":403,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 421 
enumConstants -> annotations Identifier .enumConstantArguments commentReturn enumConstantClassBody
enumConstantArguments -> .
enumConstantArguments -> .arguments
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN 
transitions ->  {"enumConstantArguments":503,"arguments":504,"LPAREN":279}

item set 422 
expression -> expression DOT SUPER DOT expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":151,"LBRACK":152,"arguments":153,"LPAREN":154,"incrementOrDecrement":155,"mulDivOrMod":156,"addOrSub":157,"LSHIFT":158,"GT":159,"lE_GE_LT_GT":160,"INSTANCEOF":161,"equals_NotEqual":162,"BITAND":163,"CARET":164,"BITOR":165,"AND":166,"OR":167,"QUESTION":168,"assignmentToken":169,"INC":170,"DEC":171,"MUL":172,"DIV":173,"MOD":174,"ADD":175,"SUB":176,"LE":177,"GE":178,"LT":179,"EQUAL":180,"NOTEQUAL":181,"ASSIGN":182,"ADD_ASSIGN":183,"SUB_ASSIGN":184,"MUL_ASSIGN":185,"DIV_ASSIGN":186,"AND_ASSIGN":187,"OR_ASSIGN":188,"XOR_ASSIGN":189,"RSHIFT_ASSIGN":190,"URSHIFT_ASSIGN":191,"LSHIFT_ASSIGN":192,"MOD_ASSIGN":193}

item set 423 
expression -> expression DOT SUPER LPAREN RPAREN .
arguments -> LPAREN RPAREN . 
transitions ->  {}

item set 424 
expression -> expression DOT NEW optionalNonWildcardTypeArguments innerCreator . 
transitions ->  {}

item set 425 
innerCreator -> Identifier .optionalNonWildcardTypeArgumentsOrDiamond classCreatorRest
optionalNonWildcardTypeArgumentsOrDiamond -> .
optionalNonWildcardTypeArgumentsOrDiamond -> .nonWildcardTypeArgumentsOrDiamond
nonWildcardTypeArgumentsOrDiamond -> .LT GT
nonWildcardTypeArgumentsOrDiamond -> .nonWildcardTypeArguments
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"optionalNonWildcardTypeArgumentsOrDiamond":505,"nonWildcardTypeArgumentsOrDiamond":506,"LT":507,"nonWildcardTypeArguments":508,"TEMPLATE":131}

item set 426 
expression -> expression DOT typeParameters Identifier arguments . 
transitions ->  {}

item set 427 
expressionList -> expressionList COMMA expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":151,"LBRACK":152,"arguments":153,"LPAREN":154,"incrementOrDecrement":155,"mulDivOrMod":156,"addOrSub":157,"LSHIFT":158,"GT":159,"lE_GE_LT_GT":160,"INSTANCEOF":161,"equals_NotEqual":162,"BITAND":163,"CARET":164,"BITOR":165,"AND":166,"OR":167,"QUESTION":168,"assignmentToken":169,"INC":170,"DEC":171,"MUL":172,"DIV":173,"MOD":174,"ADD":175,"SUB":176,"LE":177,"GE":178,"LT":179,"EQUAL":180,"NOTEQUAL":181,"ASSIGN":182,"ADD_ASSIGN":183,"SUB_ASSIGN":184,"MUL_ASSIGN":185,"DIV_ASSIGN":186,"AND_ASSIGN":187,"OR_ASSIGN":188,"XOR_ASSIGN":189,"RSHIFT_ASSIGN":190,"URSHIFT_ASSIGN":191,"LSHIFT_ASSIGN":192,"MOD_ASSIGN":193}

item set 428 
expression -> expression GT GT GT expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":151,"LBRACK":152,"arguments":153,"LPAREN":154,"incrementOrDecrement":155,"mulDivOrMod":156,"addOrSub":157,"LSHIFT":158,"GT":159,"lE_GE_LT_GT":160,"INSTANCEOF":161,"equals_NotEqual":162,"BITAND":163,"CARET":164,"BITOR":165,"AND":166,"OR":167,"QUESTION":168,"assignmentToken":169,"INC":170,"DEC":171,"MUL":172,"DIV":173,"MOD":174,"ADD":175,"SUB":176,"LE":177,"GE":178,"LT":179,"EQUAL":180,"NOTEQUAL":181,"ASSIGN":182,"ADD_ASSIGN":183,"SUB_ASSIGN":184,"MUL_ASSIGN":185,"DIV_ASSIGN":186,"AND_ASSIGN":187,"OR_ASSIGN":188,"XOR_ASSIGN":189,"RSHIFT_ASSIGN":190,"URSHIFT_ASSIGN":191,"LSHIFT_ASSIGN":192,"MOD_ASSIGN":193}

item set 429 
expression -> expression QUESTION expression COLON expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":151,"LBRACK":152,"arguments":153,"LPAREN":154,"incrementOrDecrement":155,"mulDivOrMod":156,"addOrSub":157,"LSHIFT":158,"GT":159,"lE_GE_LT_GT":160,"INSTANCEOF":161,"equals_NotEqual":162,"BITAND":163,"CARET":164,"BITOR":165,"AND":166,"OR":167,"QUESTION":168,"assignmentToken":169,"INC":170,"DEC":171,"MUL":172,"DIV":173,"MOD":174,"ADD":175,"SUB":176,"LE":177,"GE":178,"LT":179,"EQUAL":180,"NOTEQUAL":181,"ASSIGN":182,"ADD_ASSIGN":183,"SUB_ASSIGN":184,"MUL_ASSIGN":185,"DIV_ASSIGN":186,"AND_ASSIGN":187,"OR_ASSIGN":188,"XOR_ASSIGN":189,"RSHIFT_ASSIGN":190,"URSHIFT_ASSIGN":191,"LSHIFT_ASSIGN":192,"MOD_ASSIGN":193}

item set 430 
expression -> qualifiedName DOT SUPER DOT expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":151,"LBRACK":152,"arguments":153,"LPAREN":154,"incrementOrDecrement":155,"mulDivOrMod":156,"addOrSub":157,"LSHIFT":158,"GT":159,"lE_GE_LT_GT":160,"INSTANCEOF":161,"equals_NotEqual":162,"BITAND":163,"CARET":164,"BITOR":165,"AND":166,"OR":167,"QUESTION":168,"assignmentToken":169,"INC":170,"DEC":171,"MUL":172,"DIV":173,"MOD":174,"ADD":175,"SUB":176,"LE":177,"GE":178,"LT":179,"EQUAL":180,"NOTEQUAL":181,"ASSIGN":182,"ADD_ASSIGN":183,"SUB_ASSIGN":184,"MUL_ASSIGN":185,"DIV_ASSIGN":186,"AND_ASSIGN":187,"OR_ASSIGN":188,"XOR_ASSIGN":189,"RSHIFT_ASSIGN":190,"URSHIFT_ASSIGN":191,"LSHIFT_ASSIGN":192,"MOD_ASSIGN":193}

item set 431 
superSuffix -> DOT Identifier arguments . 
transitions ->  {}

item set 432 
parExpression -> LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN . 
transitions ->  {}

item set 433 
arrayCreatorRest -> LBRACK RBRACK arrayDimensionBracks .arrayInitializer
arrayInitializer -> .LBRACE RBRACE
arrayInitializer -> .LBRACE variableInitializerL SEMI RBRACE
arrayInitializer -> .LBRACE variableInitializerL RBRACE
arrayInitializer -> .LBRACE variableInitializerL COMMA RBRACE 
transitions ->  {"arrayInitializer":509,"LBRACE":510}

item set 434 
bracketedExpressions -> LBRACK expression RBRACK . 
transitions ->  {}

item set 435 
bracketedExpressions -> bracketedExpressions LBRACK expression .RBRACK
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"RBRACK":511,"DOT":151,"LBRACK":152,"arguments":153,"LPAREN":154,"incrementOrDecrement":155,"mulDivOrMod":156,"addOrSub":157,"LSHIFT":158,"GT":159,"lE_GE_LT_GT":160,"INSTANCEOF":161,"equals_NotEqual":162,"BITAND":163,"CARET":164,"BITOR":165,"AND":166,"OR":167,"QUESTION":168,"assignmentToken":169,"INC":170,"DEC":171,"MUL":172,"DIV":173,"MOD":174,"ADD":175,"SUB":176,"LE":177,"GE":178,"LT":179,"EQUAL":180,"NOTEQUAL":181,"ASSIGN":182,"ADD_ASSIGN":183,"SUB_ASSIGN":184,"MUL_ASSIGN":185,"DIV_ASSIGN":186,"AND_ASSIGN":187,"OR_ASSIGN":188,"XOR_ASSIGN":189,"RSHIFT_ASSIGN":190,"URSHIFT_ASSIGN":191,"LSHIFT_ASSIGN":192,"MOD_ASSIGN":193}

item set 436 
classCreatorRest -> LPAREN RPAREN classBody . 
transitions ->  {}

item set 437 
typeArgumentsOrDiamondList -> typeArgumentsOrDiamondList DOT Identifier .typeArgumentsOrDiamond
typeArgumentsOrDiamond -> .LT GT
typeArgumentsOrDiamond -> .typeParameters
typeParameters -> .TEMPLATE 
transitions ->  {"typeArgumentsOrDiamond":512,"LT":300,"typeParameters":301,"TEMPLATE":71}

item set 438 
annotationTypeElementDeclaration -> modifierL annotationl annotationTypeElementRest . 
transitions ->  {}

item set 439 
annotationTypeElementDeclaration -> annotationl modifierL annotationTypeElementRest . 
transitions ->  {}

item set 440 
annotationTypeElementRest -> type annotationConstantRest commentReturn .SEMI 
transitions ->  {"SEMI":513}

item set 441 
annotationTypeElementRest -> type annotationMethodRest commentReturn .SEMI 
transitions ->  {"SEMI":514}

item set 442 
variableDeclarators -> variableDeclarators COMMA .variableDeclarator
variableDeclarator -> .variableDeclaratorId
variableDeclarator -> .variableDeclaratorId ASSIGN variableInitializer
variableDeclaratorId -> .Identifier arrayDimensionBracks 
transitions ->  {"variableDeclarator":515,"variableDeclaratorId":382,"Identifier":516}

item set 443 
annotationMethodRest -> Identifier LPAREN .RPAREN defaultValue
annotationMethodRest -> Identifier LPAREN .RPAREN 
transitions ->  {"RPAREN":517}

item set 444 
variableDeclaratorId -> Identifier arrayDimensionBracks . 
transitions ->  {}

item set 445 
variableDeclarator -> variableDeclaratorId ASSIGN .variableInitializer
variableInitializer -> .arrayInitializer
variableInitializer -> .expression
arrayInitializer -> .LBRACE RBRACE
arrayInitializer -> .LBRACE variableInitializerL SEMI RBRACE
arrayInitializer -> .LBRACE variableInitializerL RBRACE
arrayInitializer -> .LBRACE variableInitializerL COMMA RBRACE
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"variableInitializer":518,"arrayInitializer":519,"expression":520,"LBRACE":510,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 446 
annotationTypeElementRest -> typeParameters type annotationMethodRest .commentReturn SEMI
commentReturn -> . 
transitions ->  {"commentReturn":521}

item set 447 
annotationMethodRest -> Identifier .LPAREN RPAREN defaultValue
annotationMethodRest -> Identifier .LPAREN RPAREN 
transitions ->  {"LPAREN":443}

item set 448 
classBody -> LBRACE classBodyDeclarationl RBRACE . 
transitions ->  {}

item set 449 
classBodyDeclarationl -> classBodyDeclarationl classBodyDeclaration . 
transitions ->  {}

item set 450 
classBodyDeclaration -> annotationl modifierL .classMemberDeclaration
modifierL -> modifierL .modifier
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> .VOID Identifier formalParameters commentReturn block
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> .type Identifier formalParameters commentReturn block
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> .VOID Identifier formalParameters commentReturn SEMI
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> .type Identifier formalParameters commentReturn SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters commentReturn block
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> .typeParameters type Identifier formalParameters commentReturn block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters commentReturn SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters commentReturn SEMI
classMemberDeclaration -> .type variableDeclarators commentReturn SEMI
classMemberDeclaration -> .Identifier formalParameters throwsList commentReturn block
classMemberDeclaration -> .typeParameters Identifier formalParameters throwsList commentReturn block
classMemberDeclaration -> .classDeclaration
classMemberDeclaration -> .interfaceDeclaration
classMemberDeclaration -> .enumDeclaration
classMemberDeclaration -> .annotationTypeDeclaration
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
typeParameters -> .TEMPLATE
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"classMemberDeclaration":522,"modifier":54,"VOID":393,"type":394,"typeParameters":395,"Identifier":396,"classDeclaration":397,"interfaceDeclaration":398,"enumDeclaration":399,"annotationTypeDeclaration":400,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"qualifiedName":137,"primitiveType":138,"TEMPLATE":71,"CLASS":31,"INTERFACE":32,"ENUM":33,"AT":66,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 451 
classBodyDeclaration -> annotationl classMemberDeclaration . 
transitions ->  {}

item set 452 
classBodyDeclaration -> modifierL annotationl .classMemberDeclaration
annotationl -> annotationl .annotation
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> .VOID Identifier formalParameters commentReturn block
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> .type Identifier formalParameters commentReturn block
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> .VOID Identifier formalParameters commentReturn SEMI
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> .type Identifier formalParameters commentReturn SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters commentReturn block
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> .typeParameters type Identifier formalParameters commentReturn block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters commentReturn SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters commentReturn SEMI
classMemberDeclaration -> .type variableDeclarators commentReturn SEMI
classMemberDeclaration -> .Identifier formalParameters throwsList commentReturn block
classMemberDeclaration -> .typeParameters Identifier formalParameters throwsList commentReturn block
classMemberDeclaration -> .classDeclaration
classMemberDeclaration -> .interfaceDeclaration
classMemberDeclaration -> .enumDeclaration
classMemberDeclaration -> .annotationTypeDeclaration
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
typeParameters -> .TEMPLATE
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"classMemberDeclaration":523,"annotation":63,"VOID":393,"type":394,"typeParameters":395,"Identifier":396,"classDeclaration":397,"interfaceDeclaration":398,"enumDeclaration":399,"annotationTypeDeclaration":400,"AT":14,"qualifiedName":137,"primitiveType":138,"TEMPLATE":71,"CLASS":31,"INTERFACE":32,"ENUM":33,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 453 
classBodyDeclaration -> modifierL classMemberDeclaration . 
transitions ->  {}

item set 454 
classMemberDeclaration -> VOID Identifier .formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> VOID Identifier .formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> VOID Identifier .formalParameters commentReturn block
classMemberDeclaration -> VOID Identifier .formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> VOID Identifier .formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> VOID Identifier .formalParameters commentReturn SEMI
formalParameters -> .LPAREN RPAREN
formalParameters -> .LPAREN formalParameterList RPAREN 
transitions ->  {"formalParameters":524,"LPAREN":461}

item set 455 
classMemberDeclaration -> type Identifier .formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> type Identifier .formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> type Identifier .formalParameters commentReturn block
classMemberDeclaration -> type Identifier .formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> type Identifier .formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> type Identifier .formalParameters commentReturn SEMI
variableDeclaratorId -> Identifier .arrayDimensionBracks
formalParameters -> .LPAREN RPAREN
formalParameters -> .LPAREN formalParameterList RPAREN
arrayDimensionBracks -> .
arrayDimensionBracks -> .arrayDimensionBrackl
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"formalParameters":525,"arrayDimensionBracks":444,"LPAREN":461,"arrayDimensionBrackl":227,"arrayDimensionBrack":201,"LBRACK":204}

item set 456 
classMemberDeclaration -> type variableDeclarators .commentReturn SEMI
variableDeclarators -> variableDeclarators .COMMA variableDeclarator
commentReturn -> . 
transitions ->  {"commentReturn":526,"COMMA":442}

item set 457 
classMemberDeclaration -> typeParameters VOID .Identifier formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> typeParameters VOID .Identifier formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> typeParameters VOID .Identifier formalParameters commentReturn block
classMemberDeclaration -> typeParameters VOID .Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> typeParameters VOID .Identifier formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> typeParameters VOID .Identifier formalParameters commentReturn SEMI 
transitions ->  {"Identifier":527}

item set 458 
classMemberDeclaration -> typeParameters type .Identifier formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> typeParameters type .Identifier formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> typeParameters type .Identifier formalParameters commentReturn block
classMemberDeclaration -> typeParameters type .Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> typeParameters type .Identifier formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> typeParameters type .Identifier formalParameters commentReturn SEMI 
transitions ->  {"Identifier":528}

item set 459 
classMemberDeclaration -> typeParameters Identifier .formalParameters throwsList commentReturn block
qualifiedName -> Identifier .
qualifiedName -> Identifier .typeParameters
formalParameters -> .LPAREN RPAREN
formalParameters -> .LPAREN formalParameterList RPAREN
typeParameters -> .TEMPLATE 
transitions ->  {"formalParameters":529,"typeParameters":70,"LPAREN":461,"TEMPLATE":71}

item set 460 
classMemberDeclaration -> Identifier formalParameters .throwsList commentReturn block
throwsList -> .
throwsList -> .THROWS qualifiedNameList 
transitions ->  {"throwsList":530,"THROWS":531}

item set 461 
formalParameters -> LPAREN .RPAREN
formalParameters -> LPAREN .formalParameterList RPAREN
formalParameterList -> .usualParameterList
formalParameterList -> .usualParameterList COMMA lastFormalParameter
formalParameterList -> .lastFormalParameter
usualParameterList -> .usualParameter
usualParameterList -> .usualParameterList COMMA usualParameter
lastFormalParameter -> .variableModifiers type ELLIPSIS variableDeclaratorId
lastFormalParameter -> .type ELLIPSIS variableDeclaratorId
usualParameter -> .variableModifiers type variableDeclaratorId
usualParameter -> .type variableDeclaratorId
variableModifiers -> .FINAL annotationl
variableModifiers -> .annotationl
variableModifiers -> .FINAL
variableModifiers -> .annotationl FINAL
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
annotationl -> .annotation
annotationl -> .annotationl annotation
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN 
transitions ->  {"RPAREN":532,"formalParameterList":533,"usualParameterList":534,"lastFormalParameter":535,"usualParameter":536,"variableModifiers":537,"type":538,"FINAL":539,"annotationl":540,"qualifiedName":137,"primitiveType":138,"annotation":10,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"AT":67}

item set 462 
classStaticBlock -> STATIC block . 
transitions ->  {}

item set 463 
block -> LBRACE RBRACE . 
transitions ->  {}

item set 464 
block -> LBRACE blockStatementList .RBRACE
blockStatementList -> blockStatementList .blockStatement
blockStatement -> .statement
blockStatement -> .LBRACE RBRACE
blockStatement -> .LBRACE blockStatementList RBRACE
statement -> .ASSERT assertExpression SEMI
statement -> .IF LPAREN expression RPAREN blockStatement optionalElseStatement
statement -> .FOR LPAREN forControl RPAREN blockStatement
statement -> .WHILE LPAREN expression RPAREN blockStatement
statement -> .DO blockStatement WHILE LPAREN expression RPAREN SEMI
statement -> .TRY block catchFinallyOrOnlyFinally
statement -> .TRY resourceSpecification block catchClauses
statement -> .TRY resourceSpecification block optionalFinallyBlock
statement -> .TRY resourceSpecification block catchClauses optionalFinallyBlock
statement -> .SWITCH LPAREN expression RPAREN LBRACE switchBlockStatementGroups emptySwitchLabels RBRACE
statement -> .SYNCHRONIZED LPAREN expression RPAREN block
statement -> .RETURN SEMI
statement -> .RETURN expression SEMI
statement -> .THROW expression SEMI
statement -> .BREAK optionalIdentifier SEMI
statement -> .CONTINUE optionalIdentifier SEMI
statement -> .Identifier COLON blockStatement
statement -> .expression SEMI
statement -> .typeDeclarationWithPrefixes
statement -> .variableDeclaratorsWithPrefixes
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
typeDeclarationWithPrefixes -> .annotationl modifierL typeDeclaration
typeDeclarationWithPrefixes -> .modifierL annotationl typeDeclaration
typeDeclarationWithPrefixes -> .modifierL typeDeclaration
typeDeclarationWithPrefixes -> .annotationl typeDeclaration
typeDeclarationWithPrefixes -> .typeDeclaration
variableDeclaratorsWithPrefixes -> .annotationl modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .localVariableDeclaration
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
localVariableDeclaration -> .type variableDeclarators
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks 
transitions ->  {"RBRACE":541,"blockStatement":542,"statement":466,"LBRACE":467,"ASSERT":468,"IF":469,"FOR":470,"WHILE":471,"DO":472,"TRY":473,"SWITCH":474,"SYNCHRONIZED":475,"RETURN":476,"THROW":477,"BREAK":478,"CONTINUE":479,"Identifier":480,"expression":481,"typeDeclarationWithPrefixes":482,"variableDeclaratorsWithPrefixes":483,"parExpression":98,"qualifiedName":484,"primitiveType":485,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"annotationl":486,"modifierL":487,"typeDeclaration":13,"localVariableDeclaration":488,"LPAREN":115,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131,"annotation":10,"modifier":15,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"type":489,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 465 
blockStatementList -> blockStatement . 
transitions ->  {}

item set 466 
blockStatement -> statement . 
transitions ->  {}

item set 467 
blockStatement -> LBRACE .RBRACE
blockStatement -> LBRACE .blockStatementList RBRACE
blockStatementList -> .blockStatement
blockStatementList -> .blockStatementList blockStatement
blockStatement -> .statement
blockStatement -> .LBRACE RBRACE
blockStatement -> .LBRACE blockStatementList RBRACE
statement -> .ASSERT assertExpression SEMI
statement -> .IF LPAREN expression RPAREN blockStatement optionalElseStatement
statement -> .FOR LPAREN forControl RPAREN blockStatement
statement -> .WHILE LPAREN expression RPAREN blockStatement
statement -> .DO blockStatement WHILE LPAREN expression RPAREN SEMI
statement -> .TRY block catchFinallyOrOnlyFinally
statement -> .TRY resourceSpecification block catchClauses
statement -> .TRY resourceSpecification block optionalFinallyBlock
statement -> .TRY resourceSpecification block catchClauses optionalFinallyBlock
statement -> .SWITCH LPAREN expression RPAREN LBRACE switchBlockStatementGroups emptySwitchLabels RBRACE
statement -> .SYNCHRONIZED LPAREN expression RPAREN block
statement -> .RETURN SEMI
statement -> .RETURN expression SEMI
statement -> .THROW expression SEMI
statement -> .BREAK optionalIdentifier SEMI
statement -> .CONTINUE optionalIdentifier SEMI
statement -> .Identifier COLON blockStatement
statement -> .expression SEMI
statement -> .typeDeclarationWithPrefixes
statement -> .variableDeclaratorsWithPrefixes
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
typeDeclarationWithPrefixes -> .annotationl modifierL typeDeclaration
typeDeclarationWithPrefixes -> .modifierL annotationl typeDeclaration
typeDeclarationWithPrefixes -> .modifierL typeDeclaration
typeDeclarationWithPrefixes -> .annotationl typeDeclaration
typeDeclarationWithPrefixes -> .typeDeclaration
variableDeclaratorsWithPrefixes -> .annotationl modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .localVariableDeclaration
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
localVariableDeclaration -> .type variableDeclarators
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks 
transitions ->  {"RBRACE":543,"blockStatementList":544,"blockStatement":465,"statement":466,"LBRACE":467,"ASSERT":468,"IF":469,"FOR":470,"WHILE":471,"DO":472,"TRY":473,"SWITCH":474,"SYNCHRONIZED":475,"RETURN":476,"THROW":477,"BREAK":478,"CONTINUE":479,"Identifier":480,"expression":481,"typeDeclarationWithPrefixes":482,"variableDeclaratorsWithPrefixes":483,"parExpression":98,"qualifiedName":484,"primitiveType":485,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"annotationl":486,"modifierL":487,"typeDeclaration":13,"localVariableDeclaration":488,"LPAREN":115,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131,"annotation":10,"modifier":15,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"type":489,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 468 
statement -> ASSERT .assertExpression SEMI
assertExpression -> .expression
assertExpression -> .expression COLON expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"assertExpression":545,"expression":546,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 469 
statement -> IF .LPAREN expression RPAREN blockStatement optionalElseStatement 
transitions ->  {"LPAREN":547}

item set 470 
statement -> FOR .LPAREN forControl RPAREN blockStatement 
transitions ->  {"LPAREN":548}

item set 471 
statement -> WHILE .LPAREN expression RPAREN blockStatement 
transitions ->  {"LPAREN":549}

item set 472 
statement -> DO .blockStatement WHILE LPAREN expression RPAREN SEMI
blockStatement -> .statement
blockStatement -> .LBRACE RBRACE
blockStatement -> .LBRACE blockStatementList RBRACE
statement -> .ASSERT assertExpression SEMI
statement -> .IF LPAREN expression RPAREN blockStatement optionalElseStatement
statement -> .FOR LPAREN forControl RPAREN blockStatement
statement -> .WHILE LPAREN expression RPAREN blockStatement
statement -> .DO blockStatement WHILE LPAREN expression RPAREN SEMI
statement -> .TRY block catchFinallyOrOnlyFinally
statement -> .TRY resourceSpecification block catchClauses
statement -> .TRY resourceSpecification block optionalFinallyBlock
statement -> .TRY resourceSpecification block catchClauses optionalFinallyBlock
statement -> .SWITCH LPAREN expression RPAREN LBRACE switchBlockStatementGroups emptySwitchLabels RBRACE
statement -> .SYNCHRONIZED LPAREN expression RPAREN block
statement -> .RETURN SEMI
statement -> .RETURN expression SEMI
statement -> .THROW expression SEMI
statement -> .BREAK optionalIdentifier SEMI
statement -> .CONTINUE optionalIdentifier SEMI
statement -> .Identifier COLON blockStatement
statement -> .expression SEMI
statement -> .typeDeclarationWithPrefixes
statement -> .variableDeclaratorsWithPrefixes
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
typeDeclarationWithPrefixes -> .annotationl modifierL typeDeclaration
typeDeclarationWithPrefixes -> .modifierL annotationl typeDeclaration
typeDeclarationWithPrefixes -> .modifierL typeDeclaration
typeDeclarationWithPrefixes -> .annotationl typeDeclaration
typeDeclarationWithPrefixes -> .typeDeclaration
variableDeclaratorsWithPrefixes -> .annotationl modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .localVariableDeclaration
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
localVariableDeclaration -> .type variableDeclarators
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks 
transitions ->  {"blockStatement":550,"statement":466,"LBRACE":467,"ASSERT":468,"IF":469,"FOR":470,"WHILE":471,"DO":472,"TRY":473,"SWITCH":474,"SYNCHRONIZED":475,"RETURN":476,"THROW":477,"BREAK":478,"CONTINUE":479,"Identifier":480,"expression":481,"typeDeclarationWithPrefixes":482,"variableDeclaratorsWithPrefixes":483,"parExpression":98,"qualifiedName":484,"primitiveType":485,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"annotationl":486,"modifierL":487,"typeDeclaration":13,"localVariableDeclaration":488,"LPAREN":115,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131,"annotation":10,"modifier":15,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"type":489,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 473 
statement -> TRY .block catchFinallyOrOnlyFinally
statement -> TRY .resourceSpecification block catchClauses
statement -> TRY .resourceSpecification block optionalFinallyBlock
statement -> TRY .resourceSpecification block catchClauses optionalFinallyBlock
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE
resourceSpecification -> .LPAREN resources semiOpt RPAREN 
transitions ->  {"block":551,"resourceSpecification":552,"LBRACE":403,"LPAREN":553}

item set 474 
statement -> SWITCH .LPAREN expression RPAREN LBRACE switchBlockStatementGroups emptySwitchLabels RBRACE 
transitions ->  {"LPAREN":554}

item set 475 
statement -> SYNCHRONIZED .LPAREN expression RPAREN block
modifier -> SYNCHRONIZED . 
transitions ->  {"LPAREN":555}

item set 476 
statement -> RETURN .SEMI
statement -> RETURN .expression SEMI
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"SEMI":556,"expression":557,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 477 
statement -> THROW .expression SEMI
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":558,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 478 
statement -> BREAK .optionalIdentifier SEMI
optionalIdentifier -> .
optionalIdentifier -> .Identifier 
transitions ->  {"optionalIdentifier":559,"Identifier":560}

item set 479 
statement -> CONTINUE .optionalIdentifier SEMI
optionalIdentifier -> .
optionalIdentifier -> .Identifier 
transitions ->  {"optionalIdentifier":561,"Identifier":560}

item set 480 
statement -> Identifier .COLON blockStatement
qualifiedName -> Identifier .
qualifiedName -> Identifier .typeParameters
typeParameters -> .TEMPLATE 
transitions ->  {"COLON":562,"typeParameters":70,"TEMPLATE":71}

item set 481 
statement -> expression .SEMI
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"SEMI":563,"DOT":151,"LBRACK":152,"arguments":153,"LPAREN":154,"incrementOrDecrement":155,"mulDivOrMod":156,"addOrSub":157,"LSHIFT":158,"GT":159,"lE_GE_LT_GT":160,"INSTANCEOF":161,"equals_NotEqual":162,"BITAND":163,"CARET":164,"BITOR":165,"AND":166,"OR":167,"QUESTION":168,"assignmentToken":169,"INC":170,"DEC":171,"MUL":172,"DIV":173,"MOD":174,"ADD":175,"SUB":176,"LE":177,"GE":178,"LT":179,"EQUAL":180,"NOTEQUAL":181,"ASSIGN":182,"ADD_ASSIGN":183,"SUB_ASSIGN":184,"MUL_ASSIGN":185,"DIV_ASSIGN":186,"AND_ASSIGN":187,"OR_ASSIGN":188,"XOR_ASSIGN":189,"RSHIFT_ASSIGN":190,"URSHIFT_ASSIGN":191,"LSHIFT_ASSIGN":192,"MOD_ASSIGN":193}

item set 482 
statement -> typeDeclarationWithPrefixes . 
transitions ->  {}

item set 483 
statement -> variableDeclaratorsWithPrefixes . 
transitions ->  {}

item set 484 
expression -> qualifiedName .
expression -> qualifiedName .DOT CLASS
expression -> qualifiedName .DOT SUPER
expression -> qualifiedName .DOT SUPER DOT expression
expression -> qualifiedName .DOT newCreator
expression -> qualifiedName .arrayDimensionBrackl DOT CLASS
expression -> qualifiedName .DOT THIS
expression -> qualifiedName .DOT explicitGenericInvocation
expression -> qualifiedName .LBRACK expression RBRACK
qualifiedName -> qualifiedName .DOT Identifier
qualifiedName -> qualifiedName .DOT Identifier typeParameters
type -> qualifiedName .arrayDimensionBracks
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
arrayDimensionBracks -> .
arrayDimensionBracks -> .arrayDimensionBrackl
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"DOT":198,"arrayDimensionBrackl":564,"LBRACK":200,"arrayDimensionBracks":226,"arrayDimensionBrack":201}

item set 485 
expression -> primitiveType .DOT CLASS
expression -> primitiveType .arrayDimensionBrackl DOT CLASS
type -> primitiveType .arrayDimensionBracks
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
arrayDimensionBracks -> .
arrayDimensionBracks -> .arrayDimensionBrackl
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"DOT":202,"arrayDimensionBrackl":565,"arrayDimensionBracks":228,"arrayDimensionBrack":201,"LBRACK":204}

item set 486 
typeDeclarationWithPrefixes -> annotationl .modifierL typeDeclaration
typeDeclarationWithPrefixes -> annotationl .typeDeclaration
variableDeclaratorsWithPrefixes -> annotationl .modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> annotationl .localVariableDeclaration
annotationl -> annotationl .annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
localVariableDeclaration -> .type variableDeclarators
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"modifierL":566,"typeDeclaration":46,"localVariableDeclaration":567,"annotation":63,"modifier":15,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"type":489,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"CLASS":31,"INTERFACE":32,"ENUM":33,"qualifiedName":137,"primitiveType":138,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 487 
typeDeclarationWithPrefixes -> modifierL .annotationl typeDeclaration
typeDeclarationWithPrefixes -> modifierL .typeDeclaration
variableDeclaratorsWithPrefixes -> modifierL .annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> modifierL .localVariableDeclaration
modifierL -> modifierL .modifier
annotationl -> .annotation
annotationl -> .annotationl annotation
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
localVariableDeclaration -> .type variableDeclarators
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"annotationl":568,"typeDeclaration":53,"localVariableDeclaration":569,"modifier":54,"annotation":10,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"type":489,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"AT":14,"CLASS":31,"INTERFACE":32,"ENUM":33,"qualifiedName":137,"primitiveType":138,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 488 
variableDeclaratorsWithPrefixes -> localVariableDeclaration . 
transitions ->  {}

item set 489 
localVariableDeclaration -> type .variableDeclarators
variableDeclarators -> .variableDeclarator
variableDeclarators -> .variableDeclarators COMMA variableDeclarator
variableDeclarator -> .variableDeclaratorId
variableDeclarator -> .variableDeclaratorId ASSIGN variableInitializer
variableDeclaratorId -> .Identifier arrayDimensionBracks 
transitions ->  {"variableDeclarators":570,"variableDeclarator":381,"variableDeclaratorId":382,"Identifier":516}

item set 490 
interfaceBodyDeclaration -> annotationl modifierL interfaceMemberDeclaration . 
transitions ->  {}

item set 491 
interfaceBodyDeclaration -> modifierL annotationl interfaceMemberDeclaration . 
transitions ->  {}

item set 492 
interfaceMemberDeclaration -> type constDelarators commentReturn .SEMI 
transitions ->  {"SEMI":571}

item set 493 
constDelarators -> constDelarators COMMA .constantDeclarator
constantDeclarator -> .Identifier ASSIGN variableInitializer
constantDeclarator -> .Identifier arrayDimensionBrackl ASSIGN variableInitializer 
transitions ->  {"constantDeclarator":572,"Identifier":573}

item set 494 
interfaceMemberDeclaration -> type Identifier formalParameters .arrayDimensionBracks throwsList commentReturn SEMI
interfaceMemberDeclaration -> type Identifier formalParameters .arrayDimensionBracks commentReturn SEMI
interfaceMemberDeclaration -> type Identifier formalParameters .commentReturn SEMI
arrayDimensionBracks -> .
arrayDimensionBracks -> .arrayDimensionBrackl
commentReturn -> .
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"arrayDimensionBracks":574,"commentReturn":575,"arrayDimensionBrackl":227,"arrayDimensionBrack":201,"LBRACK":204}

item set 495 
constantDeclarator -> Identifier ASSIGN .variableInitializer
variableInitializer -> .arrayInitializer
variableInitializer -> .expression
arrayInitializer -> .LBRACE RBRACE
arrayInitializer -> .LBRACE variableInitializerL SEMI RBRACE
arrayInitializer -> .LBRACE variableInitializerL RBRACE
arrayInitializer -> .LBRACE variableInitializerL COMMA RBRACE
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"variableInitializer":576,"arrayInitializer":519,"expression":520,"LBRACE":510,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 496 
constantDeclarator -> Identifier arrayDimensionBrackl .ASSIGN variableInitializer
arrayDimensionBrackl -> arrayDimensionBrackl .arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"ASSIGN":577,"arrayDimensionBrack":272,"LBRACK":204}

item set 497 
interfaceMemberDeclaration -> VOID Identifier formalParameters .arrayDimensionBracks throwsList commentReturn SEMI
interfaceMemberDeclaration -> VOID Identifier formalParameters .arrayDimensionBracks commentReturn SEMI
interfaceMemberDeclaration -> VOID Identifier formalParameters .commentReturn SEMI
arrayDimensionBracks -> .
arrayDimensionBracks -> .arrayDimensionBrackl
commentReturn -> .
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"arrayDimensionBracks":578,"commentReturn":579,"arrayDimensionBrackl":227,"arrayDimensionBrack":201,"LBRACK":204}

item set 498 
interfaceMemberDeclaration -> typeParameters VOID Identifier .formalParameters arrayDimensionBracks throwsList commentReturn SEMI
interfaceMemberDeclaration -> typeParameters VOID Identifier .formalParameters arrayDimensionBracks commentReturn SEMI
interfaceMemberDeclaration -> typeParameters VOID Identifier .formalParameters commentReturn SEMI
formalParameters -> .LPAREN RPAREN
formalParameters -> .LPAREN formalParameterList RPAREN 
transitions ->  {"formalParameters":580,"LPAREN":461}

item set 499 
interfaceMemberDeclaration -> typeParameters type Identifier .formalParameters arrayDimensionBracks throwsList commentReturn SEMI
interfaceMemberDeclaration -> typeParameters type Identifier .formalParameters arrayDimensionBracks commentReturn SEMI
interfaceMemberDeclaration -> typeParameters type Identifier .formalParameters commentReturn SEMI
formalParameters -> .LPAREN RPAREN
formalParameters -> .LPAREN formalParameterList RPAREN 
transitions ->  {"formalParameters":581,"LPAREN":461}

item set 500 
enumBodyDeclaration -> enumConstants COMMA SEMI .
enumBodyDeclaration -> enumConstants COMMA SEMI .classBodyDeclarationl
classBodyDeclarationl -> .classBodyDeclaration
classBodyDeclarationl -> .classBodyDeclarationl classBodyDeclaration
classBodyDeclaration -> .SEMI
classBodyDeclaration -> .annotationl modifierL classMemberDeclaration
classBodyDeclaration -> .modifierL annotationl classMemberDeclaration
classBodyDeclaration -> .modifierL classMemberDeclaration
classBodyDeclaration -> .annotationl classMemberDeclaration
classBodyDeclaration -> .classMemberDeclaration
classBodyDeclaration -> .classStaticBlock
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> .VOID Identifier formalParameters commentReturn block
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> .type Identifier formalParameters commentReturn block
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> .VOID Identifier formalParameters commentReturn SEMI
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> .type Identifier formalParameters commentReturn SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters commentReturn block
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> .typeParameters type Identifier formalParameters commentReturn block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters commentReturn SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters commentReturn SEMI
classMemberDeclaration -> .type variableDeclarators commentReturn SEMI
classMemberDeclaration -> .Identifier formalParameters throwsList commentReturn block
classMemberDeclaration -> .typeParameters Identifier formalParameters throwsList commentReturn block
classMemberDeclaration -> .classDeclaration
classMemberDeclaration -> .interfaceDeclaration
classMemberDeclaration -> .enumDeclaration
classMemberDeclaration -> .annotationTypeDeclaration
classStaticBlock -> .STATIC block
classStaticBlock -> .block
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
typeParameters -> .TEMPLATE
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"classBodyDeclarationl":582,"classBodyDeclaration":387,"SEMI":388,"annotationl":389,"modifierL":390,"classMemberDeclaration":391,"classStaticBlock":392,"annotation":10,"modifier":15,"VOID":393,"type":394,"typeParameters":395,"Identifier":396,"classDeclaration":397,"interfaceDeclaration":398,"enumDeclaration":399,"annotationTypeDeclaration":400,"STATIC":401,"block":402,"AT":14,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"qualifiedName":137,"primitiveType":138,"TEMPLATE":71,"CLASS":31,"INTERFACE":32,"ENUM":33,"LBRACE":403,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 501 
enumConstants -> enumConstants COMMA annotations .Identifier enumConstantArguments commentReturn enumConstantClassBody 
transitions ->  {"Identifier":583}

item set 502 
enumBodyDeclaration -> enumConstants SEMI classBodyDeclarationl .
classBodyDeclarationl -> classBodyDeclarationl .classBodyDeclaration
classBodyDeclaration -> .SEMI
classBodyDeclaration -> .annotationl modifierL classMemberDeclaration
classBodyDeclaration -> .modifierL annotationl classMemberDeclaration
classBodyDeclaration -> .modifierL classMemberDeclaration
classBodyDeclaration -> .annotationl classMemberDeclaration
classBodyDeclaration -> .classMemberDeclaration
classBodyDeclaration -> .classStaticBlock
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> .VOID Identifier formalParameters commentReturn block
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> .type Identifier formalParameters commentReturn block
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> .VOID Identifier formalParameters commentReturn SEMI
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> .type Identifier formalParameters commentReturn SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters commentReturn block
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> .typeParameters type Identifier formalParameters commentReturn block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters commentReturn SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters commentReturn SEMI
classMemberDeclaration -> .type variableDeclarators commentReturn SEMI
classMemberDeclaration -> .Identifier formalParameters throwsList commentReturn block
classMemberDeclaration -> .typeParameters Identifier formalParameters throwsList commentReturn block
classMemberDeclaration -> .classDeclaration
classMemberDeclaration -> .interfaceDeclaration
classMemberDeclaration -> .enumDeclaration
classMemberDeclaration -> .annotationTypeDeclaration
classStaticBlock -> .STATIC block
classStaticBlock -> .block
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
typeParameters -> .TEMPLATE
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"classBodyDeclaration":449,"SEMI":388,"annotationl":389,"modifierL":390,"classMemberDeclaration":391,"classStaticBlock":392,"annotation":10,"modifier":15,"VOID":393,"type":394,"typeParameters":395,"Identifier":396,"classDeclaration":397,"interfaceDeclaration":398,"enumDeclaration":399,"annotationTypeDeclaration":400,"STATIC":401,"block":402,"AT":14,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"qualifiedName":137,"primitiveType":138,"TEMPLATE":71,"CLASS":31,"INTERFACE":32,"ENUM":33,"LBRACE":403,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 503 
enumConstants -> annotations Identifier enumConstantArguments .commentReturn enumConstantClassBody
commentReturn -> . 
transitions ->  {"commentReturn":584}

item set 504 
enumConstantArguments -> arguments . 
transitions ->  {}

item set 505 
innerCreator -> Identifier optionalNonWildcardTypeArgumentsOrDiamond .classCreatorRest
classCreatorRest -> .arguments
classCreatorRest -> .LPAREN RPAREN
classCreatorRest -> .LPAREN RPAREN classBody
classCreatorRest -> .arguments classBody
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN 
transitions ->  {"classCreatorRest":585,"arguments":295,"LPAREN":296}

item set 506 
optionalNonWildcardTypeArgumentsOrDiamond -> nonWildcardTypeArgumentsOrDiamond . 
transitions ->  {}

item set 507 
nonWildcardTypeArgumentsOrDiamond -> LT .GT 
transitions ->  {"GT":586}

item set 508 
nonWildcardTypeArgumentsOrDiamond -> nonWildcardTypeArguments . 
transitions ->  {}

item set 509 
arrayCreatorRest -> LBRACK RBRACK arrayDimensionBracks arrayInitializer . 
transitions ->  {}

item set 510 
arrayInitializer -> LBRACE .RBRACE
arrayInitializer -> LBRACE .variableInitializerL SEMI RBRACE
arrayInitializer -> LBRACE .variableInitializerL RBRACE
arrayInitializer -> LBRACE .variableInitializerL COMMA RBRACE
variableInitializerL -> .variableInitializer
variableInitializerL -> .variableInitializerL COMMA variableInitializer
variableInitializer -> .arrayInitializer
variableInitializer -> .expression
arrayInitializer -> .LBRACE RBRACE
arrayInitializer -> .LBRACE variableInitializerL SEMI RBRACE
arrayInitializer -> .LBRACE variableInitializerL RBRACE
arrayInitializer -> .LBRACE variableInitializerL COMMA RBRACE
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"RBRACE":587,"variableInitializerL":588,"variableInitializer":589,"arrayInitializer":519,"expression":520,"LBRACE":510,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 511 
bracketedExpressions -> bracketedExpressions LBRACK expression RBRACK . 
transitions ->  {}

item set 512 
typeArgumentsOrDiamondList -> typeArgumentsOrDiamondList DOT Identifier typeArgumentsOrDiamond . 
transitions ->  {}

item set 513 
annotationTypeElementRest -> type annotationConstantRest commentReturn SEMI . 
transitions ->  {}

item set 514 
annotationTypeElementRest -> type annotationMethodRest commentReturn SEMI . 
transitions ->  {}

item set 515 
variableDeclarators -> variableDeclarators COMMA variableDeclarator . 
transitions ->  {}

item set 516 
variableDeclaratorId -> Identifier .arrayDimensionBracks
arrayDimensionBracks -> .
arrayDimensionBracks -> .arrayDimensionBrackl
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"arrayDimensionBracks":444,"arrayDimensionBrackl":227,"arrayDimensionBrack":201,"LBRACK":204}

item set 517 
annotationMethodRest -> Identifier LPAREN RPAREN .defaultValue
annotationMethodRest -> Identifier LPAREN RPAREN .
defaultValue -> .DEFAULT elementValue 
transitions ->  {"defaultValue":590,"DEFAULT":591}

item set 518 
variableDeclarator -> variableDeclaratorId ASSIGN variableInitializer . 
transitions ->  {}

item set 519 
variableInitializer -> arrayInitializer . 
transitions ->  {}

item set 520 
variableInitializer -> expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":151,"LBRACK":152,"arguments":153,"LPAREN":154,"incrementOrDecrement":155,"mulDivOrMod":156,"addOrSub":157,"LSHIFT":158,"GT":159,"lE_GE_LT_GT":160,"INSTANCEOF":161,"equals_NotEqual":162,"BITAND":163,"CARET":164,"BITOR":165,"AND":166,"OR":167,"QUESTION":168,"assignmentToken":169,"INC":170,"DEC":171,"MUL":172,"DIV":173,"MOD":174,"ADD":175,"SUB":176,"LE":177,"GE":178,"LT":179,"EQUAL":180,"NOTEQUAL":181,"ASSIGN":182,"ADD_ASSIGN":183,"SUB_ASSIGN":184,"MUL_ASSIGN":185,"DIV_ASSIGN":186,"AND_ASSIGN":187,"OR_ASSIGN":188,"XOR_ASSIGN":189,"RSHIFT_ASSIGN":190,"URSHIFT_ASSIGN":191,"LSHIFT_ASSIGN":192,"MOD_ASSIGN":193}

item set 521 
annotationTypeElementRest -> typeParameters type annotationMethodRest commentReturn .SEMI 
transitions ->  {"SEMI":592}

item set 522 
classBodyDeclaration -> annotationl modifierL classMemberDeclaration . 
transitions ->  {}

item set 523 
classBodyDeclaration -> modifierL annotationl classMemberDeclaration . 
transitions ->  {}

item set 524 
classMemberDeclaration -> VOID Identifier formalParameters .arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> VOID Identifier formalParameters .arrayDimensionBracks commentReturn block
classMemberDeclaration -> VOID Identifier formalParameters .commentReturn block
classMemberDeclaration -> VOID Identifier formalParameters .arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> VOID Identifier formalParameters .arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> VOID Identifier formalParameters .commentReturn SEMI
arrayDimensionBracks -> .
arrayDimensionBracks -> .arrayDimensionBrackl
commentReturn -> .
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"arrayDimensionBracks":593,"commentReturn":594,"arrayDimensionBrackl":227,"arrayDimensionBrack":201,"LBRACK":204}

item set 525 
classMemberDeclaration -> type Identifier formalParameters .arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> type Identifier formalParameters .arrayDimensionBracks commentReturn block
classMemberDeclaration -> type Identifier formalParameters .commentReturn block
classMemberDeclaration -> type Identifier formalParameters .arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> type Identifier formalParameters .arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> type Identifier formalParameters .commentReturn SEMI
arrayDimensionBracks -> .
arrayDimensionBracks -> .arrayDimensionBrackl
commentReturn -> .
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"arrayDimensionBracks":595,"commentReturn":596,"arrayDimensionBrackl":227,"arrayDimensionBrack":201,"LBRACK":204}

item set 526 
classMemberDeclaration -> type variableDeclarators commentReturn .SEMI 
transitions ->  {"SEMI":597}

item set 527 
classMemberDeclaration -> typeParameters VOID Identifier .formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> typeParameters VOID Identifier .formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> typeParameters VOID Identifier .formalParameters commentReturn block
classMemberDeclaration -> typeParameters VOID Identifier .formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> typeParameters VOID Identifier .formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> typeParameters VOID Identifier .formalParameters commentReturn SEMI
formalParameters -> .LPAREN RPAREN
formalParameters -> .LPAREN formalParameterList RPAREN 
transitions ->  {"formalParameters":598,"LPAREN":461}

item set 528 
classMemberDeclaration -> typeParameters type Identifier .formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> typeParameters type Identifier .formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> typeParameters type Identifier .formalParameters commentReturn block
classMemberDeclaration -> typeParameters type Identifier .formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> typeParameters type Identifier .formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> typeParameters type Identifier .formalParameters commentReturn SEMI
formalParameters -> .LPAREN RPAREN
formalParameters -> .LPAREN formalParameterList RPAREN 
transitions ->  {"formalParameters":599,"LPAREN":461}

item set 529 
classMemberDeclaration -> typeParameters Identifier formalParameters .throwsList commentReturn block
throwsList -> .
throwsList -> .THROWS qualifiedNameList 
transitions ->  {"throwsList":600,"THROWS":531}

item set 530 
classMemberDeclaration -> Identifier formalParameters throwsList .commentReturn block
commentReturn -> . 
transitions ->  {"commentReturn":601}

item set 531 
throwsList -> THROWS .qualifiedNameList
qualifiedNameList -> .qualifiedName
qualifiedNameList -> .qualifiedNameList COMMA qualifiedName
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters 
transitions ->  {"qualifiedNameList":602,"qualifiedName":603,"Identifier":49}

item set 532 
formalParameters -> LPAREN RPAREN . 
transitions ->  {}

item set 533 
formalParameters -> LPAREN formalParameterList .RPAREN 
transitions ->  {"RPAREN":604}

item set 534 
formalParameterList -> usualParameterList .
formalParameterList -> usualParameterList .COMMA lastFormalParameter
usualParameterList -> usualParameterList .COMMA usualParameter 
transitions ->  {"COMMA":605}

item set 535 
formalParameterList -> lastFormalParameter . 
transitions ->  {}

item set 536 
usualParameterList -> usualParameter . 
transitions ->  {}

item set 537 
lastFormalParameter -> variableModifiers .type ELLIPSIS variableDeclaratorId
usualParameter -> variableModifiers .type variableDeclaratorId
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"type":606,"qualifiedName":137,"primitiveType":138,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 538 
lastFormalParameter -> type .ELLIPSIS variableDeclaratorId
usualParameter -> type .variableDeclaratorId
variableDeclaratorId -> .Identifier arrayDimensionBracks 
transitions ->  {"ELLIPSIS":607,"variableDeclaratorId":608,"Identifier":516}

item set 539 
variableModifiers -> FINAL .annotationl
variableModifiers -> FINAL .
annotationl -> .annotation
annotationl -> .annotationl annotation
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN 
transitions ->  {"annotationl":609,"annotation":10,"AT":67}

item set 540 
variableModifiers -> annotationl .
variableModifiers -> annotationl .FINAL
annotationl -> annotationl .annotation
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN 
transitions ->  {"FINAL":610,"annotation":63,"AT":67}

item set 541 
block -> LBRACE blockStatementList RBRACE . 
transitions ->  {}

item set 542 
blockStatementList -> blockStatementList blockStatement . 
transitions ->  {}

item set 543 
blockStatement -> LBRACE RBRACE . 
transitions ->  {}

item set 544 
blockStatement -> LBRACE blockStatementList .RBRACE
blockStatementList -> blockStatementList .blockStatement
blockStatement -> .statement
blockStatement -> .LBRACE RBRACE
blockStatement -> .LBRACE blockStatementList RBRACE
statement -> .ASSERT assertExpression SEMI
statement -> .IF LPAREN expression RPAREN blockStatement optionalElseStatement
statement -> .FOR LPAREN forControl RPAREN blockStatement
statement -> .WHILE LPAREN expression RPAREN blockStatement
statement -> .DO blockStatement WHILE LPAREN expression RPAREN SEMI
statement -> .TRY block catchFinallyOrOnlyFinally
statement -> .TRY resourceSpecification block catchClauses
statement -> .TRY resourceSpecification block optionalFinallyBlock
statement -> .TRY resourceSpecification block catchClauses optionalFinallyBlock
statement -> .SWITCH LPAREN expression RPAREN LBRACE switchBlockStatementGroups emptySwitchLabels RBRACE
statement -> .SYNCHRONIZED LPAREN expression RPAREN block
statement -> .RETURN SEMI
statement -> .RETURN expression SEMI
statement -> .THROW expression SEMI
statement -> .BREAK optionalIdentifier SEMI
statement -> .CONTINUE optionalIdentifier SEMI
statement -> .Identifier COLON blockStatement
statement -> .expression SEMI
statement -> .typeDeclarationWithPrefixes
statement -> .variableDeclaratorsWithPrefixes
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
typeDeclarationWithPrefixes -> .annotationl modifierL typeDeclaration
typeDeclarationWithPrefixes -> .modifierL annotationl typeDeclaration
typeDeclarationWithPrefixes -> .modifierL typeDeclaration
typeDeclarationWithPrefixes -> .annotationl typeDeclaration
typeDeclarationWithPrefixes -> .typeDeclaration
variableDeclaratorsWithPrefixes -> .annotationl modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .localVariableDeclaration
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
localVariableDeclaration -> .type variableDeclarators
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks 
transitions ->  {"RBRACE":611,"blockStatement":542,"statement":466,"LBRACE":467,"ASSERT":468,"IF":469,"FOR":470,"WHILE":471,"DO":472,"TRY":473,"SWITCH":474,"SYNCHRONIZED":475,"RETURN":476,"THROW":477,"BREAK":478,"CONTINUE":479,"Identifier":480,"expression":481,"typeDeclarationWithPrefixes":482,"variableDeclaratorsWithPrefixes":483,"parExpression":98,"qualifiedName":484,"primitiveType":485,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"annotationl":486,"modifierL":487,"typeDeclaration":13,"localVariableDeclaration":488,"LPAREN":115,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131,"annotation":10,"modifier":15,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"type":489,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 545 
statement -> ASSERT assertExpression .SEMI 
transitions ->  {"SEMI":612}

item set 546 
assertExpression -> expression .
assertExpression -> expression .COLON expression
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"COLON":613,"DOT":151,"LBRACK":152,"arguments":153,"LPAREN":154,"incrementOrDecrement":155,"mulDivOrMod":156,"addOrSub":157,"LSHIFT":158,"GT":159,"lE_GE_LT_GT":160,"INSTANCEOF":161,"equals_NotEqual":162,"BITAND":163,"CARET":164,"BITOR":165,"AND":166,"OR":167,"QUESTION":168,"assignmentToken":169,"INC":170,"DEC":171,"MUL":172,"DIV":173,"MOD":174,"ADD":175,"SUB":176,"LE":177,"GE":178,"LT":179,"EQUAL":180,"NOTEQUAL":181,"ASSIGN":182,"ADD_ASSIGN":183,"SUB_ASSIGN":184,"MUL_ASSIGN":185,"DIV_ASSIGN":186,"AND_ASSIGN":187,"OR_ASSIGN":188,"XOR_ASSIGN":189,"RSHIFT_ASSIGN":190,"URSHIFT_ASSIGN":191,"LSHIFT_ASSIGN":192,"MOD_ASSIGN":193}

item set 547 
statement -> IF LPAREN .expression RPAREN blockStatement optionalElseStatement
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":614,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 548 
statement -> FOR LPAREN .forControl RPAREN blockStatement
forControl -> .enhancedForControl
forControl -> .forInit SEMI optionalExpression SEMI optionalForUpdate
forControl -> .SEMI optionalExpression SEMI optionalForUpdate
enhancedForControl -> .modifierL type variableDeclaratorId COLON expression
enhancedForControl -> .type variableDeclaratorId COLON expression
forInit -> .variableDeclaratorsWithPrefixes
forInit -> .expressionList
modifierL -> .modifier
modifierL -> .modifierL modifier
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
variableDeclaratorsWithPrefixes -> .annotationl modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .localVariableDeclaration
expressionList -> .expression
expressionList -> .expressionList COMMA expression
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
annotationl -> .annotation
annotationl -> .annotationl annotation
localVariableDeclaration -> .type variableDeclarators
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"forControl":615,"enhancedForControl":616,"forInit":617,"SEMI":618,"modifierL":619,"type":620,"variableDeclaratorsWithPrefixes":621,"expressionList":622,"modifier":15,"qualifiedName":484,"primitiveType":485,"annotationl":623,"localVariableDeclaration":488,"expression":248,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"annotation":10,"parExpression":98,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"AT":67,"LPAREN":115,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 549 
statement -> WHILE LPAREN .expression RPAREN blockStatement
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":624,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 550 
statement -> DO blockStatement .WHILE LPAREN expression RPAREN SEMI 
transitions ->  {"WHILE":625}

item set 551 
statement -> TRY block .catchFinallyOrOnlyFinally
catchFinallyOrOnlyFinally -> .catchClauses optionalFinallyBlock
catchFinallyOrOnlyFinally -> .finallyBlock
catchClauses -> .catchClause
catchClauses -> .catchClauses catchClause
finallyBlock -> .FINALLY block
catchClause -> .CATCH LPAREN variableModifiers catchType Identifier RPAREN block
catchClause -> .CATCH LPAREN catchType Identifier RPAREN block 
transitions ->  {"catchFinallyOrOnlyFinally":626,"catchClauses":627,"finallyBlock":628,"catchClause":629,"FINALLY":630,"CATCH":631}

item set 552 
statement -> TRY resourceSpecification .block catchClauses
statement -> TRY resourceSpecification .block optionalFinallyBlock
statement -> TRY resourceSpecification .block catchClauses optionalFinallyBlock
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE 
transitions ->  {"block":632,"LBRACE":403}

item set 553 
resourceSpecification -> LPAREN .resources semiOpt RPAREN
resources -> .resource
resources -> .resources SEMI resource
resource -> .variableModifiers classOrInterfaceType variableDeclaratorId ASSIGN expression
resource -> .classOrInterfaceType variableDeclaratorId ASSIGN expression
variableModifiers -> .FINAL annotationl
variableModifiers -> .annotationl
variableModifiers -> .FINAL
variableModifiers -> .annotationl FINAL
classOrInterfaceType -> .qualifiedName
classOrInterfaceType -> .qualifiedName typeParameters
annotationl -> .annotation
annotationl -> .annotationl annotation
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN 
transitions ->  {"resources":633,"resource":634,"variableModifiers":635,"classOrInterfaceType":636,"FINAL":539,"annotationl":540,"qualifiedName":637,"annotation":10,"Identifier":49,"AT":67}

item set 554 
statement -> SWITCH LPAREN .expression RPAREN LBRACE switchBlockStatementGroups emptySwitchLabels RBRACE
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":638,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 555 
statement -> SYNCHRONIZED LPAREN .expression RPAREN block
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":639,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 556 
statement -> RETURN SEMI . 
transitions ->  {}

item set 557 
statement -> RETURN expression .SEMI
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"SEMI":640,"DOT":151,"LBRACK":152,"arguments":153,"LPAREN":154,"incrementOrDecrement":155,"mulDivOrMod":156,"addOrSub":157,"LSHIFT":158,"GT":159,"lE_GE_LT_GT":160,"INSTANCEOF":161,"equals_NotEqual":162,"BITAND":163,"CARET":164,"BITOR":165,"AND":166,"OR":167,"QUESTION":168,"assignmentToken":169,"INC":170,"DEC":171,"MUL":172,"DIV":173,"MOD":174,"ADD":175,"SUB":176,"LE":177,"GE":178,"LT":179,"EQUAL":180,"NOTEQUAL":181,"ASSIGN":182,"ADD_ASSIGN":183,"SUB_ASSIGN":184,"MUL_ASSIGN":185,"DIV_ASSIGN":186,"AND_ASSIGN":187,"OR_ASSIGN":188,"XOR_ASSIGN":189,"RSHIFT_ASSIGN":190,"URSHIFT_ASSIGN":191,"LSHIFT_ASSIGN":192,"MOD_ASSIGN":193}

item set 558 
statement -> THROW expression .SEMI
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"SEMI":641,"DOT":151,"LBRACK":152,"arguments":153,"LPAREN":154,"incrementOrDecrement":155,"mulDivOrMod":156,"addOrSub":157,"LSHIFT":158,"GT":159,"lE_GE_LT_GT":160,"INSTANCEOF":161,"equals_NotEqual":162,"BITAND":163,"CARET":164,"BITOR":165,"AND":166,"OR":167,"QUESTION":168,"assignmentToken":169,"INC":170,"DEC":171,"MUL":172,"DIV":173,"MOD":174,"ADD":175,"SUB":176,"LE":177,"GE":178,"LT":179,"EQUAL":180,"NOTEQUAL":181,"ASSIGN":182,"ADD_ASSIGN":183,"SUB_ASSIGN":184,"MUL_ASSIGN":185,"DIV_ASSIGN":186,"AND_ASSIGN":187,"OR_ASSIGN":188,"XOR_ASSIGN":189,"RSHIFT_ASSIGN":190,"URSHIFT_ASSIGN":191,"LSHIFT_ASSIGN":192,"MOD_ASSIGN":193}

item set 559 
statement -> BREAK optionalIdentifier .SEMI 
transitions ->  {"SEMI":642}

item set 560 
optionalIdentifier -> Identifier . 
transitions ->  {}

item set 561 
statement -> CONTINUE optionalIdentifier .SEMI 
transitions ->  {"SEMI":643}

item set 562 
statement -> Identifier COLON .blockStatement
blockStatement -> .statement
blockStatement -> .LBRACE RBRACE
blockStatement -> .LBRACE blockStatementList RBRACE
statement -> .ASSERT assertExpression SEMI
statement -> .IF LPAREN expression RPAREN blockStatement optionalElseStatement
statement -> .FOR LPAREN forControl RPAREN blockStatement
statement -> .WHILE LPAREN expression RPAREN blockStatement
statement -> .DO blockStatement WHILE LPAREN expression RPAREN SEMI
statement -> .TRY block catchFinallyOrOnlyFinally
statement -> .TRY resourceSpecification block catchClauses
statement -> .TRY resourceSpecification block optionalFinallyBlock
statement -> .TRY resourceSpecification block catchClauses optionalFinallyBlock
statement -> .SWITCH LPAREN expression RPAREN LBRACE switchBlockStatementGroups emptySwitchLabels RBRACE
statement -> .SYNCHRONIZED LPAREN expression RPAREN block
statement -> .RETURN SEMI
statement -> .RETURN expression SEMI
statement -> .THROW expression SEMI
statement -> .BREAK optionalIdentifier SEMI
statement -> .CONTINUE optionalIdentifier SEMI
statement -> .Identifier COLON blockStatement
statement -> .expression SEMI
statement -> .typeDeclarationWithPrefixes
statement -> .variableDeclaratorsWithPrefixes
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
typeDeclarationWithPrefixes -> .annotationl modifierL typeDeclaration
typeDeclarationWithPrefixes -> .modifierL annotationl typeDeclaration
typeDeclarationWithPrefixes -> .modifierL typeDeclaration
typeDeclarationWithPrefixes -> .annotationl typeDeclaration
typeDeclarationWithPrefixes -> .typeDeclaration
variableDeclaratorsWithPrefixes -> .annotationl modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .localVariableDeclaration
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
localVariableDeclaration -> .type variableDeclarators
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks 
transitions ->  {"blockStatement":644,"statement":466,"LBRACE":467,"ASSERT":468,"IF":469,"FOR":470,"WHILE":471,"DO":472,"TRY":473,"SWITCH":474,"SYNCHRONIZED":475,"RETURN":476,"THROW":477,"BREAK":478,"CONTINUE":479,"Identifier":480,"expression":481,"typeDeclarationWithPrefixes":482,"variableDeclaratorsWithPrefixes":483,"parExpression":98,"qualifiedName":484,"primitiveType":485,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"annotationl":486,"modifierL":487,"typeDeclaration":13,"localVariableDeclaration":488,"LPAREN":115,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131,"annotation":10,"modifier":15,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"type":489,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 563 
statement -> expression SEMI . 
transitions ->  {}

item set 564 
expression -> qualifiedName arrayDimensionBrackl .DOT CLASS
arrayDimensionBrackl -> arrayDimensionBrackl .arrayDimensionBrack
arrayDimensionBracks -> arrayDimensionBrackl .
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"DOT":271,"arrayDimensionBrack":272,"LBRACK":204}

item set 565 
expression -> primitiveType arrayDimensionBrackl .DOT CLASS
arrayDimensionBrackl -> arrayDimensionBrackl .arrayDimensionBrack
arrayDimensionBracks -> arrayDimensionBrackl .
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"DOT":276,"arrayDimensionBrack":272,"LBRACK":204}

item set 566 
typeDeclarationWithPrefixes -> annotationl modifierL .typeDeclaration
variableDeclaratorsWithPrefixes -> annotationl modifierL .localVariableDeclaration
modifierL -> modifierL .modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
localVariableDeclaration -> .type variableDeclarators
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"typeDeclaration":65,"localVariableDeclaration":645,"modifier":54,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"type":489,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"CLASS":31,"INTERFACE":32,"ENUM":33,"AT":66,"qualifiedName":137,"primitiveType":138,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 567 
variableDeclaratorsWithPrefixes -> annotationl localVariableDeclaration . 
transitions ->  {}

item set 568 
typeDeclarationWithPrefixes -> modifierL annotationl .typeDeclaration
variableDeclaratorsWithPrefixes -> modifierL annotationl .localVariableDeclaration
annotationl -> annotationl .annotation
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
localVariableDeclaration -> .type variableDeclarators
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"typeDeclaration":75,"localVariableDeclaration":646,"annotation":63,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"type":489,"AT":14,"CLASS":31,"INTERFACE":32,"ENUM":33,"qualifiedName":137,"primitiveType":138,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 569 
variableDeclaratorsWithPrefixes -> modifierL localVariableDeclaration . 
transitions ->  {}

item set 570 
localVariableDeclaration -> type variableDeclarators .
variableDeclarators -> variableDeclarators .COMMA variableDeclarator 
transitions ->  {"COMMA":442}

item set 571 
interfaceMemberDeclaration -> type constDelarators commentReturn SEMI . 
transitions ->  {}

item set 572 
constDelarators -> constDelarators COMMA constantDeclarator . 
transitions ->  {}

item set 573 
constantDeclarator -> Identifier .ASSIGN variableInitializer
constantDeclarator -> Identifier .arrayDimensionBrackl ASSIGN variableInitializer
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"ASSIGN":495,"arrayDimensionBrackl":496,"arrayDimensionBrack":201,"LBRACK":204}

item set 574 
interfaceMemberDeclaration -> type Identifier formalParameters arrayDimensionBracks .throwsList commentReturn SEMI
interfaceMemberDeclaration -> type Identifier formalParameters arrayDimensionBracks .commentReturn SEMI
throwsList -> .
throwsList -> .THROWS qualifiedNameList
commentReturn -> . 
transitions ->  {"throwsList":647,"commentReturn":648,"THROWS":531}

item set 575 
interfaceMemberDeclaration -> type Identifier formalParameters commentReturn .SEMI 
transitions ->  {"SEMI":649}

item set 576 
constantDeclarator -> Identifier ASSIGN variableInitializer . 
transitions ->  {}

item set 577 
constantDeclarator -> Identifier arrayDimensionBrackl ASSIGN .variableInitializer
variableInitializer -> .arrayInitializer
variableInitializer -> .expression
arrayInitializer -> .LBRACE RBRACE
arrayInitializer -> .LBRACE variableInitializerL SEMI RBRACE
arrayInitializer -> .LBRACE variableInitializerL RBRACE
arrayInitializer -> .LBRACE variableInitializerL COMMA RBRACE
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"variableInitializer":650,"arrayInitializer":519,"expression":520,"LBRACE":510,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 578 
interfaceMemberDeclaration -> VOID Identifier formalParameters arrayDimensionBracks .throwsList commentReturn SEMI
interfaceMemberDeclaration -> VOID Identifier formalParameters arrayDimensionBracks .commentReturn SEMI
throwsList -> .
throwsList -> .THROWS qualifiedNameList
commentReturn -> . 
transitions ->  {"throwsList":651,"commentReturn":652,"THROWS":531}

item set 579 
interfaceMemberDeclaration -> VOID Identifier formalParameters commentReturn .SEMI 
transitions ->  {"SEMI":653}

item set 580 
interfaceMemberDeclaration -> typeParameters VOID Identifier formalParameters .arrayDimensionBracks throwsList commentReturn SEMI
interfaceMemberDeclaration -> typeParameters VOID Identifier formalParameters .arrayDimensionBracks commentReturn SEMI
interfaceMemberDeclaration -> typeParameters VOID Identifier formalParameters .commentReturn SEMI
arrayDimensionBracks -> .
arrayDimensionBracks -> .arrayDimensionBrackl
commentReturn -> .
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"arrayDimensionBracks":654,"commentReturn":655,"arrayDimensionBrackl":227,"arrayDimensionBrack":201,"LBRACK":204}

item set 581 
interfaceMemberDeclaration -> typeParameters type Identifier formalParameters .arrayDimensionBracks throwsList commentReturn SEMI
interfaceMemberDeclaration -> typeParameters type Identifier formalParameters .arrayDimensionBracks commentReturn SEMI
interfaceMemberDeclaration -> typeParameters type Identifier formalParameters .commentReturn SEMI
arrayDimensionBracks -> .
arrayDimensionBracks -> .arrayDimensionBrackl
commentReturn -> .
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"arrayDimensionBracks":656,"commentReturn":657,"arrayDimensionBrackl":227,"arrayDimensionBrack":201,"LBRACK":204}

item set 582 
enumBodyDeclaration -> enumConstants COMMA SEMI classBodyDeclarationl .
classBodyDeclarationl -> classBodyDeclarationl .classBodyDeclaration
classBodyDeclaration -> .SEMI
classBodyDeclaration -> .annotationl modifierL classMemberDeclaration
classBodyDeclaration -> .modifierL annotationl classMemberDeclaration
classBodyDeclaration -> .modifierL classMemberDeclaration
classBodyDeclaration -> .annotationl classMemberDeclaration
classBodyDeclaration -> .classMemberDeclaration
classBodyDeclaration -> .classStaticBlock
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> .VOID Identifier formalParameters commentReturn block
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> .type Identifier formalParameters commentReturn block
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> .VOID Identifier formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> .VOID Identifier formalParameters commentReturn SEMI
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> .type Identifier formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> .type Identifier formalParameters commentReturn SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters commentReturn block
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks commentReturn block
classMemberDeclaration -> .typeParameters type Identifier formalParameters commentReturn block
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> .typeParameters VOID Identifier formalParameters commentReturn SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> .typeParameters type Identifier formalParameters commentReturn SEMI
classMemberDeclaration -> .type variableDeclarators commentReturn SEMI
classMemberDeclaration -> .Identifier formalParameters throwsList commentReturn block
classMemberDeclaration -> .typeParameters Identifier formalParameters throwsList commentReturn block
classMemberDeclaration -> .classDeclaration
classMemberDeclaration -> .interfaceDeclaration
classMemberDeclaration -> .enumDeclaration
classMemberDeclaration -> .annotationTypeDeclaration
classStaticBlock -> .STATIC block
classStaticBlock -> .block
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
typeParameters -> .TEMPLATE
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"classBodyDeclaration":449,"SEMI":388,"annotationl":389,"modifierL":390,"classMemberDeclaration":391,"classStaticBlock":392,"annotation":10,"modifier":15,"VOID":393,"type":394,"typeParameters":395,"Identifier":396,"classDeclaration":397,"interfaceDeclaration":398,"enumDeclaration":399,"annotationTypeDeclaration":400,"STATIC":401,"block":402,"AT":14,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"qualifiedName":137,"primitiveType":138,"TEMPLATE":71,"CLASS":31,"INTERFACE":32,"ENUM":33,"LBRACE":403,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 583 
enumConstants -> enumConstants COMMA annotations Identifier .enumConstantArguments commentReturn enumConstantClassBody
enumConstantArguments -> .
enumConstantArguments -> .arguments
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN 
transitions ->  {"enumConstantArguments":658,"arguments":504,"LPAREN":279}

item set 584 
enumConstants -> annotations Identifier enumConstantArguments commentReturn .enumConstantClassBody
enumConstantClassBody -> .
enumConstantClassBody -> .classBody
classBody -> .LBRACE RBRACE
classBody -> .LBRACE classBodyDeclarationl RBRACE 
transitions ->  {"enumConstantClassBody":659,"classBody":660,"LBRACE":317}

item set 585 
innerCreator -> Identifier optionalNonWildcardTypeArgumentsOrDiamond classCreatorRest . 
transitions ->  {}

item set 586 
nonWildcardTypeArgumentsOrDiamond -> LT GT . 
transitions ->  {}

item set 587 
arrayInitializer -> LBRACE RBRACE . 
transitions ->  {}

item set 588 
arrayInitializer -> LBRACE variableInitializerL .SEMI RBRACE
arrayInitializer -> LBRACE variableInitializerL .RBRACE
arrayInitializer -> LBRACE variableInitializerL .COMMA RBRACE
variableInitializerL -> variableInitializerL .COMMA variableInitializer 
transitions ->  {"SEMI":661,"RBRACE":662,"COMMA":663}

item set 589 
variableInitializerL -> variableInitializer . 
transitions ->  {}

item set 590 
annotationMethodRest -> Identifier LPAREN RPAREN defaultValue . 
transitions ->  {}

item set 591 
defaultValue -> DEFAULT .elementValue
elementValue -> .expression
elementValue -> .annotations
elementValue -> .LBRACE RBRACE
elementValue -> .LBRACE elementValueList RBRACE
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
annotations -> .
annotations -> .annotationl
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE
annotationl -> .annotation
annotationl -> .annotationl annotation
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN 
transitions ->  {"elementValue":664,"expression":94,"annotations":95,"LBRACE":96,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"annotationl":114,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131,"annotation":10,"AT":67}

item set 592 
annotationTypeElementRest -> typeParameters type annotationMethodRest commentReturn SEMI . 
transitions ->  {}

item set 593 
classMemberDeclaration -> VOID Identifier formalParameters arrayDimensionBracks .throwsList commentReturn block
classMemberDeclaration -> VOID Identifier formalParameters arrayDimensionBracks .commentReturn block
classMemberDeclaration -> VOID Identifier formalParameters arrayDimensionBracks .throwsList commentReturn SEMI
classMemberDeclaration -> VOID Identifier formalParameters arrayDimensionBracks .commentReturn SEMI
throwsList -> .
throwsList -> .THROWS qualifiedNameList
commentReturn -> . 
transitions ->  {"throwsList":665,"commentReturn":666,"THROWS":531}

item set 594 
classMemberDeclaration -> VOID Identifier formalParameters commentReturn .block
classMemberDeclaration -> VOID Identifier formalParameters commentReturn .SEMI
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE 
transitions ->  {"block":667,"SEMI":668,"LBRACE":403}

item set 595 
classMemberDeclaration -> type Identifier formalParameters arrayDimensionBracks .throwsList commentReturn block
classMemberDeclaration -> type Identifier formalParameters arrayDimensionBracks .commentReturn block
classMemberDeclaration -> type Identifier formalParameters arrayDimensionBracks .throwsList commentReturn SEMI
classMemberDeclaration -> type Identifier formalParameters arrayDimensionBracks .commentReturn SEMI
throwsList -> .
throwsList -> .THROWS qualifiedNameList
commentReturn -> . 
transitions ->  {"throwsList":669,"commentReturn":670,"THROWS":531}

item set 596 
classMemberDeclaration -> type Identifier formalParameters commentReturn .block
classMemberDeclaration -> type Identifier formalParameters commentReturn .SEMI
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE 
transitions ->  {"block":671,"SEMI":672,"LBRACE":403}

item set 597 
classMemberDeclaration -> type variableDeclarators commentReturn SEMI . 
transitions ->  {}

item set 598 
classMemberDeclaration -> typeParameters VOID Identifier formalParameters .arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> typeParameters VOID Identifier formalParameters .arrayDimensionBracks commentReturn block
classMemberDeclaration -> typeParameters VOID Identifier formalParameters .commentReturn block
classMemberDeclaration -> typeParameters VOID Identifier formalParameters .arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> typeParameters VOID Identifier formalParameters .arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> typeParameters VOID Identifier formalParameters .commentReturn SEMI
arrayDimensionBracks -> .
arrayDimensionBracks -> .arrayDimensionBrackl
commentReturn -> .
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"arrayDimensionBracks":673,"commentReturn":674,"arrayDimensionBrackl":227,"arrayDimensionBrack":201,"LBRACK":204}

item set 599 
classMemberDeclaration -> typeParameters type Identifier formalParameters .arrayDimensionBracks throwsList commentReturn block
classMemberDeclaration -> typeParameters type Identifier formalParameters .arrayDimensionBracks commentReturn block
classMemberDeclaration -> typeParameters type Identifier formalParameters .commentReturn block
classMemberDeclaration -> typeParameters type Identifier formalParameters .arrayDimensionBracks throwsList commentReturn SEMI
classMemberDeclaration -> typeParameters type Identifier formalParameters .arrayDimensionBracks commentReturn SEMI
classMemberDeclaration -> typeParameters type Identifier formalParameters .commentReturn SEMI
arrayDimensionBracks -> .
arrayDimensionBracks -> .arrayDimensionBrackl
commentReturn -> .
arrayDimensionBrackl -> .arrayDimensionBrack
arrayDimensionBrackl -> .arrayDimensionBrackl arrayDimensionBrack
arrayDimensionBrack -> .LBRACK RBRACK 
transitions ->  {"arrayDimensionBracks":675,"commentReturn":676,"arrayDimensionBrackl":227,"arrayDimensionBrack":201,"LBRACK":204}

item set 600 
classMemberDeclaration -> typeParameters Identifier formalParameters throwsList .commentReturn block
commentReturn -> . 
transitions ->  {"commentReturn":677}

item set 601 
classMemberDeclaration -> Identifier formalParameters throwsList commentReturn .block
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE 
transitions ->  {"block":678,"LBRACE":403}

item set 602 
throwsList -> THROWS qualifiedNameList .
qualifiedNameList -> qualifiedNameList .COMMA qualifiedName 
transitions ->  {"COMMA":679}

item set 603 
qualifiedNameList -> qualifiedName .
qualifiedName -> qualifiedName .DOT Identifier
qualifiedName -> qualifiedName .DOT Identifier typeParameters 
transitions ->  {"DOT":69}

item set 604 
formalParameters -> LPAREN formalParameterList RPAREN . 
transitions ->  {}

item set 605 
formalParameterList -> usualParameterList COMMA .lastFormalParameter
usualParameterList -> usualParameterList COMMA .usualParameter
lastFormalParameter -> .variableModifiers type ELLIPSIS variableDeclaratorId
lastFormalParameter -> .type ELLIPSIS variableDeclaratorId
usualParameter -> .variableModifiers type variableDeclaratorId
usualParameter -> .type variableDeclaratorId
variableModifiers -> .FINAL annotationl
variableModifiers -> .annotationl
variableModifiers -> .FINAL
variableModifiers -> .annotationl FINAL
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
annotationl -> .annotation
annotationl -> .annotationl annotation
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN 
transitions ->  {"lastFormalParameter":680,"usualParameter":681,"variableModifiers":537,"type":538,"FINAL":539,"annotationl":540,"qualifiedName":137,"primitiveType":138,"annotation":10,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"AT":67}

item set 606 
lastFormalParameter -> variableModifiers type .ELLIPSIS variableDeclaratorId
usualParameter -> variableModifiers type .variableDeclaratorId
variableDeclaratorId -> .Identifier arrayDimensionBracks 
transitions ->  {"ELLIPSIS":682,"variableDeclaratorId":683,"Identifier":516}

item set 607 
lastFormalParameter -> type ELLIPSIS .variableDeclaratorId
variableDeclaratorId -> .Identifier arrayDimensionBracks 
transitions ->  {"variableDeclaratorId":684,"Identifier":516}

item set 608 
usualParameter -> type variableDeclaratorId . 
transitions ->  {}

item set 609 
variableModifiers -> FINAL annotationl .
annotationl -> annotationl .annotation
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN 
transitions ->  {"annotation":63,"AT":67}

item set 610 
variableModifiers -> annotationl FINAL . 
transitions ->  {}

item set 611 
blockStatement -> LBRACE blockStatementList RBRACE . 
transitions ->  {}

item set 612 
statement -> ASSERT assertExpression SEMI . 
transitions ->  {}

item set 613 
assertExpression -> expression COLON .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":685,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 614 
statement -> IF LPAREN expression .RPAREN blockStatement optionalElseStatement
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"RPAREN":686,"DOT":151,"LBRACK":152,"arguments":153,"LPAREN":154,"incrementOrDecrement":155,"mulDivOrMod":156,"addOrSub":157,"LSHIFT":158,"GT":159,"lE_GE_LT_GT":160,"INSTANCEOF":161,"equals_NotEqual":162,"BITAND":163,"CARET":164,"BITOR":165,"AND":166,"OR":167,"QUESTION":168,"assignmentToken":169,"INC":170,"DEC":171,"MUL":172,"DIV":173,"MOD":174,"ADD":175,"SUB":176,"LE":177,"GE":178,"LT":179,"EQUAL":180,"NOTEQUAL":181,"ASSIGN":182,"ADD_ASSIGN":183,"SUB_ASSIGN":184,"MUL_ASSIGN":185,"DIV_ASSIGN":186,"AND_ASSIGN":187,"OR_ASSIGN":188,"XOR_ASSIGN":189,"RSHIFT_ASSIGN":190,"URSHIFT_ASSIGN":191,"LSHIFT_ASSIGN":192,"MOD_ASSIGN":193}

item set 615 
statement -> FOR LPAREN forControl .RPAREN blockStatement 
transitions ->  {"RPAREN":687}

item set 616 
forControl -> enhancedForControl . 
transitions ->  {}

item set 617 
forControl -> forInit .SEMI optionalExpression SEMI optionalForUpdate 
transitions ->  {"SEMI":688}

item set 618 
forControl -> SEMI .optionalExpression SEMI optionalForUpdate
optionalExpression -> .
optionalExpression -> .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"optionalExpression":689,"expression":690,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 619 
enhancedForControl -> modifierL .type variableDeclaratorId COLON expression
modifierL -> modifierL .modifier
variableDeclaratorsWithPrefixes -> modifierL .annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> modifierL .localVariableDeclaration
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
annotationl -> .annotation
annotationl -> .annotationl annotation
localVariableDeclaration -> .type variableDeclarators
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN 
transitions ->  {"type":691,"modifier":54,"annotationl":692,"localVariableDeclaration":569,"qualifiedName":137,"primitiveType":138,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"annotation":10,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"AT":67}

item set 620 
enhancedForControl -> type .variableDeclaratorId COLON expression
localVariableDeclaration -> type .variableDeclarators
variableDeclaratorId -> .Identifier arrayDimensionBracks
variableDeclarators -> .variableDeclarator
variableDeclarators -> .variableDeclarators COMMA variableDeclarator
variableDeclarator -> .variableDeclaratorId
variableDeclarator -> .variableDeclaratorId ASSIGN variableInitializer 
transitions ->  {"variableDeclaratorId":693,"variableDeclarators":570,"Identifier":516,"variableDeclarator":381}

item set 621 
forInit -> variableDeclaratorsWithPrefixes . 
transitions ->  {}

item set 622 
forInit -> expressionList .
expressionList -> expressionList .COMMA expression 
transitions ->  {"COMMA":347}

item set 623 
variableDeclaratorsWithPrefixes -> annotationl .modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> annotationl .localVariableDeclaration
annotationl -> annotationl .annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
localVariableDeclaration -> .type variableDeclarators
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"modifierL":694,"localVariableDeclaration":567,"annotation":63,"modifier":15,"type":489,"AT":67,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"qualifiedName":137,"primitiveType":138,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 624 
statement -> WHILE LPAREN expression .RPAREN blockStatement
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"RPAREN":695,"DOT":151,"LBRACK":152,"arguments":153,"LPAREN":154,"incrementOrDecrement":155,"mulDivOrMod":156,"addOrSub":157,"LSHIFT":158,"GT":159,"lE_GE_LT_GT":160,"INSTANCEOF":161,"equals_NotEqual":162,"BITAND":163,"CARET":164,"BITOR":165,"AND":166,"OR":167,"QUESTION":168,"assignmentToken":169,"INC":170,"DEC":171,"MUL":172,"DIV":173,"MOD":174,"ADD":175,"SUB":176,"LE":177,"GE":178,"LT":179,"EQUAL":180,"NOTEQUAL":181,"ASSIGN":182,"ADD_ASSIGN":183,"SUB_ASSIGN":184,"MUL_ASSIGN":185,"DIV_ASSIGN":186,"AND_ASSIGN":187,"OR_ASSIGN":188,"XOR_ASSIGN":189,"RSHIFT_ASSIGN":190,"URSHIFT_ASSIGN":191,"LSHIFT_ASSIGN":192,"MOD_ASSIGN":193}

item set 625 
statement -> DO blockStatement WHILE .LPAREN expression RPAREN SEMI 
transitions ->  {"LPAREN":696}

item set 626 
statement -> TRY block catchFinallyOrOnlyFinally . 
transitions ->  {}

item set 627 
catchFinallyOrOnlyFinally -> catchClauses .optionalFinallyBlock
catchClauses -> catchClauses .catchClause
optionalFinallyBlock -> .
optionalFinallyBlock -> .finallyBlock
catchClause -> .CATCH LPAREN variableModifiers catchType Identifier RPAREN block
catchClause -> .CATCH LPAREN catchType Identifier RPAREN block
finallyBlock -> .FINALLY block 
transitions ->  {"optionalFinallyBlock":697,"catchClause":698,"finallyBlock":699,"CATCH":631,"FINALLY":630}

item set 628 
catchFinallyOrOnlyFinally -> finallyBlock . 
transitions ->  {}

item set 629 
catchClauses -> catchClause . 
transitions ->  {}

item set 630 
finallyBlock -> FINALLY .block
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE 
transitions ->  {"block":700,"LBRACE":403}

item set 631 
catchClause -> CATCH .LPAREN variableModifiers catchType Identifier RPAREN block
catchClause -> CATCH .LPAREN catchType Identifier RPAREN block 
transitions ->  {"LPAREN":701}

item set 632 
statement -> TRY resourceSpecification block .catchClauses
statement -> TRY resourceSpecification block .optionalFinallyBlock
statement -> TRY resourceSpecification block .catchClauses optionalFinallyBlock
catchClauses -> .catchClause
catchClauses -> .catchClauses catchClause
optionalFinallyBlock -> .
optionalFinallyBlock -> .finallyBlock
catchClause -> .CATCH LPAREN variableModifiers catchType Identifier RPAREN block
catchClause -> .CATCH LPAREN catchType Identifier RPAREN block
finallyBlock -> .FINALLY block 
transitions ->  {"catchClauses":702,"optionalFinallyBlock":703,"catchClause":629,"finallyBlock":699,"CATCH":631,"FINALLY":630}

item set 633 
resourceSpecification -> LPAREN resources .semiOpt RPAREN
resources -> resources .SEMI resource
semiOpt -> .
semiOpt -> .SEMI 
transitions ->  {"semiOpt":704,"SEMI":705}

item set 634 
resources -> resource . 
transitions ->  {}

item set 635 
resource -> variableModifiers .classOrInterfaceType variableDeclaratorId ASSIGN expression
classOrInterfaceType -> .qualifiedName
classOrInterfaceType -> .qualifiedName typeParameters
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters 
transitions ->  {"classOrInterfaceType":706,"qualifiedName":637,"Identifier":49}

item set 636 
resource -> classOrInterfaceType .variableDeclaratorId ASSIGN expression
variableDeclaratorId -> .Identifier arrayDimensionBracks 
transitions ->  {"variableDeclaratorId":707,"Identifier":516}

item set 637 
classOrInterfaceType -> qualifiedName .
classOrInterfaceType -> qualifiedName .typeParameters
qualifiedName -> qualifiedName .DOT Identifier
qualifiedName -> qualifiedName .DOT Identifier typeParameters
typeParameters -> .TEMPLATE 
transitions ->  {"typeParameters":708,"DOT":69,"TEMPLATE":71}

item set 638 
statement -> SWITCH LPAREN expression .RPAREN LBRACE switchBlockStatementGroups emptySwitchLabels RBRACE
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"RPAREN":709,"DOT":151,"LBRACK":152,"arguments":153,"LPAREN":154,"incrementOrDecrement":155,"mulDivOrMod":156,"addOrSub":157,"LSHIFT":158,"GT":159,"lE_GE_LT_GT":160,"INSTANCEOF":161,"equals_NotEqual":162,"BITAND":163,"CARET":164,"BITOR":165,"AND":166,"OR":167,"QUESTION":168,"assignmentToken":169,"INC":170,"DEC":171,"MUL":172,"DIV":173,"MOD":174,"ADD":175,"SUB":176,"LE":177,"GE":178,"LT":179,"EQUAL":180,"NOTEQUAL":181,"ASSIGN":182,"ADD_ASSIGN":183,"SUB_ASSIGN":184,"MUL_ASSIGN":185,"DIV_ASSIGN":186,"AND_ASSIGN":187,"OR_ASSIGN":188,"XOR_ASSIGN":189,"RSHIFT_ASSIGN":190,"URSHIFT_ASSIGN":191,"LSHIFT_ASSIGN":192,"MOD_ASSIGN":193}

item set 639 
statement -> SYNCHRONIZED LPAREN expression .RPAREN block
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"RPAREN":710,"DOT":151,"LBRACK":152,"arguments":153,"LPAREN":154,"incrementOrDecrement":155,"mulDivOrMod":156,"addOrSub":157,"LSHIFT":158,"GT":159,"lE_GE_LT_GT":160,"INSTANCEOF":161,"equals_NotEqual":162,"BITAND":163,"CARET":164,"BITOR":165,"AND":166,"OR":167,"QUESTION":168,"assignmentToken":169,"INC":170,"DEC":171,"MUL":172,"DIV":173,"MOD":174,"ADD":175,"SUB":176,"LE":177,"GE":178,"LT":179,"EQUAL":180,"NOTEQUAL":181,"ASSIGN":182,"ADD_ASSIGN":183,"SUB_ASSIGN":184,"MUL_ASSIGN":185,"DIV_ASSIGN":186,"AND_ASSIGN":187,"OR_ASSIGN":188,"XOR_ASSIGN":189,"RSHIFT_ASSIGN":190,"URSHIFT_ASSIGN":191,"LSHIFT_ASSIGN":192,"MOD_ASSIGN":193}

item set 640 
statement -> RETURN expression SEMI . 
transitions ->  {}

item set 641 
statement -> THROW expression SEMI . 
transitions ->  {}

item set 642 
statement -> BREAK optionalIdentifier SEMI . 
transitions ->  {}

item set 643 
statement -> CONTINUE optionalIdentifier SEMI . 
transitions ->  {}

item set 644 
statement -> Identifier COLON blockStatement . 
transitions ->  {}

item set 645 
variableDeclaratorsWithPrefixes -> annotationl modifierL localVariableDeclaration . 
transitions ->  {}

item set 646 
variableDeclaratorsWithPrefixes -> modifierL annotationl localVariableDeclaration . 
transitions ->  {}

item set 647 
interfaceMemberDeclaration -> type Identifier formalParameters arrayDimensionBracks throwsList .commentReturn SEMI
commentReturn -> . 
transitions ->  {"commentReturn":711}

item set 648 
interfaceMemberDeclaration -> type Identifier formalParameters arrayDimensionBracks commentReturn .SEMI 
transitions ->  {"SEMI":712}

item set 649 
interfaceMemberDeclaration -> type Identifier formalParameters commentReturn SEMI . 
transitions ->  {}

item set 650 
constantDeclarator -> Identifier arrayDimensionBrackl ASSIGN variableInitializer . 
transitions ->  {}

item set 651 
interfaceMemberDeclaration -> VOID Identifier formalParameters arrayDimensionBracks throwsList .commentReturn SEMI
commentReturn -> . 
transitions ->  {"commentReturn":713}

item set 652 
interfaceMemberDeclaration -> VOID Identifier formalParameters arrayDimensionBracks commentReturn .SEMI 
transitions ->  {"SEMI":714}

item set 653 
interfaceMemberDeclaration -> VOID Identifier formalParameters commentReturn SEMI . 
transitions ->  {}

item set 654 
interfaceMemberDeclaration -> typeParameters VOID Identifier formalParameters arrayDimensionBracks .throwsList commentReturn SEMI
interfaceMemberDeclaration -> typeParameters VOID Identifier formalParameters arrayDimensionBracks .commentReturn SEMI
throwsList -> .
throwsList -> .THROWS qualifiedNameList
commentReturn -> . 
transitions ->  {"throwsList":715,"commentReturn":716,"THROWS":531}

item set 655 
interfaceMemberDeclaration -> typeParameters VOID Identifier formalParameters commentReturn .SEMI 
transitions ->  {"SEMI":717}

item set 656 
interfaceMemberDeclaration -> typeParameters type Identifier formalParameters arrayDimensionBracks .throwsList commentReturn SEMI
interfaceMemberDeclaration -> typeParameters type Identifier formalParameters arrayDimensionBracks .commentReturn SEMI
throwsList -> .
throwsList -> .THROWS qualifiedNameList
commentReturn -> . 
transitions ->  {"throwsList":718,"commentReturn":719,"THROWS":531}

item set 657 
interfaceMemberDeclaration -> typeParameters type Identifier formalParameters commentReturn .SEMI 
transitions ->  {"SEMI":720}

item set 658 
enumConstants -> enumConstants COMMA annotations Identifier enumConstantArguments .commentReturn enumConstantClassBody
commentReturn -> . 
transitions ->  {"commentReturn":721}

item set 659 
enumConstants -> annotations Identifier enumConstantArguments commentReturn enumConstantClassBody . 
transitions ->  {}

item set 660 
enumConstantClassBody -> classBody . 
transitions ->  {}

item set 661 
arrayInitializer -> LBRACE variableInitializerL SEMI .RBRACE 
transitions ->  {"RBRACE":722}

item set 662 
arrayInitializer -> LBRACE variableInitializerL RBRACE . 
transitions ->  {}

item set 663 
arrayInitializer -> LBRACE variableInitializerL COMMA .RBRACE
variableInitializerL -> variableInitializerL COMMA .variableInitializer
variableInitializer -> .arrayInitializer
variableInitializer -> .expression
arrayInitializer -> .LBRACE RBRACE
arrayInitializer -> .LBRACE variableInitializerL SEMI RBRACE
arrayInitializer -> .LBRACE variableInitializerL RBRACE
arrayInitializer -> .LBRACE variableInitializerL COMMA RBRACE
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"RBRACE":723,"variableInitializer":724,"arrayInitializer":519,"expression":520,"LBRACE":510,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 664 
defaultValue -> DEFAULT elementValue . 
transitions ->  {}

item set 665 
classMemberDeclaration -> VOID Identifier formalParameters arrayDimensionBracks throwsList .commentReturn block
classMemberDeclaration -> VOID Identifier formalParameters arrayDimensionBracks throwsList .commentReturn SEMI
commentReturn -> . 
transitions ->  {"commentReturn":725}

item set 666 
classMemberDeclaration -> VOID Identifier formalParameters arrayDimensionBracks commentReturn .block
classMemberDeclaration -> VOID Identifier formalParameters arrayDimensionBracks commentReturn .SEMI
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE 
transitions ->  {"block":726,"SEMI":727,"LBRACE":403}

item set 667 
classMemberDeclaration -> VOID Identifier formalParameters commentReturn block . 
transitions ->  {}

item set 668 
classMemberDeclaration -> VOID Identifier formalParameters commentReturn SEMI . 
transitions ->  {}

item set 669 
classMemberDeclaration -> type Identifier formalParameters arrayDimensionBracks throwsList .commentReturn block
classMemberDeclaration -> type Identifier formalParameters arrayDimensionBracks throwsList .commentReturn SEMI
commentReturn -> . 
transitions ->  {"commentReturn":728}

item set 670 
classMemberDeclaration -> type Identifier formalParameters arrayDimensionBracks commentReturn .block
classMemberDeclaration -> type Identifier formalParameters arrayDimensionBracks commentReturn .SEMI
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE 
transitions ->  {"block":729,"SEMI":730,"LBRACE":403}

item set 671 
classMemberDeclaration -> type Identifier formalParameters commentReturn block . 
transitions ->  {}

item set 672 
classMemberDeclaration -> type Identifier formalParameters commentReturn SEMI . 
transitions ->  {}

item set 673 
classMemberDeclaration -> typeParameters VOID Identifier formalParameters arrayDimensionBracks .throwsList commentReturn block
classMemberDeclaration -> typeParameters VOID Identifier formalParameters arrayDimensionBracks .commentReturn block
classMemberDeclaration -> typeParameters VOID Identifier formalParameters arrayDimensionBracks .throwsList commentReturn SEMI
classMemberDeclaration -> typeParameters VOID Identifier formalParameters arrayDimensionBracks .commentReturn SEMI
throwsList -> .
throwsList -> .THROWS qualifiedNameList
commentReturn -> . 
transitions ->  {"throwsList":731,"commentReturn":732,"THROWS":531}

item set 674 
classMemberDeclaration -> typeParameters VOID Identifier formalParameters commentReturn .block
classMemberDeclaration -> typeParameters VOID Identifier formalParameters commentReturn .SEMI
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE 
transitions ->  {"block":733,"SEMI":734,"LBRACE":403}

item set 675 
classMemberDeclaration -> typeParameters type Identifier formalParameters arrayDimensionBracks .throwsList commentReturn block
classMemberDeclaration -> typeParameters type Identifier formalParameters arrayDimensionBracks .commentReturn block
classMemberDeclaration -> typeParameters type Identifier formalParameters arrayDimensionBracks .throwsList commentReturn SEMI
classMemberDeclaration -> typeParameters type Identifier formalParameters arrayDimensionBracks .commentReturn SEMI
throwsList -> .
throwsList -> .THROWS qualifiedNameList
commentReturn -> . 
transitions ->  {"throwsList":735,"commentReturn":736,"THROWS":531}

item set 676 
classMemberDeclaration -> typeParameters type Identifier formalParameters commentReturn .block
classMemberDeclaration -> typeParameters type Identifier formalParameters commentReturn .SEMI
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE 
transitions ->  {"block":737,"SEMI":738,"LBRACE":403}

item set 677 
classMemberDeclaration -> typeParameters Identifier formalParameters throwsList commentReturn .block
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE 
transitions ->  {"block":739,"LBRACE":403}

item set 678 
classMemberDeclaration -> Identifier formalParameters throwsList commentReturn block . 
transitions ->  {}

item set 679 
qualifiedNameList -> qualifiedNameList COMMA .qualifiedName
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters 
transitions ->  {"qualifiedName":740,"Identifier":49}

item set 680 
formalParameterList -> usualParameterList COMMA lastFormalParameter . 
transitions ->  {}

item set 681 
usualParameterList -> usualParameterList COMMA usualParameter . 
transitions ->  {}

item set 682 
lastFormalParameter -> variableModifiers type ELLIPSIS .variableDeclaratorId
variableDeclaratorId -> .Identifier arrayDimensionBracks 
transitions ->  {"variableDeclaratorId":741,"Identifier":516}

item set 683 
usualParameter -> variableModifiers type variableDeclaratorId . 
transitions ->  {}

item set 684 
lastFormalParameter -> type ELLIPSIS variableDeclaratorId . 
transitions ->  {}

item set 685 
assertExpression -> expression COLON expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":151,"LBRACK":152,"arguments":153,"LPAREN":154,"incrementOrDecrement":155,"mulDivOrMod":156,"addOrSub":157,"LSHIFT":158,"GT":159,"lE_GE_LT_GT":160,"INSTANCEOF":161,"equals_NotEqual":162,"BITAND":163,"CARET":164,"BITOR":165,"AND":166,"OR":167,"QUESTION":168,"assignmentToken":169,"INC":170,"DEC":171,"MUL":172,"DIV":173,"MOD":174,"ADD":175,"SUB":176,"LE":177,"GE":178,"LT":179,"EQUAL":180,"NOTEQUAL":181,"ASSIGN":182,"ADD_ASSIGN":183,"SUB_ASSIGN":184,"MUL_ASSIGN":185,"DIV_ASSIGN":186,"AND_ASSIGN":187,"OR_ASSIGN":188,"XOR_ASSIGN":189,"RSHIFT_ASSIGN":190,"URSHIFT_ASSIGN":191,"LSHIFT_ASSIGN":192,"MOD_ASSIGN":193}

item set 686 
statement -> IF LPAREN expression RPAREN .blockStatement optionalElseStatement
blockStatement -> .statement
blockStatement -> .LBRACE RBRACE
blockStatement -> .LBRACE blockStatementList RBRACE
statement -> .ASSERT assertExpression SEMI
statement -> .IF LPAREN expression RPAREN blockStatement optionalElseStatement
statement -> .FOR LPAREN forControl RPAREN blockStatement
statement -> .WHILE LPAREN expression RPAREN blockStatement
statement -> .DO blockStatement WHILE LPAREN expression RPAREN SEMI
statement -> .TRY block catchFinallyOrOnlyFinally
statement -> .TRY resourceSpecification block catchClauses
statement -> .TRY resourceSpecification block optionalFinallyBlock
statement -> .TRY resourceSpecification block catchClauses optionalFinallyBlock
statement -> .SWITCH LPAREN expression RPAREN LBRACE switchBlockStatementGroups emptySwitchLabels RBRACE
statement -> .SYNCHRONIZED LPAREN expression RPAREN block
statement -> .RETURN SEMI
statement -> .RETURN expression SEMI
statement -> .THROW expression SEMI
statement -> .BREAK optionalIdentifier SEMI
statement -> .CONTINUE optionalIdentifier SEMI
statement -> .Identifier COLON blockStatement
statement -> .expression SEMI
statement -> .typeDeclarationWithPrefixes
statement -> .variableDeclaratorsWithPrefixes
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
typeDeclarationWithPrefixes -> .annotationl modifierL typeDeclaration
typeDeclarationWithPrefixes -> .modifierL annotationl typeDeclaration
typeDeclarationWithPrefixes -> .modifierL typeDeclaration
typeDeclarationWithPrefixes -> .annotationl typeDeclaration
typeDeclarationWithPrefixes -> .typeDeclaration
variableDeclaratorsWithPrefixes -> .annotationl modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .localVariableDeclaration
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
localVariableDeclaration -> .type variableDeclarators
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks 
transitions ->  {"blockStatement":742,"statement":466,"LBRACE":467,"ASSERT":468,"IF":469,"FOR":470,"WHILE":471,"DO":472,"TRY":473,"SWITCH":474,"SYNCHRONIZED":475,"RETURN":476,"THROW":477,"BREAK":478,"CONTINUE":479,"Identifier":480,"expression":481,"typeDeclarationWithPrefixes":482,"variableDeclaratorsWithPrefixes":483,"parExpression":98,"qualifiedName":484,"primitiveType":485,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"annotationl":486,"modifierL":487,"typeDeclaration":13,"localVariableDeclaration":488,"LPAREN":115,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131,"annotation":10,"modifier":15,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"type":489,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 687 
statement -> FOR LPAREN forControl RPAREN .blockStatement
blockStatement -> .statement
blockStatement -> .LBRACE RBRACE
blockStatement -> .LBRACE blockStatementList RBRACE
statement -> .ASSERT assertExpression SEMI
statement -> .IF LPAREN expression RPAREN blockStatement optionalElseStatement
statement -> .FOR LPAREN forControl RPAREN blockStatement
statement -> .WHILE LPAREN expression RPAREN blockStatement
statement -> .DO blockStatement WHILE LPAREN expression RPAREN SEMI
statement -> .TRY block catchFinallyOrOnlyFinally
statement -> .TRY resourceSpecification block catchClauses
statement -> .TRY resourceSpecification block optionalFinallyBlock
statement -> .TRY resourceSpecification block catchClauses optionalFinallyBlock
statement -> .SWITCH LPAREN expression RPAREN LBRACE switchBlockStatementGroups emptySwitchLabels RBRACE
statement -> .SYNCHRONIZED LPAREN expression RPAREN block
statement -> .RETURN SEMI
statement -> .RETURN expression SEMI
statement -> .THROW expression SEMI
statement -> .BREAK optionalIdentifier SEMI
statement -> .CONTINUE optionalIdentifier SEMI
statement -> .Identifier COLON blockStatement
statement -> .expression SEMI
statement -> .typeDeclarationWithPrefixes
statement -> .variableDeclaratorsWithPrefixes
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
typeDeclarationWithPrefixes -> .annotationl modifierL typeDeclaration
typeDeclarationWithPrefixes -> .modifierL annotationl typeDeclaration
typeDeclarationWithPrefixes -> .modifierL typeDeclaration
typeDeclarationWithPrefixes -> .annotationl typeDeclaration
typeDeclarationWithPrefixes -> .typeDeclaration
variableDeclaratorsWithPrefixes -> .annotationl modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .localVariableDeclaration
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
localVariableDeclaration -> .type variableDeclarators
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks 
transitions ->  {"blockStatement":743,"statement":466,"LBRACE":467,"ASSERT":468,"IF":469,"FOR":470,"WHILE":471,"DO":472,"TRY":473,"SWITCH":474,"SYNCHRONIZED":475,"RETURN":476,"THROW":477,"BREAK":478,"CONTINUE":479,"Identifier":480,"expression":481,"typeDeclarationWithPrefixes":482,"variableDeclaratorsWithPrefixes":483,"parExpression":98,"qualifiedName":484,"primitiveType":485,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"annotationl":486,"modifierL":487,"typeDeclaration":13,"localVariableDeclaration":488,"LPAREN":115,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131,"annotation":10,"modifier":15,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"type":489,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 688 
forControl -> forInit SEMI .optionalExpression SEMI optionalForUpdate
optionalExpression -> .
optionalExpression -> .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"optionalExpression":744,"expression":690,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 689 
forControl -> SEMI optionalExpression .SEMI optionalForUpdate 
transitions ->  {"SEMI":745}

item set 690 
optionalExpression -> expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":151,"LBRACK":152,"arguments":153,"LPAREN":154,"incrementOrDecrement":155,"mulDivOrMod":156,"addOrSub":157,"LSHIFT":158,"GT":159,"lE_GE_LT_GT":160,"INSTANCEOF":161,"equals_NotEqual":162,"BITAND":163,"CARET":164,"BITOR":165,"AND":166,"OR":167,"QUESTION":168,"assignmentToken":169,"INC":170,"DEC":171,"MUL":172,"DIV":173,"MOD":174,"ADD":175,"SUB":176,"LE":177,"GE":178,"LT":179,"EQUAL":180,"NOTEQUAL":181,"ASSIGN":182,"ADD_ASSIGN":183,"SUB_ASSIGN":184,"MUL_ASSIGN":185,"DIV_ASSIGN":186,"AND_ASSIGN":187,"OR_ASSIGN":188,"XOR_ASSIGN":189,"RSHIFT_ASSIGN":190,"URSHIFT_ASSIGN":191,"LSHIFT_ASSIGN":192,"MOD_ASSIGN":193}

item set 691 
enhancedForControl -> modifierL type .variableDeclaratorId COLON expression
localVariableDeclaration -> type .variableDeclarators
variableDeclaratorId -> .Identifier arrayDimensionBracks
variableDeclarators -> .variableDeclarator
variableDeclarators -> .variableDeclarators COMMA variableDeclarator
variableDeclarator -> .variableDeclaratorId
variableDeclarator -> .variableDeclaratorId ASSIGN variableInitializer 
transitions ->  {"variableDeclaratorId":746,"variableDeclarators":570,"Identifier":516,"variableDeclarator":381}

item set 692 
variableDeclaratorsWithPrefixes -> modifierL annotationl .localVariableDeclaration
annotationl -> annotationl .annotation
localVariableDeclaration -> .type variableDeclarators
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"localVariableDeclaration":646,"annotation":63,"type":489,"AT":67,"qualifiedName":137,"primitiveType":138,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 693 
enhancedForControl -> type variableDeclaratorId .COLON expression
variableDeclarator -> variableDeclaratorId .
variableDeclarator -> variableDeclaratorId .ASSIGN variableInitializer 
transitions ->  {"COLON":747,"ASSIGN":445}

item set 694 
variableDeclaratorsWithPrefixes -> annotationl modifierL .localVariableDeclaration
modifierL -> modifierL .modifier
localVariableDeclaration -> .type variableDeclarators
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE 
transitions ->  {"localVariableDeclaration":645,"modifier":54,"type":489,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"SYNCHRONIZED":30,"qualifiedName":137,"primitiveType":138,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123}

item set 695 
statement -> WHILE LPAREN expression RPAREN .blockStatement
blockStatement -> .statement
blockStatement -> .LBRACE RBRACE
blockStatement -> .LBRACE blockStatementList RBRACE
statement -> .ASSERT assertExpression SEMI
statement -> .IF LPAREN expression RPAREN blockStatement optionalElseStatement
statement -> .FOR LPAREN forControl RPAREN blockStatement
statement -> .WHILE LPAREN expression RPAREN blockStatement
statement -> .DO blockStatement WHILE LPAREN expression RPAREN SEMI
statement -> .TRY block catchFinallyOrOnlyFinally
statement -> .TRY resourceSpecification block catchClauses
statement -> .TRY resourceSpecification block optionalFinallyBlock
statement -> .TRY resourceSpecification block catchClauses optionalFinallyBlock
statement -> .SWITCH LPAREN expression RPAREN LBRACE switchBlockStatementGroups emptySwitchLabels RBRACE
statement -> .SYNCHRONIZED LPAREN expression RPAREN block
statement -> .RETURN SEMI
statement -> .RETURN expression SEMI
statement -> .THROW expression SEMI
statement -> .BREAK optionalIdentifier SEMI
statement -> .CONTINUE optionalIdentifier SEMI
statement -> .Identifier COLON blockStatement
statement -> .expression SEMI
statement -> .typeDeclarationWithPrefixes
statement -> .variableDeclaratorsWithPrefixes
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
typeDeclarationWithPrefixes -> .annotationl modifierL typeDeclaration
typeDeclarationWithPrefixes -> .modifierL annotationl typeDeclaration
typeDeclarationWithPrefixes -> .modifierL typeDeclaration
typeDeclarationWithPrefixes -> .annotationl typeDeclaration
typeDeclarationWithPrefixes -> .typeDeclaration
variableDeclaratorsWithPrefixes -> .annotationl modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .localVariableDeclaration
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
localVariableDeclaration -> .type variableDeclarators
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks 
transitions ->  {"blockStatement":748,"statement":466,"LBRACE":467,"ASSERT":468,"IF":469,"FOR":470,"WHILE":471,"DO":472,"TRY":473,"SWITCH":474,"SYNCHRONIZED":475,"RETURN":476,"THROW":477,"BREAK":478,"CONTINUE":479,"Identifier":480,"expression":481,"typeDeclarationWithPrefixes":482,"variableDeclaratorsWithPrefixes":483,"parExpression":98,"qualifiedName":484,"primitiveType":485,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"annotationl":486,"modifierL":487,"typeDeclaration":13,"localVariableDeclaration":488,"LPAREN":115,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131,"annotation":10,"modifier":15,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"type":489,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 696 
statement -> DO blockStatement WHILE LPAREN .expression RPAREN SEMI
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":749,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 697 
catchFinallyOrOnlyFinally -> catchClauses optionalFinallyBlock . 
transitions ->  {}

item set 698 
catchClauses -> catchClauses catchClause . 
transitions ->  {}

item set 699 
optionalFinallyBlock -> finallyBlock . 
transitions ->  {}

item set 700 
finallyBlock -> FINALLY block . 
transitions ->  {}

item set 701 
catchClause -> CATCH LPAREN .variableModifiers catchType Identifier RPAREN block
catchClause -> CATCH LPAREN .catchType Identifier RPAREN block
variableModifiers -> .FINAL annotationl
variableModifiers -> .annotationl
variableModifiers -> .FINAL
variableModifiers -> .annotationl FINAL
catchType -> .qualifiedName
catchType -> .catchType BITOR qualifiedName
annotationl -> .annotation
annotationl -> .annotationl annotation
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN 
transitions ->  {"variableModifiers":750,"catchType":751,"FINAL":539,"annotationl":540,"qualifiedName":752,"annotation":10,"Identifier":49,"AT":67}

item set 702 
statement -> TRY resourceSpecification block catchClauses .
statement -> TRY resourceSpecification block catchClauses .optionalFinallyBlock
catchClauses -> catchClauses .catchClause
optionalFinallyBlock -> .
optionalFinallyBlock -> .finallyBlock
catchClause -> .CATCH LPAREN variableModifiers catchType Identifier RPAREN block
catchClause -> .CATCH LPAREN catchType Identifier RPAREN block
finallyBlock -> .FINALLY block 
transitions ->  {"optionalFinallyBlock":753,"catchClause":698,"finallyBlock":699,"CATCH":631,"FINALLY":630}

item set 703 
statement -> TRY resourceSpecification block optionalFinallyBlock . 
transitions ->  {}

item set 704 
resourceSpecification -> LPAREN resources semiOpt .RPAREN 
transitions ->  {"RPAREN":754}

item set 705 
resources -> resources SEMI .resource
semiOpt -> SEMI .
resource -> .variableModifiers classOrInterfaceType variableDeclaratorId ASSIGN expression
resource -> .classOrInterfaceType variableDeclaratorId ASSIGN expression
variableModifiers -> .FINAL annotationl
variableModifiers -> .annotationl
variableModifiers -> .FINAL
variableModifiers -> .annotationl FINAL
classOrInterfaceType -> .qualifiedName
classOrInterfaceType -> .qualifiedName typeParameters
annotationl -> .annotation
annotationl -> .annotationl annotation
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN 
transitions ->  {"resource":755,"variableModifiers":635,"classOrInterfaceType":636,"FINAL":539,"annotationl":540,"qualifiedName":637,"annotation":10,"Identifier":49,"AT":67}

item set 706 
resource -> variableModifiers classOrInterfaceType .variableDeclaratorId ASSIGN expression
variableDeclaratorId -> .Identifier arrayDimensionBracks 
transitions ->  {"variableDeclaratorId":756,"Identifier":516}

item set 707 
resource -> classOrInterfaceType variableDeclaratorId .ASSIGN expression 
transitions ->  {"ASSIGN":757}

item set 708 
classOrInterfaceType -> qualifiedName typeParameters . 
transitions ->  {}

item set 709 
statement -> SWITCH LPAREN expression RPAREN .LBRACE switchBlockStatementGroups emptySwitchLabels RBRACE 
transitions ->  {"LBRACE":758}

item set 710 
statement -> SYNCHRONIZED LPAREN expression RPAREN .block
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE 
transitions ->  {"block":759,"LBRACE":403}

item set 711 
interfaceMemberDeclaration -> type Identifier formalParameters arrayDimensionBracks throwsList commentReturn .SEMI 
transitions ->  {"SEMI":760}

item set 712 
interfaceMemberDeclaration -> type Identifier formalParameters arrayDimensionBracks commentReturn SEMI . 
transitions ->  {}

item set 713 
interfaceMemberDeclaration -> VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn .SEMI 
transitions ->  {"SEMI":761}

item set 714 
interfaceMemberDeclaration -> VOID Identifier formalParameters arrayDimensionBracks commentReturn SEMI . 
transitions ->  {}

item set 715 
interfaceMemberDeclaration -> typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList .commentReturn SEMI
commentReturn -> . 
transitions ->  {"commentReturn":762}

item set 716 
interfaceMemberDeclaration -> typeParameters VOID Identifier formalParameters arrayDimensionBracks commentReturn .SEMI 
transitions ->  {"SEMI":763}

item set 717 
interfaceMemberDeclaration -> typeParameters VOID Identifier formalParameters commentReturn SEMI . 
transitions ->  {}

item set 718 
interfaceMemberDeclaration -> typeParameters type Identifier formalParameters arrayDimensionBracks throwsList .commentReturn SEMI
commentReturn -> . 
transitions ->  {"commentReturn":764}

item set 719 
interfaceMemberDeclaration -> typeParameters type Identifier formalParameters arrayDimensionBracks commentReturn .SEMI 
transitions ->  {"SEMI":765}

item set 720 
interfaceMemberDeclaration -> typeParameters type Identifier formalParameters commentReturn SEMI . 
transitions ->  {}

item set 721 
enumConstants -> enumConstants COMMA annotations Identifier enumConstantArguments commentReturn .enumConstantClassBody
enumConstantClassBody -> .
enumConstantClassBody -> .classBody
classBody -> .LBRACE RBRACE
classBody -> .LBRACE classBodyDeclarationl RBRACE 
transitions ->  {"enumConstantClassBody":766,"classBody":660,"LBRACE":317}

item set 722 
arrayInitializer -> LBRACE variableInitializerL SEMI RBRACE . 
transitions ->  {}

item set 723 
arrayInitializer -> LBRACE variableInitializerL COMMA RBRACE . 
transitions ->  {}

item set 724 
variableInitializerL -> variableInitializerL COMMA variableInitializer . 
transitions ->  {}

item set 725 
classMemberDeclaration -> VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn .block
classMemberDeclaration -> VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn .SEMI
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE 
transitions ->  {"block":767,"SEMI":768,"LBRACE":403}

item set 726 
classMemberDeclaration -> VOID Identifier formalParameters arrayDimensionBracks commentReturn block . 
transitions ->  {}

item set 727 
classMemberDeclaration -> VOID Identifier formalParameters arrayDimensionBracks commentReturn SEMI . 
transitions ->  {}

item set 728 
classMemberDeclaration -> type Identifier formalParameters arrayDimensionBracks throwsList commentReturn .block
classMemberDeclaration -> type Identifier formalParameters arrayDimensionBracks throwsList commentReturn .SEMI
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE 
transitions ->  {"block":769,"SEMI":770,"LBRACE":403}

item set 729 
classMemberDeclaration -> type Identifier formalParameters arrayDimensionBracks commentReturn block . 
transitions ->  {}

item set 730 
classMemberDeclaration -> type Identifier formalParameters arrayDimensionBracks commentReturn SEMI . 
transitions ->  {}

item set 731 
classMemberDeclaration -> typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList .commentReturn block
classMemberDeclaration -> typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList .commentReturn SEMI
commentReturn -> . 
transitions ->  {"commentReturn":771}

item set 732 
classMemberDeclaration -> typeParameters VOID Identifier formalParameters arrayDimensionBracks commentReturn .block
classMemberDeclaration -> typeParameters VOID Identifier formalParameters arrayDimensionBracks commentReturn .SEMI
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE 
transitions ->  {"block":772,"SEMI":773,"LBRACE":403}

item set 733 
classMemberDeclaration -> typeParameters VOID Identifier formalParameters commentReturn block . 
transitions ->  {}

item set 734 
classMemberDeclaration -> typeParameters VOID Identifier formalParameters commentReturn SEMI . 
transitions ->  {}

item set 735 
classMemberDeclaration -> typeParameters type Identifier formalParameters arrayDimensionBracks throwsList .commentReturn block
classMemberDeclaration -> typeParameters type Identifier formalParameters arrayDimensionBracks throwsList .commentReturn SEMI
commentReturn -> . 
transitions ->  {"commentReturn":774}

item set 736 
classMemberDeclaration -> typeParameters type Identifier formalParameters arrayDimensionBracks commentReturn .block
classMemberDeclaration -> typeParameters type Identifier formalParameters arrayDimensionBracks commentReturn .SEMI
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE 
transitions ->  {"block":775,"SEMI":776,"LBRACE":403}

item set 737 
classMemberDeclaration -> typeParameters type Identifier formalParameters commentReturn block . 
transitions ->  {}

item set 738 
classMemberDeclaration -> typeParameters type Identifier formalParameters commentReturn SEMI . 
transitions ->  {}

item set 739 
classMemberDeclaration -> typeParameters Identifier formalParameters throwsList commentReturn block . 
transitions ->  {}

item set 740 
qualifiedNameList -> qualifiedNameList COMMA qualifiedName .
qualifiedName -> qualifiedName .DOT Identifier
qualifiedName -> qualifiedName .DOT Identifier typeParameters 
transitions ->  {"DOT":69}

item set 741 
lastFormalParameter -> variableModifiers type ELLIPSIS variableDeclaratorId . 
transitions ->  {}

item set 742 
statement -> IF LPAREN expression RPAREN blockStatement .optionalElseStatement
optionalElseStatement -> .
optionalElseStatement -> .ELSE blockStatement 
transitions ->  {"optionalElseStatement":777,"ELSE":778}

item set 743 
statement -> FOR LPAREN forControl RPAREN blockStatement . 
transitions ->  {}

item set 744 
forControl -> forInit SEMI optionalExpression .SEMI optionalForUpdate 
transitions ->  {"SEMI":779}

item set 745 
forControl -> SEMI optionalExpression SEMI .optionalForUpdate
optionalForUpdate -> .
optionalForUpdate -> .forUpdate
forUpdate -> .expressionList
expressionList -> .expression
expressionList -> .expressionList COMMA expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"optionalForUpdate":780,"forUpdate":781,"expressionList":782,"expression":248,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 746 
enhancedForControl -> modifierL type variableDeclaratorId .COLON expression
variableDeclarator -> variableDeclaratorId .
variableDeclarator -> variableDeclaratorId .ASSIGN variableInitializer 
transitions ->  {"COLON":783,"ASSIGN":445}

item set 747 
enhancedForControl -> type variableDeclaratorId COLON .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":784,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 748 
statement -> WHILE LPAREN expression RPAREN blockStatement . 
transitions ->  {}

item set 749 
statement -> DO blockStatement WHILE LPAREN expression .RPAREN SEMI
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"RPAREN":785,"DOT":151,"LBRACK":152,"arguments":153,"LPAREN":154,"incrementOrDecrement":155,"mulDivOrMod":156,"addOrSub":157,"LSHIFT":158,"GT":159,"lE_GE_LT_GT":160,"INSTANCEOF":161,"equals_NotEqual":162,"BITAND":163,"CARET":164,"BITOR":165,"AND":166,"OR":167,"QUESTION":168,"assignmentToken":169,"INC":170,"DEC":171,"MUL":172,"DIV":173,"MOD":174,"ADD":175,"SUB":176,"LE":177,"GE":178,"LT":179,"EQUAL":180,"NOTEQUAL":181,"ASSIGN":182,"ADD_ASSIGN":183,"SUB_ASSIGN":184,"MUL_ASSIGN":185,"DIV_ASSIGN":186,"AND_ASSIGN":187,"OR_ASSIGN":188,"XOR_ASSIGN":189,"RSHIFT_ASSIGN":190,"URSHIFT_ASSIGN":191,"LSHIFT_ASSIGN":192,"MOD_ASSIGN":193}

item set 750 
catchClause -> CATCH LPAREN variableModifiers .catchType Identifier RPAREN block
catchType -> .qualifiedName
catchType -> .catchType BITOR qualifiedName
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters 
transitions ->  {"catchType":786,"qualifiedName":752,"Identifier":49}

item set 751 
catchClause -> CATCH LPAREN catchType .Identifier RPAREN block
catchType -> catchType .BITOR qualifiedName 
transitions ->  {"Identifier":787,"BITOR":788}

item set 752 
catchType -> qualifiedName .
qualifiedName -> qualifiedName .DOT Identifier
qualifiedName -> qualifiedName .DOT Identifier typeParameters 
transitions ->  {"DOT":69}

item set 753 
statement -> TRY resourceSpecification block catchClauses optionalFinallyBlock . 
transitions ->  {}

item set 754 
resourceSpecification -> LPAREN resources semiOpt RPAREN . 
transitions ->  {}

item set 755 
resources -> resources SEMI resource . 
transitions ->  {}

item set 756 
resource -> variableModifiers classOrInterfaceType variableDeclaratorId .ASSIGN expression 
transitions ->  {"ASSIGN":789}

item set 757 
resource -> classOrInterfaceType variableDeclaratorId ASSIGN .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":790,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 758 
statement -> SWITCH LPAREN expression RPAREN LBRACE .switchBlockStatementGroups emptySwitchLabels RBRACE
switchBlockStatementGroups -> .
switchBlockStatementGroups -> .switchBlockStatementGroupL
switchBlockStatementGroupL -> .switchBlockStatementGroup
switchBlockStatementGroupL -> .switchBlockStatementGroupL switchBlockStatementGroup
switchBlockStatementGroup -> .switchLabelL blockStatementList
switchBlockStatementGroup -> .switchLabelL
switchLabelL -> .switchLabel
switchLabelL -> .switchLabelL switchLabel
switchLabel -> .CASE expression COLON
switchLabel -> .DEFAULT COLON 
transitions ->  {"switchBlockStatementGroups":791,"switchBlockStatementGroupL":792,"switchBlockStatementGroup":793,"switchLabelL":794,"switchLabel":795,"CASE":796,"DEFAULT":797}

item set 759 
statement -> SYNCHRONIZED LPAREN expression RPAREN block . 
transitions ->  {}

item set 760 
interfaceMemberDeclaration -> type Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI . 
transitions ->  {}

item set 761 
interfaceMemberDeclaration -> VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI . 
transitions ->  {}

item set 762 
interfaceMemberDeclaration -> typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn .SEMI 
transitions ->  {"SEMI":798}

item set 763 
interfaceMemberDeclaration -> typeParameters VOID Identifier formalParameters arrayDimensionBracks commentReturn SEMI . 
transitions ->  {}

item set 764 
interfaceMemberDeclaration -> typeParameters type Identifier formalParameters arrayDimensionBracks throwsList commentReturn .SEMI 
transitions ->  {"SEMI":799}

item set 765 
interfaceMemberDeclaration -> typeParameters type Identifier formalParameters arrayDimensionBracks commentReturn SEMI . 
transitions ->  {}

item set 766 
enumConstants -> enumConstants COMMA annotations Identifier enumConstantArguments commentReturn enumConstantClassBody . 
transitions ->  {}

item set 767 
classMemberDeclaration -> VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn block . 
transitions ->  {}

item set 768 
classMemberDeclaration -> VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI . 
transitions ->  {}

item set 769 
classMemberDeclaration -> type Identifier formalParameters arrayDimensionBracks throwsList commentReturn block . 
transitions ->  {}

item set 770 
classMemberDeclaration -> type Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI . 
transitions ->  {}

item set 771 
classMemberDeclaration -> typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn .block
classMemberDeclaration -> typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn .SEMI
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE 
transitions ->  {"block":800,"SEMI":801,"LBRACE":403}

item set 772 
classMemberDeclaration -> typeParameters VOID Identifier formalParameters arrayDimensionBracks commentReturn block . 
transitions ->  {}

item set 773 
classMemberDeclaration -> typeParameters VOID Identifier formalParameters arrayDimensionBracks commentReturn SEMI . 
transitions ->  {}

item set 774 
classMemberDeclaration -> typeParameters type Identifier formalParameters arrayDimensionBracks throwsList commentReturn .block
classMemberDeclaration -> typeParameters type Identifier formalParameters arrayDimensionBracks throwsList commentReturn .SEMI
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE 
transitions ->  {"block":802,"SEMI":803,"LBRACE":403}

item set 775 
classMemberDeclaration -> typeParameters type Identifier formalParameters arrayDimensionBracks commentReturn block . 
transitions ->  {}

item set 776 
classMemberDeclaration -> typeParameters type Identifier formalParameters arrayDimensionBracks commentReturn SEMI . 
transitions ->  {}

item set 777 
statement -> IF LPAREN expression RPAREN blockStatement optionalElseStatement . 
transitions ->  {}

item set 778 
optionalElseStatement -> ELSE .blockStatement
blockStatement -> .statement
blockStatement -> .LBRACE RBRACE
blockStatement -> .LBRACE blockStatementList RBRACE
statement -> .ASSERT assertExpression SEMI
statement -> .IF LPAREN expression RPAREN blockStatement optionalElseStatement
statement -> .FOR LPAREN forControl RPAREN blockStatement
statement -> .WHILE LPAREN expression RPAREN blockStatement
statement -> .DO blockStatement WHILE LPAREN expression RPAREN SEMI
statement -> .TRY block catchFinallyOrOnlyFinally
statement -> .TRY resourceSpecification block catchClauses
statement -> .TRY resourceSpecification block optionalFinallyBlock
statement -> .TRY resourceSpecification block catchClauses optionalFinallyBlock
statement -> .SWITCH LPAREN expression RPAREN LBRACE switchBlockStatementGroups emptySwitchLabels RBRACE
statement -> .SYNCHRONIZED LPAREN expression RPAREN block
statement -> .RETURN SEMI
statement -> .RETURN expression SEMI
statement -> .THROW expression SEMI
statement -> .BREAK optionalIdentifier SEMI
statement -> .CONTINUE optionalIdentifier SEMI
statement -> .Identifier COLON blockStatement
statement -> .expression SEMI
statement -> .typeDeclarationWithPrefixes
statement -> .variableDeclaratorsWithPrefixes
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
typeDeclarationWithPrefixes -> .annotationl modifierL typeDeclaration
typeDeclarationWithPrefixes -> .modifierL annotationl typeDeclaration
typeDeclarationWithPrefixes -> .modifierL typeDeclaration
typeDeclarationWithPrefixes -> .annotationl typeDeclaration
typeDeclarationWithPrefixes -> .typeDeclaration
variableDeclaratorsWithPrefixes -> .annotationl modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .localVariableDeclaration
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
localVariableDeclaration -> .type variableDeclarators
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks 
transitions ->  {"blockStatement":804,"statement":466,"LBRACE":467,"ASSERT":468,"IF":469,"FOR":470,"WHILE":471,"DO":472,"TRY":473,"SWITCH":474,"SYNCHRONIZED":475,"RETURN":476,"THROW":477,"BREAK":478,"CONTINUE":479,"Identifier":480,"expression":481,"typeDeclarationWithPrefixes":482,"variableDeclaratorsWithPrefixes":483,"parExpression":98,"qualifiedName":484,"primitiveType":485,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"annotationl":486,"modifierL":487,"typeDeclaration":13,"localVariableDeclaration":488,"LPAREN":115,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131,"annotation":10,"modifier":15,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"type":489,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 779 
forControl -> forInit SEMI optionalExpression SEMI .optionalForUpdate
optionalForUpdate -> .
optionalForUpdate -> .forUpdate
forUpdate -> .expressionList
expressionList -> .expression
expressionList -> .expressionList COMMA expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"optionalForUpdate":805,"forUpdate":781,"expressionList":782,"expression":248,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 780 
forControl -> SEMI optionalExpression SEMI optionalForUpdate . 
transitions ->  {}

item set 781 
optionalForUpdate -> forUpdate . 
transitions ->  {}

item set 782 
forUpdate -> expressionList .
expressionList -> expressionList .COMMA expression 
transitions ->  {"COMMA":347}

item set 783 
enhancedForControl -> modifierL type variableDeclaratorId COLON .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":806,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 784 
enhancedForControl -> type variableDeclaratorId COLON expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":151,"LBRACK":152,"arguments":153,"LPAREN":154,"incrementOrDecrement":155,"mulDivOrMod":156,"addOrSub":157,"LSHIFT":158,"GT":159,"lE_GE_LT_GT":160,"INSTANCEOF":161,"equals_NotEqual":162,"BITAND":163,"CARET":164,"BITOR":165,"AND":166,"OR":167,"QUESTION":168,"assignmentToken":169,"INC":170,"DEC":171,"MUL":172,"DIV":173,"MOD":174,"ADD":175,"SUB":176,"LE":177,"GE":178,"LT":179,"EQUAL":180,"NOTEQUAL":181,"ASSIGN":182,"ADD_ASSIGN":183,"SUB_ASSIGN":184,"MUL_ASSIGN":185,"DIV_ASSIGN":186,"AND_ASSIGN":187,"OR_ASSIGN":188,"XOR_ASSIGN":189,"RSHIFT_ASSIGN":190,"URSHIFT_ASSIGN":191,"LSHIFT_ASSIGN":192,"MOD_ASSIGN":193}

item set 785 
statement -> DO blockStatement WHILE LPAREN expression RPAREN .SEMI 
transitions ->  {"SEMI":807}

item set 786 
catchClause -> CATCH LPAREN variableModifiers catchType .Identifier RPAREN block
catchType -> catchType .BITOR qualifiedName 
transitions ->  {"Identifier":808,"BITOR":788}

item set 787 
catchClause -> CATCH LPAREN catchType Identifier .RPAREN block 
transitions ->  {"RPAREN":809}

item set 788 
catchType -> catchType BITOR .qualifiedName
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters 
transitions ->  {"qualifiedName":810,"Identifier":49}

item set 789 
resource -> variableModifiers classOrInterfaceType variableDeclaratorId ASSIGN .expression
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":811,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 790 
resource -> classOrInterfaceType variableDeclaratorId ASSIGN expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":151,"LBRACK":152,"arguments":153,"LPAREN":154,"incrementOrDecrement":155,"mulDivOrMod":156,"addOrSub":157,"LSHIFT":158,"GT":159,"lE_GE_LT_GT":160,"INSTANCEOF":161,"equals_NotEqual":162,"BITAND":163,"CARET":164,"BITOR":165,"AND":166,"OR":167,"QUESTION":168,"assignmentToken":169,"INC":170,"DEC":171,"MUL":172,"DIV":173,"MOD":174,"ADD":175,"SUB":176,"LE":177,"GE":178,"LT":179,"EQUAL":180,"NOTEQUAL":181,"ASSIGN":182,"ADD_ASSIGN":183,"SUB_ASSIGN":184,"MUL_ASSIGN":185,"DIV_ASSIGN":186,"AND_ASSIGN":187,"OR_ASSIGN":188,"XOR_ASSIGN":189,"RSHIFT_ASSIGN":190,"URSHIFT_ASSIGN":191,"LSHIFT_ASSIGN":192,"MOD_ASSIGN":193}

item set 791 
statement -> SWITCH LPAREN expression RPAREN LBRACE switchBlockStatementGroups .emptySwitchLabels RBRACE
emptySwitchLabels -> .
emptySwitchLabels -> .switchLabelL
switchLabelL -> .switchLabel
switchLabelL -> .switchLabelL switchLabel
switchLabel -> .CASE expression COLON
switchLabel -> .DEFAULT COLON 
transitions ->  {"emptySwitchLabels":812,"switchLabelL":813,"switchLabel":795,"CASE":796,"DEFAULT":797}

item set 792 
switchBlockStatementGroups -> switchBlockStatementGroupL .
switchBlockStatementGroupL -> switchBlockStatementGroupL .switchBlockStatementGroup
switchBlockStatementGroup -> .switchLabelL blockStatementList
switchBlockStatementGroup -> .switchLabelL
switchLabelL -> .switchLabel
switchLabelL -> .switchLabelL switchLabel
switchLabel -> .CASE expression COLON
switchLabel -> .DEFAULT COLON 
transitions ->  {"switchBlockStatementGroup":814,"switchLabelL":794,"switchLabel":795,"CASE":796,"DEFAULT":797}

item set 793 
switchBlockStatementGroupL -> switchBlockStatementGroup . 
transitions ->  {}

item set 794 
switchBlockStatementGroup -> switchLabelL .blockStatementList
switchBlockStatementGroup -> switchLabelL .
switchLabelL -> switchLabelL .switchLabel
blockStatementList -> .blockStatement
blockStatementList -> .blockStatementList blockStatement
switchLabel -> .CASE expression COLON
switchLabel -> .DEFAULT COLON
blockStatement -> .statement
blockStatement -> .LBRACE RBRACE
blockStatement -> .LBRACE blockStatementList RBRACE
statement -> .ASSERT assertExpression SEMI
statement -> .IF LPAREN expression RPAREN blockStatement optionalElseStatement
statement -> .FOR LPAREN forControl RPAREN blockStatement
statement -> .WHILE LPAREN expression RPAREN blockStatement
statement -> .DO blockStatement WHILE LPAREN expression RPAREN SEMI
statement -> .TRY block catchFinallyOrOnlyFinally
statement -> .TRY resourceSpecification block catchClauses
statement -> .TRY resourceSpecification block optionalFinallyBlock
statement -> .TRY resourceSpecification block catchClauses optionalFinallyBlock
statement -> .SWITCH LPAREN expression RPAREN LBRACE switchBlockStatementGroups emptySwitchLabels RBRACE
statement -> .SYNCHRONIZED LPAREN expression RPAREN block
statement -> .RETURN SEMI
statement -> .RETURN expression SEMI
statement -> .THROW expression SEMI
statement -> .BREAK optionalIdentifier SEMI
statement -> .CONTINUE optionalIdentifier SEMI
statement -> .Identifier COLON blockStatement
statement -> .expression SEMI
statement -> .typeDeclarationWithPrefixes
statement -> .variableDeclaratorsWithPrefixes
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
typeDeclarationWithPrefixes -> .annotationl modifierL typeDeclaration
typeDeclarationWithPrefixes -> .modifierL annotationl typeDeclaration
typeDeclarationWithPrefixes -> .modifierL typeDeclaration
typeDeclarationWithPrefixes -> .annotationl typeDeclaration
typeDeclarationWithPrefixes -> .typeDeclaration
variableDeclaratorsWithPrefixes -> .annotationl modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .localVariableDeclaration
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
localVariableDeclaration -> .type variableDeclarators
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks 
transitions ->  {"blockStatementList":815,"switchLabel":816,"blockStatement":465,"CASE":796,"DEFAULT":797,"statement":466,"LBRACE":467,"ASSERT":468,"IF":469,"FOR":470,"WHILE":471,"DO":472,"TRY":473,"SWITCH":474,"SYNCHRONIZED":475,"RETURN":476,"THROW":477,"BREAK":478,"CONTINUE":479,"Identifier":480,"expression":481,"typeDeclarationWithPrefixes":482,"variableDeclaratorsWithPrefixes":483,"parExpression":98,"qualifiedName":484,"primitiveType":485,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"annotationl":486,"modifierL":487,"typeDeclaration":13,"localVariableDeclaration":488,"LPAREN":115,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131,"annotation":10,"modifier":15,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"type":489,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 795 
switchLabelL -> switchLabel . 
transitions ->  {}

item set 796 
switchLabel -> CASE .expression COLON
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE 
transitions ->  {"expression":817,"parExpression":98,"qualifiedName":99,"primitiveType":100,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"LPAREN":115,"Identifier":49,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131}

item set 797 
switchLabel -> DEFAULT .COLON 
transitions ->  {"COLON":818}

item set 798 
interfaceMemberDeclaration -> typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI . 
transitions ->  {}

item set 799 
interfaceMemberDeclaration -> typeParameters type Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI . 
transitions ->  {}

item set 800 
classMemberDeclaration -> typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn block . 
transitions ->  {}

item set 801 
classMemberDeclaration -> typeParameters VOID Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI . 
transitions ->  {}

item set 802 
classMemberDeclaration -> typeParameters type Identifier formalParameters arrayDimensionBracks throwsList commentReturn block . 
transitions ->  {}

item set 803 
classMemberDeclaration -> typeParameters type Identifier formalParameters arrayDimensionBracks throwsList commentReturn SEMI . 
transitions ->  {}

item set 804 
optionalElseStatement -> ELSE blockStatement . 
transitions ->  {}

item set 805 
forControl -> forInit SEMI optionalExpression SEMI optionalForUpdate . 
transitions ->  {}

item set 806 
enhancedForControl -> modifierL type variableDeclaratorId COLON expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":151,"LBRACK":152,"arguments":153,"LPAREN":154,"incrementOrDecrement":155,"mulDivOrMod":156,"addOrSub":157,"LSHIFT":158,"GT":159,"lE_GE_LT_GT":160,"INSTANCEOF":161,"equals_NotEqual":162,"BITAND":163,"CARET":164,"BITOR":165,"AND":166,"OR":167,"QUESTION":168,"assignmentToken":169,"INC":170,"DEC":171,"MUL":172,"DIV":173,"MOD":174,"ADD":175,"SUB":176,"LE":177,"GE":178,"LT":179,"EQUAL":180,"NOTEQUAL":181,"ASSIGN":182,"ADD_ASSIGN":183,"SUB_ASSIGN":184,"MUL_ASSIGN":185,"DIV_ASSIGN":186,"AND_ASSIGN":187,"OR_ASSIGN":188,"XOR_ASSIGN":189,"RSHIFT_ASSIGN":190,"URSHIFT_ASSIGN":191,"LSHIFT_ASSIGN":192,"MOD_ASSIGN":193}

item set 807 
statement -> DO blockStatement WHILE LPAREN expression RPAREN SEMI . 
transitions ->  {}

item set 808 
catchClause -> CATCH LPAREN variableModifiers catchType Identifier .RPAREN block 
transitions ->  {"RPAREN":819}

item set 809 
catchClause -> CATCH LPAREN catchType Identifier RPAREN .block
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE 
transitions ->  {"block":820,"LBRACE":403}

item set 810 
catchType -> catchType BITOR qualifiedName .
qualifiedName -> qualifiedName .DOT Identifier
qualifiedName -> qualifiedName .DOT Identifier typeParameters 
transitions ->  {"DOT":69}

item set 811 
resource -> variableModifiers classOrInterfaceType variableDeclaratorId ASSIGN expression .
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"DOT":151,"LBRACK":152,"arguments":153,"LPAREN":154,"incrementOrDecrement":155,"mulDivOrMod":156,"addOrSub":157,"LSHIFT":158,"GT":159,"lE_GE_LT_GT":160,"INSTANCEOF":161,"equals_NotEqual":162,"BITAND":163,"CARET":164,"BITOR":165,"AND":166,"OR":167,"QUESTION":168,"assignmentToken":169,"INC":170,"DEC":171,"MUL":172,"DIV":173,"MOD":174,"ADD":175,"SUB":176,"LE":177,"GE":178,"LT":179,"EQUAL":180,"NOTEQUAL":181,"ASSIGN":182,"ADD_ASSIGN":183,"SUB_ASSIGN":184,"MUL_ASSIGN":185,"DIV_ASSIGN":186,"AND_ASSIGN":187,"OR_ASSIGN":188,"XOR_ASSIGN":189,"RSHIFT_ASSIGN":190,"URSHIFT_ASSIGN":191,"LSHIFT_ASSIGN":192,"MOD_ASSIGN":193}

item set 812 
statement -> SWITCH LPAREN expression RPAREN LBRACE switchBlockStatementGroups emptySwitchLabels .RBRACE 
transitions ->  {"RBRACE":821}

item set 813 
emptySwitchLabels -> switchLabelL .
switchLabelL -> switchLabelL .switchLabel
switchLabel -> .CASE expression COLON
switchLabel -> .DEFAULT COLON 
transitions ->  {"switchLabel":816,"CASE":796,"DEFAULT":797}

item set 814 
switchBlockStatementGroupL -> switchBlockStatementGroupL switchBlockStatementGroup . 
transitions ->  {}

item set 815 
switchBlockStatementGroup -> switchLabelL blockStatementList .
blockStatementList -> blockStatementList .blockStatement
blockStatement -> .statement
blockStatement -> .LBRACE RBRACE
blockStatement -> .LBRACE blockStatementList RBRACE
statement -> .ASSERT assertExpression SEMI
statement -> .IF LPAREN expression RPAREN blockStatement optionalElseStatement
statement -> .FOR LPAREN forControl RPAREN blockStatement
statement -> .WHILE LPAREN expression RPAREN blockStatement
statement -> .DO blockStatement WHILE LPAREN expression RPAREN SEMI
statement -> .TRY block catchFinallyOrOnlyFinally
statement -> .TRY resourceSpecification block catchClauses
statement -> .TRY resourceSpecification block optionalFinallyBlock
statement -> .TRY resourceSpecification block catchClauses optionalFinallyBlock
statement -> .SWITCH LPAREN expression RPAREN LBRACE switchBlockStatementGroups emptySwitchLabels RBRACE
statement -> .SYNCHRONIZED LPAREN expression RPAREN block
statement -> .RETURN SEMI
statement -> .RETURN expression SEMI
statement -> .THROW expression SEMI
statement -> .BREAK optionalIdentifier SEMI
statement -> .CONTINUE optionalIdentifier SEMI
statement -> .Identifier COLON blockStatement
statement -> .expression SEMI
statement -> .typeDeclarationWithPrefixes
statement -> .variableDeclaratorsWithPrefixes
expression -> .parExpression
expression -> .qualifiedName
expression -> .qualifiedName DOT CLASS
expression -> .expression DOT qualifiedName
expression -> .expression DOT SUPER
expression -> .qualifiedName DOT SUPER
expression -> .qualifiedName DOT SUPER DOT expression
expression -> .expression DOT SUPER DOT expression
expression -> .expression DOT SUPER arguments
expression -> .expression DOT SUPER LPAREN RPAREN
expression -> .expression
expression -> .qualifiedName DOT newCreator
expression -> .expression DOT newCreator
expression -> .qualifiedName arrayDimensionBrackl DOT CLASS
expression -> .primitiveType DOT CLASS
expression -> .primitiveType arrayDimensionBrackl DOT CLASS
expression -> .qualifiedName DOT THIS
expression -> .expression DOT THIS
expression -> .expression DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> .qualifiedName DOT explicitGenericInvocation
expression -> .expression DOT qualifiedName
expression -> .expression DOT typeParameters Identifier arguments
expression -> .expression LBRACK expression RBRACK
expression -> .qualifiedName LBRACK expression RBRACK
expression -> .expression arguments
expression -> .expression LPAREN RPAREN
expression -> .newCreator
expression -> .parExpression expression
expression -> .expression incrementOrDecrement
expression -> .plusMinusIncOrDec expression
expression -> .prefixTildeOrBang expression
expression -> .expression mulDivOrMod expression
expression -> .expression addOrSub expression
expression -> .expression LSHIFT expression
expression -> .expression GT GT expression
expression -> .expression GT GT GT expression
expression -> .expression lE_GE_LT_GT expression
expression -> .expression INSTANCEOF type
expression -> .expression equals_NotEqual expression
expression -> .expression BITAND expression
expression -> .expression CARET expression
expression -> .expression BITOR expression
expression -> .expression AND expression
expression -> .expression OR expression
expression -> .expression QUESTION expression COLON expression
expression -> .expression assignmentToken expression
expression -> .THIS
expression -> .SUPER
expression -> .IntegerLiteral
expression -> .FloatingPointLiteral
expression -> .CharacterLiteral
expression -> .StringLiteral
expression -> .BooleanLiteral
expression -> .NullLiteral
expression -> .VOID DOT CLASS
expression -> .nonWildcardTypeArguments explicitGenericInvocationSuffixOrThisArgs
typeDeclarationWithPrefixes -> .annotationl modifierL typeDeclaration
typeDeclarationWithPrefixes -> .modifierL annotationl typeDeclaration
typeDeclarationWithPrefixes -> .modifierL typeDeclaration
typeDeclarationWithPrefixes -> .annotationl typeDeclaration
typeDeclarationWithPrefixes -> .typeDeclaration
variableDeclaratorsWithPrefixes -> .annotationl modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .modifierL localVariableDeclaration
variableDeclaratorsWithPrefixes -> .annotationl localVariableDeclaration
variableDeclaratorsWithPrefixes -> .localVariableDeclaration
parExpression -> .LPAREN expression RPAREN
parExpression -> .LPAREN primitiveType RPAREN
parExpression -> .LPAREN qualifiedName arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters arrayDimensionBrackl RPAREN
parExpression -> .LPAREN qualifiedName typeParameters RPAREN
parExpression -> .LPAREN primitiveType arrayDimensionBrackl RPAREN
parExpression -> .LPAREN expression RPAREN
qualifiedName -> .Identifier
qualifiedName -> .Identifier typeParameters
qualifiedName -> .qualifiedName DOT Identifier
qualifiedName -> .qualifiedName DOT Identifier typeParameters
primitiveType -> .BOOLEAN
primitiveType -> .CHAR
primitiveType -> .BYTE
primitiveType -> .SHORT
primitiveType -> .INT
primitiveType -> .LONG
primitiveType -> .FLOAT
primitiveType -> .DOUBLE
newCreator -> .NEW creator
plusMinusIncOrDec -> .ADD
plusMinusIncOrDec -> .SUB
plusMinusIncOrDec -> .INC
plusMinusIncOrDec -> .DEC
prefixTildeOrBang -> .TILDE
prefixTildeOrBang -> .BANG
nonWildcardTypeArguments -> .TEMPLATE
annotationl -> .annotation
annotationl -> .annotationl annotation
modifierL -> .modifier
modifierL -> .modifierL modifier
typeDeclaration -> .classDeclaration
typeDeclaration -> .interfaceDeclaration
typeDeclaration -> .enumDeclaration
typeDeclaration -> .annotationTypeDeclaration
typeDeclaration -> .SEMI
localVariableDeclaration -> .type variableDeclarators
annotation -> .AT qualifiedName
annotation -> .AT qualifiedName LPAREN elementValueList RPAREN
annotation -> .AT qualifiedName LPAREN elementValuePairs RPAREN
modifier -> .STATIC
modifier -> .FINAL
modifier -> .ABSTRACT
modifier -> .STRICTFP
modifier -> .TRANSIENT
modifier -> .VOLATILE
modifier -> .PUBLIC
modifier -> .PRIVATE
modifier -> .PROTECTED
modifier -> .NATIVE
modifier -> .SYNCHRONIZED
classDeclaration -> .CLASS Identifier classInheritance interfaceImplentation commentReturn classBody
classDeclaration -> .CLASS Identifier typeParameters classInheritance interfaceImplentation commentReturn classBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters commentReturn interfaceBody
interfaceDeclaration -> .INTERFACE Identifier optionalTypeParameters EXTENDS typeList commentReturn interfaceBody
enumDeclaration -> .ENUM Identifier interfaceImplentation commentReturn enumBody
annotationTypeDeclaration -> .AT INTERFACE Identifier commentReturn annotationTypeBody
annotationTypeDeclaration -> .AT INTERFACE Identifier EXTENDS typeList commentReturn annotationTypeBody
type -> .qualifiedName arrayDimensionBracks
type -> .primitiveType arrayDimensionBracks 
transitions ->  {"blockStatement":542,"statement":466,"LBRACE":467,"ASSERT":468,"IF":469,"FOR":470,"WHILE":471,"DO":472,"TRY":473,"SWITCH":474,"SYNCHRONIZED":475,"RETURN":476,"THROW":477,"BREAK":478,"CONTINUE":479,"Identifier":480,"expression":481,"typeDeclarationWithPrefixes":482,"variableDeclaratorsWithPrefixes":483,"parExpression":98,"qualifiedName":484,"primitiveType":485,"newCreator":101,"plusMinusIncOrDec":102,"prefixTildeOrBang":103,"THIS":104,"SUPER":105,"IntegerLiteral":106,"FloatingPointLiteral":107,"CharacterLiteral":108,"StringLiteral":109,"BooleanLiteral":110,"NullLiteral":111,"VOID":112,"nonWildcardTypeArguments":113,"annotationl":486,"modifierL":487,"typeDeclaration":13,"localVariableDeclaration":488,"LPAREN":115,"BOOLEAN":116,"CHAR":117,"BYTE":118,"SHORT":119,"INT":120,"LONG":121,"FLOAT":122,"DOUBLE":123,"NEW":124,"ADD":125,"SUB":126,"INC":127,"DEC":128,"TILDE":129,"BANG":130,"TEMPLATE":131,"annotation":10,"modifier":15,"classDeclaration":16,"interfaceDeclaration":17,"enumDeclaration":18,"annotationTypeDeclaration":19,"SEMI":38,"type":489,"AT":14,"STATIC":20,"FINAL":21,"ABSTRACT":22,"STRICTFP":23,"TRANSIENT":24,"VOLATILE":25,"PUBLIC":26,"PRIVATE":27,"PROTECTED":28,"NATIVE":29,"CLASS":31,"INTERFACE":32,"ENUM":33}

item set 816 
switchLabelL -> switchLabelL switchLabel . 
transitions ->  {}

item set 817 
switchLabel -> CASE expression .COLON
expression -> expression .DOT qualifiedName
expression -> expression .DOT SUPER
expression -> expression .DOT SUPER DOT expression
expression -> expression .DOT SUPER arguments
expression -> expression .DOT SUPER LPAREN RPAREN
expression -> expression .
expression -> expression .DOT newCreator
expression -> expression .DOT THIS
expression -> expression .DOT NEW optionalNonWildcardTypeArguments innerCreator
expression -> expression .DOT qualifiedName
expression -> expression .DOT typeParameters Identifier arguments
expression -> expression .LBRACK expression RBRACK
expression -> expression .arguments
expression -> expression .LPAREN RPAREN
expression -> expression .incrementOrDecrement
expression -> expression .mulDivOrMod expression
expression -> expression .addOrSub expression
expression -> expression .LSHIFT expression
expression -> expression .GT GT expression
expression -> expression .GT GT GT expression
expression -> expression .lE_GE_LT_GT expression
expression -> expression .INSTANCEOF type
expression -> expression .equals_NotEqual expression
expression -> expression .BITAND expression
expression -> expression .CARET expression
expression -> expression .BITOR expression
expression -> expression .AND expression
expression -> expression .OR expression
expression -> expression .QUESTION expression COLON expression
expression -> expression .assignmentToken expression
arguments -> .LPAREN RPAREN
arguments -> .LPAREN expressionList RPAREN
incrementOrDecrement -> .INC
incrementOrDecrement -> .DEC
mulDivOrMod -> .MUL
mulDivOrMod -> .DIV
mulDivOrMod -> .MOD
addOrSub -> .ADD
addOrSub -> .SUB
lE_GE_LT_GT -> .LE
lE_GE_LT_GT -> .GE
lE_GE_LT_GT -> .GT
lE_GE_LT_GT -> .LT
equals_NotEqual -> .EQUAL
equals_NotEqual -> .NOTEQUAL
assignmentToken -> .ASSIGN
assignmentToken -> .ADD_ASSIGN
assignmentToken -> .SUB_ASSIGN
assignmentToken -> .MUL_ASSIGN
assignmentToken -> .DIV_ASSIGN
assignmentToken -> .AND_ASSIGN
assignmentToken -> .OR_ASSIGN
assignmentToken -> .XOR_ASSIGN
assignmentToken -> .RSHIFT_ASSIGN
assignmentToken -> .URSHIFT_ASSIGN
assignmentToken -> .LSHIFT_ASSIGN
assignmentToken -> .MOD_ASSIGN 
transitions ->  {"COLON":822,"DOT":151,"LBRACK":152,"arguments":153,"LPAREN":154,"incrementOrDecrement":155,"mulDivOrMod":156,"addOrSub":157,"LSHIFT":158,"GT":159,"lE_GE_LT_GT":160,"INSTANCEOF":161,"equals_NotEqual":162,"BITAND":163,"CARET":164,"BITOR":165,"AND":166,"OR":167,"QUESTION":168,"assignmentToken":169,"INC":170,"DEC":171,"MUL":172,"DIV":173,"MOD":174,"ADD":175,"SUB":176,"LE":177,"GE":178,"LT":179,"EQUAL":180,"NOTEQUAL":181,"ASSIGN":182,"ADD_ASSIGN":183,"SUB_ASSIGN":184,"MUL_ASSIGN":185,"DIV_ASSIGN":186,"AND_ASSIGN":187,"OR_ASSIGN":188,"XOR_ASSIGN":189,"RSHIFT_ASSIGN":190,"URSHIFT_ASSIGN":191,"LSHIFT_ASSIGN":192,"MOD_ASSIGN":193}

item set 818 
switchLabel -> DEFAULT COLON . 
transitions ->  {}

item set 819 
catchClause -> CATCH LPAREN variableModifiers catchType Identifier RPAREN .block
block -> .LBRACE RBRACE
block -> .LBRACE blockStatementList RBRACE 
transitions ->  {"block":823,"LBRACE":403}

item set 820 
catchClause -> CATCH LPAREN catchType Identifier RPAREN block . 
transitions ->  {}

item set 821 
statement -> SWITCH LPAREN expression RPAREN LBRACE switchBlockStatementGroups emptySwitchLabels RBRACE . 
transitions ->  {}

item set 822 
switchLabel -> CASE expression COLON . 
transitions ->  {}

item set 823 
catchClause -> CATCH LPAREN variableModifiers catchType Identifier RPAREN block . 
transitions ->  {}
824 states.
Building lookahead grammar.
Computing lookaheads.
Building parse table.
Conflict at state: 2, token: EOF
  reduce by rule: packageDeclaration -> packageDeclaration
  shift token (then go to state 34)
Conflict at state: 2, token: IMPORT
  reduce by rule: packageDeclaration -> packageDeclaration
  shift token (then go to state 11)
Conflict at state: 2, token: AT
  reduce by rule: packageDeclaration -> packageDeclaration
  shift token (then go to state 14)
Conflict at state: 2, token: STATIC
  reduce by rule: packageDeclaration -> packageDeclaration
  shift token (then go to state 20)
Conflict at state: 2, token: FINAL
  reduce by rule: packageDeclaration -> packageDeclaration
  shift token (then go to state 21)
Conflict at state: 2, token: ABSTRACT
  reduce by rule: packageDeclaration -> packageDeclaration
  shift token (then go to state 22)
Conflict at state: 2, token: STRICTFP
  reduce by rule: packageDeclaration -> packageDeclaration
  shift token (then go to state 23)
Conflict at state: 2, token: TRANSIENT
  reduce by rule: packageDeclaration -> packageDeclaration
  shift token (then go to state 24)
Conflict at state: 2, token: VOLATILE
  reduce by rule: packageDeclaration -> packageDeclaration
  shift token (then go to state 25)
Conflict at state: 2, token: PUBLIC
  reduce by rule: packageDeclaration -> packageDeclaration
  shift token (then go to state 26)
Conflict at state: 2, token: PRIVATE
  reduce by rule: packageDeclaration -> packageDeclaration
  shift token (then go to state 27)
Conflict at state: 2, token: PROTECTED
  reduce by rule: packageDeclaration -> packageDeclaration
  shift token (then go to state 28)
Conflict at state: 2, token: NATIVE
  reduce by rule: packageDeclaration -> packageDeclaration
  shift token (then go to state 29)
Conflict at state: 2, token: SYNCHRONIZED
  reduce by rule: packageDeclaration -> packageDeclaration
  shift token (then go to state 30)
Conflict at state: 2, token: CLASS
  reduce by rule: packageDeclaration -> packageDeclaration
  shift token (then go to state 31)
Conflict at state: 2, token: INTERFACE
  reduce by rule: packageDeclaration -> packageDeclaration
  shift token (then go to state 32)
Conflict at state: 2, token: ENUM
  reduce by rule: packageDeclaration -> packageDeclaration
  shift token (then go to state 33)
Conflict at state: 2, token: SEMI
  reduce by rule: packageDeclaration -> packageDeclaration
  shift token (then go to state 38)
Conflict at state: 5, token: $end
  reduce by rule: typeDeclaration -> SEMI
  reduce by rule: compilationUnit -> SEMI
Conflict at state: 5, token: EOF
  reduce by rule: typeDeclaration -> SEMI
  reduce by rule: compilationUnit -> SEMI
Conflict at state: 5, token: AT
  reduce by rule: typeDeclaration -> SEMI
  reduce by rule: compilationUnit -> SEMI
Conflict at state: 5, token: STATIC
  reduce by rule: typeDeclaration -> SEMI
  reduce by rule: compilationUnit -> SEMI
Conflict at state: 5, token: FINAL
  reduce by rule: typeDeclaration -> SEMI
  reduce by rule: compilationUnit -> SEMI
Conflict at state: 5, token: ABSTRACT
  reduce by rule: typeDeclaration -> SEMI
  reduce by rule: compilationUnit -> SEMI
Conflict at state: 5, token: STRICTFP
  reduce by rule: typeDeclaration -> SEMI
  reduce by rule: compilationUnit -> SEMI
Conflict at state: 5, token: TRANSIENT
  reduce by rule: typeDeclaration -> SEMI
  reduce by rule: compilationUnit -> SEMI
Conflict at state: 5, token: VOLATILE
  reduce by rule: typeDeclaration -> SEMI
  reduce by rule: compilationUnit -> SEMI
Conflict at state: 5, token: PUBLIC
  reduce by rule: typeDeclaration -> SEMI
  reduce by rule: compilationUnit -> SEMI
Conflict at state: 5, token: PRIVATE
  reduce by rule: typeDeclaration -> SEMI
  reduce by rule: compilationUnit -> SEMI
Conflict at state: 5, token: PROTECTED
  reduce by rule: typeDeclaration -> SEMI
  reduce by rule: compilationUnit -> SEMI
Conflict at state: 5, token: NATIVE
  reduce by rule: typeDeclaration -> SEMI
  reduce by rule: compilationUnit -> SEMI
Conflict at state: 5, token: SYNCHRONIZED
  reduce by rule: typeDeclaration -> SEMI
  reduce by rule: compilationUnit -> SEMI
Conflict at state: 5, token: CLASS
  reduce by rule: typeDeclaration -> SEMI
  reduce by rule: compilationUnit -> SEMI
Conflict at state: 5, token: INTERFACE
  reduce by rule: typeDeclaration -> SEMI
  reduce by rule: compilationUnit -> SEMI
Conflict at state: 5, token: ENUM
  reduce by rule: typeDeclaration -> SEMI
  reduce by rule: compilationUnit -> SEMI
Conflict at state: 5, token: SEMI
  reduce by rule: typeDeclaration -> SEMI
  reduce by rule: compilationUnit -> SEMI
Conflict at state: 43, token: SEMI
  reduce by rule: packageDeclaration -> packageDeclaration
  reduce by rule: packageDeclaration -> annotationl packageDeclaration
Conflict at state: 43, token: ENUM
  reduce by rule: packageDeclaration -> packageDeclaration
  reduce by rule: packageDeclaration -> annotationl packageDeclaration
Conflict at state: 43, token: INTERFACE
  reduce by rule: packageDeclaration -> packageDeclaration
  reduce by rule: packageDeclaration -> annotationl packageDeclaration
Conflict at state: 43, token: CLASS
  reduce by rule: packageDeclaration -> packageDeclaration
  reduce by rule: packageDeclaration -> annotationl packageDeclaration
Conflict at state: 43, token: SYNCHRONIZED
  reduce by rule: packageDeclaration -> packageDeclaration
  reduce by rule: packageDeclaration -> annotationl packageDeclaration
Conflict at state: 43, token: NATIVE
  reduce by rule: packageDeclaration -> packageDeclaration
  reduce by rule: packageDeclaration -> annotationl packageDeclaration
Conflict at state: 43, token: PROTECTED
  reduce by rule: packageDeclaration -> packageDeclaration
  reduce by rule: packageDeclaration -> annotationl packageDeclaration
Conflict at state: 43, token: PRIVATE
  reduce by rule: packageDeclaration -> packageDeclaration
  reduce by rule: packageDeclaration -> annotationl packageDeclaration
Conflict at state: 43, token: PUBLIC
  reduce by rule: packageDeclaration -> packageDeclaration
  reduce by rule: packageDeclaration -> annotationl packageDeclaration
Conflict at state: 43, token: VOLATILE
  reduce by rule: packageDeclaration -> packageDeclaration
  reduce by rule: packageDeclaration -> annotationl packageDeclaration
Conflict at state: 43, token: TRANSIENT
  reduce by rule: packageDeclaration -> packageDeclaration
  reduce by rule: packageDeclaration -> annotationl packageDeclaration
Conflict at state: 43, token: STRICTFP
  reduce by rule: packageDeclaration -> packageDeclaration
  reduce by rule: packageDeclaration -> annotationl packageDeclaration
Conflict at state: 43, token: ABSTRACT
  reduce by rule: packageDeclaration -> packageDeclaration
  reduce by rule: packageDeclaration -> annotationl packageDeclaration
Conflict at state: 43, token: FINAL
  reduce by rule: packageDeclaration -> packageDeclaration
  reduce by rule: packageDeclaration -> annotationl packageDeclaration
Conflict at state: 43, token: STATIC
  reduce by rule: packageDeclaration -> packageDeclaration
  reduce by rule: packageDeclaration -> annotationl packageDeclaration
Conflict at state: 43, token: AT
  reduce by rule: packageDeclaration -> packageDeclaration
  reduce by rule: packageDeclaration -> annotationl packageDeclaration
Conflict at state: 43, token: IMPORT
  reduce by rule: packageDeclaration -> packageDeclaration
  reduce by rule: packageDeclaration -> annotationl packageDeclaration
Conflict at state: 43, token: EOF
  reduce by rule: packageDeclaration -> packageDeclaration
  reduce by rule: packageDeclaration -> annotationl packageDeclaration
Conflict at state: 44, token: AT
  reduce by rule: annotationl -> annotation
  reduce by rule: annotationl -> annotationl annotation
Conflict at state: 44, token: PACKAGE
  reduce by rule: annotationl -> annotation
  reduce by rule: annotationl -> annotationl annotation
Conflict at state: 49, token: TEMPLATE
  reduce by rule: qualifiedName -> Identifier
  shift token (then go to state 71)
Conflict at state: 86, token: TEMPLATE
  reduce by rule: qualifiedName -> qualifiedName DOT Identifier
  shift token (then go to state 71)
Conflict at state: 94, token: DOT
  reduce by rule: elementValue -> expression
  shift token (then go to state 151)
Conflict at state: 94, token: LBRACK
  reduce by rule: elementValue -> expression
  shift token (then go to state 152)
Conflict at state: 94, token: LPAREN
  reduce by rule: elementValue -> expression
  shift token (then go to state 154)
Conflict at state: 94, token: INC
  reduce by rule: elementValue -> expression
  shift token (then go to state 170)
Conflict at state: 94, token: DEC
  reduce by rule: elementValue -> expression
  shift token (then go to state 171)
Conflict at state: 94, token: MUL
  reduce by rule: elementValue -> expression
  shift token (then go to state 172)
Conflict at state: 94, token: DIV
  reduce by rule: elementValue -> expression
  shift token (then go to state 173)
Conflict at state: 94, token: MOD
  reduce by rule: elementValue -> expression
  shift token (then go to state 174)
Conflict at state: 94, token: ADD
  reduce by rule: elementValue -> expression
  shift token (then go to state 175)
Conflict at state: 94, token: SUB
  reduce by rule: elementValue -> expression
  shift token (then go to state 176)
Conflict at state: 94, token: LSHIFT
  reduce by rule: elementValue -> expression
  shift token (then go to state 158)
Conflict at state: 94, token: GT
  reduce by rule: elementValue -> expression
  shift token (then go to state 159)
Conflict at state: 94, token: LE
  reduce by rule: elementValue -> expression
  shift token (then go to state 177)
Conflict at state: 94, token: GE
  reduce by rule: elementValue -> expression
  shift token (then go to state 178)
Conflict at state: 94, token: LT
  reduce by rule: elementValue -> expression
  shift token (then go to state 179)
Conflict at state: 94, token: INSTANCEOF
  reduce by rule: elementValue -> expression
  shift token (then go to state 161)
Conflict at state: 94, token: EQUAL
  reduce by rule: elementValue -> expression
  shift token (then go to state 180)
Conflict at state: 94, token: NOTEQUAL
  reduce by rule: elementValue -> expression
  shift token (then go to state 181)
Conflict at state: 94, token: BITAND
  reduce by rule: elementValue -> expression
  shift token (then go to state 163)
Conflict at state: 94, token: CARET
  reduce by rule: elementValue -> expression
  shift token (then go to state 164)
Conflict at state: 94, token: BITOR
  reduce by rule: elementValue -> expression
  shift token (then go to state 165)
Conflict at state: 94, token: AND
  reduce by rule: elementValue -> expression
  shift token (then go to state 166)
Conflict at state: 94, token: OR
  reduce by rule: elementValue -> expression
  shift token (then go to state 167)
Conflict at state: 94, token: QUESTION
  reduce by rule: elementValue -> expression
  shift token (then go to state 168)
Conflict at state: 94, token: ASSIGN
  reduce by rule: elementValue -> expression
  shift token (then go to state 182)
Conflict at state: 94, token: ADD_ASSIGN
  reduce by rule: elementValue -> expression
  shift token (then go to state 183)
Conflict at state: 94, token: SUB_ASSIGN
  reduce by rule: elementValue -> expression
  shift token (then go to state 184)
Conflict at state: 94, token: MUL_ASSIGN
  reduce by rule: elementValue -> expression
  shift token (then go to state 185)
Conflict at state: 94, token: DIV_ASSIGN
  reduce by rule: elementValue -> expression
  shift token (then go to state 186)
Conflict at state: 94, token: AND_ASSIGN
  reduce by rule: elementValue -> expression
  shift token (then go to state 187)
Conflict at state: 94, token: OR_ASSIGN
  reduce by rule: elementValue -> expression
  shift token (then go to state 188)
Conflict at state: 94, token: XOR_ASSIGN
  reduce by rule: elementValue -> expression
  shift token (then go to state 189)
Conflict at state: 94, token: RSHIFT_ASSIGN
  reduce by rule: elementValue -> expression
  shift token (then go to state 190)
Conflict at state: 94, token: URSHIFT_ASSIGN
  reduce by rule: elementValue -> expression
  shift token (then go to state 191)
Conflict at state: 94, token: LSHIFT_ASSIGN
  reduce by rule: elementValue -> expression
  shift token (then go to state 192)
Conflict at state: 94, token: MOD_ASSIGN
  reduce by rule: elementValue -> expression
  shift token (then go to state 193)
Conflict at state: 94, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: elementValue -> expression
Conflict at state: 94, token: COMMA
  reduce by rule: expression -> expression
  reduce by rule: elementValue -> expression
Conflict at state: 94, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 151)
Conflict at state: 94, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 152)
Conflict at state: 94, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 94, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 94, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 94, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 172)
Conflict at state: 94, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 94, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 94, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 94, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 94, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 158)
Conflict at state: 94, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 159)
Conflict at state: 94, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 94, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 94, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 94, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 94, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 94, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 94, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 163)
Conflict at state: 94, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 94, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 165)
Conflict at state: 94, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 94, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 94, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 94, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 94, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 94, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 94, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 94, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 94, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 94, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 94, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 94, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 94, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 94, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 94, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 94, token: RBRACE
  reduce by rule: expression -> expression
  reduce by rule: elementValue -> expression
Conflict at state: 94, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: elementValue -> expression
Conflict at state: 96, token: RBRACE
  reduce by rule: annotations -> 
  shift token (then go to state 194)
Conflict at state: 97, token: ASSIGN
  reduce by rule: qualifiedName -> Identifier
  shift token (then go to state 196)
Conflict at state: 98, token: LPAREN
  reduce by rule: expression -> parExpression
  shift token (then go to state 115)
Conflict at state: 98, token: INC
  reduce by rule: expression -> parExpression
  shift token (then go to state 127)
Conflict at state: 98, token: DEC
  reduce by rule: expression -> parExpression
  shift token (then go to state 128)
Conflict at state: 98, token: ADD
  reduce by rule: expression -> parExpression
  shift token (then go to state 125)
Conflict at state: 98, token: SUB
  reduce by rule: expression -> parExpression
  shift token (then go to state 126)
Conflict at state: 98, token: TEMPLATE
  reduce by rule: expression -> parExpression
  shift token (then go to state 131)
Conflict at state: 98, token: BANG
  reduce by rule: expression -> parExpression
  shift token (then go to state 130)
Conflict at state: 98, token: TILDE
  reduce by rule: expression -> parExpression
  shift token (then go to state 129)
Conflict at state: 98, token: NEW
  reduce by rule: expression -> parExpression
  shift token (then go to state 124)
Conflict at state: 98, token: DOUBLE
  reduce by rule: expression -> parExpression
  shift token (then go to state 123)
Conflict at state: 98, token: FLOAT
  reduce by rule: expression -> parExpression
  shift token (then go to state 122)
Conflict at state: 98, token: LONG
  reduce by rule: expression -> parExpression
  shift token (then go to state 121)
Conflict at state: 98, token: INT
  reduce by rule: expression -> parExpression
  shift token (then go to state 120)
Conflict at state: 98, token: SHORT
  reduce by rule: expression -> parExpression
  shift token (then go to state 119)
Conflict at state: 98, token: BYTE
  reduce by rule: expression -> parExpression
  shift token (then go to state 118)
Conflict at state: 98, token: CHAR
  reduce by rule: expression -> parExpression
  shift token (then go to state 117)
Conflict at state: 98, token: BOOLEAN
  reduce by rule: expression -> parExpression
  shift token (then go to state 116)
Conflict at state: 98, token: VOID
  reduce by rule: expression -> parExpression
  shift token (then go to state 112)
Conflict at state: 98, token: NullLiteral
  reduce by rule: expression -> parExpression
  shift token (then go to state 111)
Conflict at state: 98, token: BooleanLiteral
  reduce by rule: expression -> parExpression
  shift token (then go to state 110)
Conflict at state: 98, token: StringLiteral
  reduce by rule: expression -> parExpression
  shift token (then go to state 109)
Conflict at state: 98, token: CharacterLiteral
  reduce by rule: expression -> parExpression
  shift token (then go to state 108)
Conflict at state: 98, token: FloatingPointLiteral
  reduce by rule: expression -> parExpression
  shift token (then go to state 107)
Conflict at state: 98, token: IntegerLiteral
  reduce by rule: expression -> parExpression
  shift token (then go to state 106)
Conflict at state: 98, token: SUPER
  reduce by rule: expression -> parExpression
  shift token (then go to state 105)
Conflict at state: 98, token: THIS
  reduce by rule: expression -> parExpression
  shift token (then go to state 104)
Conflict at state: 98, token: Identifier
  reduce by rule: expression -> parExpression
  shift token (then go to state 49)
Conflict at state: 99, token: DOT
  reduce by rule: expression -> qualifiedName
  shift token (then go to state 198)
Conflict at state: 99, token: LBRACK
  reduce by rule: expression -> qualifiedName
  shift token (then go to state 200)
Conflict at state: 137, token: DOT
  reduce by rule: arrayDimensionBracks -> 
  shift token (then go to state 69)
Conflict at state: 137, token: LBRACK
  reduce by rule: arrayDimensionBracks -> 
  shift token (then go to state 204)
Conflict at state: 138, token: LBRACK
  reduce by rule: arrayDimensionBracks -> 
  shift token (then go to state 204)
Conflict at state: 197, token: DOT
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 151)
Conflict at state: 197, token: LBRACK
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 152)
Conflict at state: 197, token: LPAREN
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 154)
Conflict at state: 197, token: INC
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 170)
Conflict at state: 197, token: DEC
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 171)
Conflict at state: 197, token: MUL
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 172)
Conflict at state: 197, token: DIV
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 173)
Conflict at state: 197, token: MOD
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 174)
Conflict at state: 197, token: ADD
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 175)
Conflict at state: 197, token: SUB
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 176)
Conflict at state: 197, token: LSHIFT
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 158)
Conflict at state: 197, token: GT
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 159)
Conflict at state: 197, token: LE
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 177)
Conflict at state: 197, token: GE
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 178)
Conflict at state: 197, token: LT
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 179)
Conflict at state: 197, token: INSTANCEOF
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 161)
Conflict at state: 197, token: EQUAL
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 180)
Conflict at state: 197, token: NOTEQUAL
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 181)
Conflict at state: 197, token: BITAND
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 163)
Conflict at state: 197, token: CARET
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 164)
Conflict at state: 197, token: BITOR
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 165)
Conflict at state: 197, token: AND
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 166)
Conflict at state: 197, token: OR
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 167)
Conflict at state: 197, token: QUESTION
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 168)
Conflict at state: 197, token: ASSIGN
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 182)
Conflict at state: 197, token: ADD_ASSIGN
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 183)
Conflict at state: 197, token: SUB_ASSIGN
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 184)
Conflict at state: 197, token: MUL_ASSIGN
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 185)
Conflict at state: 197, token: DIV_ASSIGN
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 186)
Conflict at state: 197, token: AND_ASSIGN
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 187)
Conflict at state: 197, token: OR_ASSIGN
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 188)
Conflict at state: 197, token: XOR_ASSIGN
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 189)
Conflict at state: 197, token: RSHIFT_ASSIGN
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 190)
Conflict at state: 197, token: URSHIFT_ASSIGN
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 191)
Conflict at state: 197, token: LSHIFT_ASSIGN
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 192)
Conflict at state: 197, token: MOD_ASSIGN
  reduce by rule: expression -> parExpression expression
  shift token (then go to state 193)
Conflict at state: 197, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 197, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 152)
Conflict at state: 197, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 151)
Conflict at state: 197, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: RBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 197, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 197, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 172)
Conflict at state: 197, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 197, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 197, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 197, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 197, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 158)
Conflict at state: 197, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 159)
Conflict at state: 197, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 197, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 197, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 197, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 197, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 197, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 197, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 163)
Conflict at state: 197, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 197, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 165)
Conflict at state: 197, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 197, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 197, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 197, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 197, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 197, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 197, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 197, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 197, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 197, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 197, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 197, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 197, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 197, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 197, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 197, token: COMMA
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: RBRACK
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: COLON
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: LBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: ENUM
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: INTERFACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: CLASS
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: NATIVE
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: PROTECTED
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: PRIVATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: PUBLIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: VOLATILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: TRANSIENT
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: STRICTFP
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: ABSTRACT
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: FINAL
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: STATIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: AT
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: TEMPLATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: BANG
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: TILDE
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: NEW
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: DOUBLE
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: FLOAT
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: LONG
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: INT
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: SHORT
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: BYTE
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: CHAR
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: BOOLEAN
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: VOID
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: NullLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: BooleanLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: StringLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: CharacterLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: FloatingPointLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: IntegerLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: SUPER
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: THIS
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: Identifier
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: CONTINUE
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: BREAK
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: THROW
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: RETURN
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: SYNCHRONIZED
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: SWITCH
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: TRY
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: DO
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: WHILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: FOR
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: IF
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: ASSERT
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: ELSE
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: DEFAULT
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 197, token: CASE
  reduce by rule: expression -> expression
  reduce by rule: expression -> parExpression expression
Conflict at state: 205, token: DOT
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 151)
Conflict at state: 205, token: LBRACK
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 152)
Conflict at state: 205, token: LPAREN
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 154)
Conflict at state: 205, token: INC
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 170)
Conflict at state: 205, token: DEC
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 171)
Conflict at state: 205, token: MUL
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 172)
Conflict at state: 205, token: DIV
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 173)
Conflict at state: 205, token: MOD
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 174)
Conflict at state: 205, token: ADD
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 175)
Conflict at state: 205, token: SUB
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 176)
Conflict at state: 205, token: LSHIFT
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 158)
Conflict at state: 205, token: GT
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 159)
Conflict at state: 205, token: LE
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 177)
Conflict at state: 205, token: GE
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 178)
Conflict at state: 205, token: LT
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 179)
Conflict at state: 205, token: INSTANCEOF
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 161)
Conflict at state: 205, token: EQUAL
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 180)
Conflict at state: 205, token: NOTEQUAL
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 181)
Conflict at state: 205, token: BITAND
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 163)
Conflict at state: 205, token: CARET
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 164)
Conflict at state: 205, token: BITOR
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 165)
Conflict at state: 205, token: AND
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 166)
Conflict at state: 205, token: OR
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 167)
Conflict at state: 205, token: QUESTION
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 168)
Conflict at state: 205, token: ASSIGN
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 182)
Conflict at state: 205, token: ADD_ASSIGN
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 183)
Conflict at state: 205, token: SUB_ASSIGN
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 184)
Conflict at state: 205, token: MUL_ASSIGN
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 185)
Conflict at state: 205, token: DIV_ASSIGN
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 186)
Conflict at state: 205, token: AND_ASSIGN
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 187)
Conflict at state: 205, token: OR_ASSIGN
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 188)
Conflict at state: 205, token: XOR_ASSIGN
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 189)
Conflict at state: 205, token: RSHIFT_ASSIGN
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 190)
Conflict at state: 205, token: URSHIFT_ASSIGN
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 191)
Conflict at state: 205, token: LSHIFT_ASSIGN
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 192)
Conflict at state: 205, token: MOD_ASSIGN
  reduce by rule: expression -> plusMinusIncOrDec expression
  shift token (then go to state 193)
Conflict at state: 205, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 205, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 205, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 205, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 152)
Conflict at state: 205, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 151)
Conflict at state: 205, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: RBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 172)
Conflict at state: 205, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 205, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 205, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 205, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 205, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 158)
Conflict at state: 205, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 159)
Conflict at state: 205, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 205, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 205, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 205, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 205, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 205, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 205, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 163)
Conflict at state: 205, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 205, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 165)
Conflict at state: 205, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 205, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 205, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 205, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 205, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 205, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 205, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 205, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 205, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 205, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 205, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 205, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 205, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 205, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 205, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 205, token: COMMA
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: RBRACK
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: COLON
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: LBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: ENUM
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: INTERFACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: CLASS
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: NATIVE
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: PROTECTED
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: PRIVATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: PUBLIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: VOLATILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: TRANSIENT
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: STRICTFP
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: ABSTRACT
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: FINAL
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: STATIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: AT
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: TEMPLATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: BANG
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: TILDE
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: NEW
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: DOUBLE
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: FLOAT
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: LONG
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: INT
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: SHORT
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: BYTE
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: CHAR
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: BOOLEAN
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: VOID
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: NullLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: BooleanLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: StringLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: CharacterLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: FloatingPointLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: IntegerLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: SUPER
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: THIS
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: Identifier
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: CONTINUE
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: BREAK
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: THROW
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: RETURN
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: SYNCHRONIZED
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: SWITCH
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: TRY
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: DO
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: WHILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: FOR
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: IF
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: ASSERT
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: ELSE
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: DEFAULT
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 205, token: CASE
  reduce by rule: expression -> expression
  reduce by rule: expression -> plusMinusIncOrDec expression
Conflict at state: 206, token: DOT
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 151)
Conflict at state: 206, token: LBRACK
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 152)
Conflict at state: 206, token: LPAREN
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 154)
Conflict at state: 206, token: INC
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 170)
Conflict at state: 206, token: DEC
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 171)
Conflict at state: 206, token: MUL
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 172)
Conflict at state: 206, token: DIV
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 173)
Conflict at state: 206, token: MOD
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 174)
Conflict at state: 206, token: ADD
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 175)
Conflict at state: 206, token: SUB
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 176)
Conflict at state: 206, token: LSHIFT
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 158)
Conflict at state: 206, token: GT
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 159)
Conflict at state: 206, token: LE
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 177)
Conflict at state: 206, token: GE
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 178)
Conflict at state: 206, token: LT
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 179)
Conflict at state: 206, token: INSTANCEOF
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 161)
Conflict at state: 206, token: EQUAL
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 180)
Conflict at state: 206, token: NOTEQUAL
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 181)
Conflict at state: 206, token: BITAND
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 163)
Conflict at state: 206, token: CARET
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 164)
Conflict at state: 206, token: BITOR
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 165)
Conflict at state: 206, token: AND
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 166)
Conflict at state: 206, token: OR
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 167)
Conflict at state: 206, token: QUESTION
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 168)
Conflict at state: 206, token: ASSIGN
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 182)
Conflict at state: 206, token: ADD_ASSIGN
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 183)
Conflict at state: 206, token: SUB_ASSIGN
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 184)
Conflict at state: 206, token: MUL_ASSIGN
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 185)
Conflict at state: 206, token: DIV_ASSIGN
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 186)
Conflict at state: 206, token: AND_ASSIGN
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 187)
Conflict at state: 206, token: OR_ASSIGN
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 188)
Conflict at state: 206, token: XOR_ASSIGN
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 189)
Conflict at state: 206, token: RSHIFT_ASSIGN
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 190)
Conflict at state: 206, token: URSHIFT_ASSIGN
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 191)
Conflict at state: 206, token: LSHIFT_ASSIGN
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 192)
Conflict at state: 206, token: MOD_ASSIGN
  reduce by rule: expression -> prefixTildeOrBang expression
  shift token (then go to state 193)
Conflict at state: 206, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 206, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 206, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 206, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 152)
Conflict at state: 206, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 151)
Conflict at state: 206, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: RBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 172)
Conflict at state: 206, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 206, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 206, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 206, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 206, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 158)
Conflict at state: 206, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 159)
Conflict at state: 206, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 206, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 206, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 206, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 206, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 206, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 206, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 163)
Conflict at state: 206, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 206, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 165)
Conflict at state: 206, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 206, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 206, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 206, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 206, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 206, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 206, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 206, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 206, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 206, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 206, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 206, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 206, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 206, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 206, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 206, token: COMMA
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: RBRACK
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: COLON
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: LBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: ENUM
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: INTERFACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: CLASS
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: NATIVE
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: PROTECTED
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: PRIVATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: PUBLIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: VOLATILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: TRANSIENT
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: STRICTFP
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: ABSTRACT
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: FINAL
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: STATIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: AT
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: TEMPLATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: BANG
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: TILDE
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: NEW
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: DOUBLE
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: FLOAT
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: LONG
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: INT
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: SHORT
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: BYTE
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: CHAR
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: BOOLEAN
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: VOID
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: NullLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: BooleanLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: StringLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: CharacterLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: FloatingPointLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: IntegerLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: SUPER
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: THIS
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: Identifier
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: CONTINUE
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: BREAK
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: THROW
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: RETURN
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: SYNCHRONIZED
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: SWITCH
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: TRY
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: DO
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: WHILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: FOR
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: IF
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: ASSERT
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: ELSE
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: DEFAULT
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 206, token: CASE
  reduce by rule: expression -> expression
  reduce by rule: expression -> prefixTildeOrBang expression
Conflict at state: 213, token: RPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 284)
Conflict at state: 213, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 151)
Conflict at state: 213, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 152)
Conflict at state: 213, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 213, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 213, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 213, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 172)
Conflict at state: 213, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 213, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 213, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 213, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 213, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 158)
Conflict at state: 213, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 159)
Conflict at state: 213, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 213, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 213, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 213, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 213, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 213, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 213, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 163)
Conflict at state: 213, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 213, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 165)
Conflict at state: 213, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 213, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 213, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 213, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 213, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 213, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 213, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 213, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 213, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 213, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 213, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 213, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 213, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 213, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 213, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 215, token: DOT
  reduce by rule: expression -> qualifiedName
  shift token (then go to state 198)
Conflict at state: 215, token: LBRACK
  reduce by rule: expression -> qualifiedName
  shift token (then go to state 200)
Conflict at state: 227, token: LBRACK
  reduce by rule: arrayDimensionBracks -> arrayDimensionBrackl
  shift token (then go to state 204)
Conflict at state: 239, token: DOT
  reduce by rule: expression -> expression DOT qualifiedName
  shift token (then go to state 69)
Conflict at state: 239, token: RPAREN
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: DOT
  reduce by rule: expression -> expression DOT qualifiedName
  shift token (then go to state 69)
Conflict at state: 239, token: LBRACK
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: LPAREN
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: INC
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: DEC
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: MUL
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: DIV
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: MOD
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: ADD
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: SUB
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: LSHIFT
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: GT
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: LE
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: GE
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: LT
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: INSTANCEOF
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: EQUAL
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: NOTEQUAL
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: BITAND
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: CARET
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: BITOR
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: AND
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: OR
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: QUESTION
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: ASSIGN
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: ADD_ASSIGN
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: SUB_ASSIGN
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: MUL_ASSIGN
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: DIV_ASSIGN
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: AND_ASSIGN
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: OR_ASSIGN
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: XOR_ASSIGN
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: MOD_ASSIGN
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: COMMA
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: RBRACE
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: RBRACK
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: COLON
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: SEMI
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: LBRACE
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: ENUM
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: INTERFACE
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: CLASS
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: NATIVE
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: PROTECTED
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: PRIVATE
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: PUBLIC
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: VOLATILE
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: TRANSIENT
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: STRICTFP
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: ABSTRACT
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: FINAL
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: STATIC
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: AT
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: TEMPLATE
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: BANG
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: TILDE
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: NEW
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: DOUBLE
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: FLOAT
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: LONG
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: INT
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: SHORT
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: BYTE
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: CHAR
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: BOOLEAN
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: VOID
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: NullLiteral
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: BooleanLiteral
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: StringLiteral
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: CharacterLiteral
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: FloatingPointLiteral
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: IntegerLiteral
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: SUPER
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: THIS
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: Identifier
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: CONTINUE
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: BREAK
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: THROW
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: RETURN
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: SYNCHRONIZED
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: SWITCH
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: TRY
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: DO
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: WHILE
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: FOR
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: IF
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: ASSERT
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: ELSE
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: DEFAULT
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 239, token: CASE
  reduce by rule: expression -> expression DOT qualifiedName
  reduce by rule: expression -> expression DOT qualifiedName
Conflict at state: 240, token: DOT
  reduce by rule: expression -> expression DOT SUPER
  shift token (then go to state 339)
Conflict at state: 240, token: LPAREN
  reduce by rule: expression -> expression DOT SUPER
  shift token (then go to state 341)
Conflict at state: 243, token: Identifier
  reduce by rule: optionalNonWildcardTypeArguments -> 
  shift token (then go to state 49)
Conflict at state: 245, token: RBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 345)
Conflict at state: 245, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 151)
Conflict at state: 245, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 152)
Conflict at state: 245, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 245, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 245, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 245, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 172)
Conflict at state: 245, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 245, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 245, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 245, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 245, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 158)
Conflict at state: 245, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 159)
Conflict at state: 245, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 245, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 245, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 245, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 245, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 245, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 245, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 163)
Conflict at state: 245, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 245, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 165)
Conflict at state: 245, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 245, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 245, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 245, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 245, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 245, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 245, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 245, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 245, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 245, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 245, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 245, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 245, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 245, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 245, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 246, token: LPAREN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: LBRACK
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: DOT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: RPAREN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: RBRACE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: COMMA
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: SEMI
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: MOD_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: LSHIFT_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: URSHIFT_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: RSHIFT_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: XOR_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: OR_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: AND_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: DIV_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: MUL_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: SUB_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: ADD_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: QUESTION
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: OR
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: AND
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: BITOR
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: CARET
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: BITAND
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: NOTEQUAL
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: EQUAL
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: INSTANCEOF
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: LT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: GE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: LE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: GT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: LSHIFT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: SUB
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: ADD
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: MOD
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: DIV
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: MUL
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: DEC
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: INC
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: COLON
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: RBRACK
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: WHILE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: ASSERT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: IF
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: FOR
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: DO
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: TRY
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: SWITCH
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: SYNCHRONIZED
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: RETURN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: THROW
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: BREAK
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: CONTINUE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: Identifier
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: THIS
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: SUPER
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: IntegerLiteral
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: FloatingPointLiteral
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: CharacterLiteral
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: StringLiteral
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: BooleanLiteral
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: NullLiteral
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: VOID
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: BOOLEAN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: CHAR
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: BYTE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: SHORT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: INT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: LONG
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: FLOAT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: DOUBLE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: NEW
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: TILDE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: BANG
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: TEMPLATE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: AT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: STATIC
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: FINAL
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: ABSTRACT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: STRICTFP
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: TRANSIENT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: VOLATILE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: PUBLIC
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: PRIVATE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: PROTECTED
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: NATIVE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: CLASS
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: INTERFACE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: ENUM
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: LBRACE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: DEFAULT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: CASE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 246, token: ELSE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression LPAREN RPAREN
Conflict at state: 248, token: DOT
  reduce by rule: expressionList -> expression
  shift token (then go to state 151)
Conflict at state: 248, token: LBRACK
  reduce by rule: expressionList -> expression
  shift token (then go to state 152)
Conflict at state: 248, token: LPAREN
  reduce by rule: expressionList -> expression
  shift token (then go to state 154)
Conflict at state: 248, token: INC
  reduce by rule: expressionList -> expression
  shift token (then go to state 170)
Conflict at state: 248, token: DEC
  reduce by rule: expressionList -> expression
  shift token (then go to state 171)
Conflict at state: 248, token: MUL
  reduce by rule: expressionList -> expression
  shift token (then go to state 172)
Conflict at state: 248, token: DIV
  reduce by rule: expressionList -> expression
  shift token (then go to state 173)
Conflict at state: 248, token: MOD
  reduce by rule: expressionList -> expression
  shift token (then go to state 174)
Conflict at state: 248, token: ADD
  reduce by rule: expressionList -> expression
  shift token (then go to state 175)
Conflict at state: 248, token: SUB
  reduce by rule: expressionList -> expression
  shift token (then go to state 176)
Conflict at state: 248, token: LSHIFT
  reduce by rule: expressionList -> expression
  shift token (then go to state 158)
Conflict at state: 248, token: GT
  reduce by rule: expressionList -> expression
  shift token (then go to state 159)
Conflict at state: 248, token: LE
  reduce by rule: expressionList -> expression
  shift token (then go to state 177)
Conflict at state: 248, token: GE
  reduce by rule: expressionList -> expression
  shift token (then go to state 178)
Conflict at state: 248, token: LT
  reduce by rule: expressionList -> expression
  shift token (then go to state 179)
Conflict at state: 248, token: INSTANCEOF
  reduce by rule: expressionList -> expression
  shift token (then go to state 161)
Conflict at state: 248, token: EQUAL
  reduce by rule: expressionList -> expression
  shift token (then go to state 180)
Conflict at state: 248, token: NOTEQUAL
  reduce by rule: expressionList -> expression
  shift token (then go to state 181)
Conflict at state: 248, token: BITAND
  reduce by rule: expressionList -> expression
  shift token (then go to state 163)
Conflict at state: 248, token: CARET
  reduce by rule: expressionList -> expression
  shift token (then go to state 164)
Conflict at state: 248, token: BITOR
  reduce by rule: expressionList -> expression
  shift token (then go to state 165)
Conflict at state: 248, token: AND
  reduce by rule: expressionList -> expression
  shift token (then go to state 166)
Conflict at state: 248, token: OR
  reduce by rule: expressionList -> expression
  shift token (then go to state 167)
Conflict at state: 248, token: QUESTION
  reduce by rule: expressionList -> expression
  shift token (then go to state 168)
Conflict at state: 248, token: ASSIGN
  reduce by rule: expressionList -> expression
  shift token (then go to state 182)
Conflict at state: 248, token: ADD_ASSIGN
  reduce by rule: expressionList -> expression
  shift token (then go to state 183)
Conflict at state: 248, token: SUB_ASSIGN
  reduce by rule: expressionList -> expression
  shift token (then go to state 184)
Conflict at state: 248, token: MUL_ASSIGN
  reduce by rule: expressionList -> expression
  shift token (then go to state 185)
Conflict at state: 248, token: DIV_ASSIGN
  reduce by rule: expressionList -> expression
  shift token (then go to state 186)
Conflict at state: 248, token: AND_ASSIGN
  reduce by rule: expressionList -> expression
  shift token (then go to state 187)
Conflict at state: 248, token: OR_ASSIGN
  reduce by rule: expressionList -> expression
  shift token (then go to state 188)
Conflict at state: 248, token: XOR_ASSIGN
  reduce by rule: expressionList -> expression
  shift token (then go to state 189)
Conflict at state: 248, token: RSHIFT_ASSIGN
  reduce by rule: expressionList -> expression
  shift token (then go to state 190)
Conflict at state: 248, token: URSHIFT_ASSIGN
  reduce by rule: expressionList -> expression
  shift token (then go to state 191)
Conflict at state: 248, token: LSHIFT_ASSIGN
  reduce by rule: expressionList -> expression
  shift token (then go to state 192)
Conflict at state: 248, token: MOD_ASSIGN
  reduce by rule: expressionList -> expression
  shift token (then go to state 193)
Conflict at state: 248, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: expressionList -> expression
Conflict at state: 248, token: COMMA
  reduce by rule: expression -> expression
  reduce by rule: expressionList -> expression
Conflict at state: 248, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 151)
Conflict at state: 248, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 152)
Conflict at state: 248, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 248, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 248, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 248, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 172)
Conflict at state: 248, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 248, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 248, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 248, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 248, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 158)
Conflict at state: 248, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 159)
Conflict at state: 248, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 248, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 248, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 248, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 248, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 248, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 248, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 163)
Conflict at state: 248, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 248, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 165)
Conflict at state: 248, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 248, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 248, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 248, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 248, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 248, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 248, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 248, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 248, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 248, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 248, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 248, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 248, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 248, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 248, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 248, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: expressionList -> expression
Conflict at state: 249, token: DOT
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 151)
Conflict at state: 249, token: LBRACK
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 152)
Conflict at state: 249, token: LPAREN
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 154)
Conflict at state: 249, token: INC
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 170)
Conflict at state: 249, token: DEC
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 171)
Conflict at state: 249, token: MUL
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 172)
Conflict at state: 249, token: DIV
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 173)
Conflict at state: 249, token: MOD
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 174)
Conflict at state: 249, token: ADD
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 175)
Conflict at state: 249, token: SUB
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 176)
Conflict at state: 249, token: LSHIFT
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 158)
Conflict at state: 249, token: GT
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 159)
Conflict at state: 249, token: LE
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 177)
Conflict at state: 249, token: GE
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 178)
Conflict at state: 249, token: LT
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 179)
Conflict at state: 249, token: INSTANCEOF
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 161)
Conflict at state: 249, token: EQUAL
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 180)
Conflict at state: 249, token: NOTEQUAL
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 181)
Conflict at state: 249, token: BITAND
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 163)
Conflict at state: 249, token: CARET
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 164)
Conflict at state: 249, token: BITOR
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 165)
Conflict at state: 249, token: AND
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 166)
Conflict at state: 249, token: OR
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 167)
Conflict at state: 249, token: QUESTION
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 168)
Conflict at state: 249, token: ASSIGN
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 182)
Conflict at state: 249, token: ADD_ASSIGN
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 183)
Conflict at state: 249, token: SUB_ASSIGN
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 184)
Conflict at state: 249, token: MUL_ASSIGN
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 185)
Conflict at state: 249, token: DIV_ASSIGN
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 186)
Conflict at state: 249, token: AND_ASSIGN
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 187)
Conflict at state: 249, token: OR_ASSIGN
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 188)
Conflict at state: 249, token: XOR_ASSIGN
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 189)
Conflict at state: 249, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 190)
Conflict at state: 249, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 191)
Conflict at state: 249, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 192)
Conflict at state: 249, token: MOD_ASSIGN
  reduce by rule: expression -> expression mulDivOrMod expression
  shift token (then go to state 193)
Conflict at state: 249, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 249, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 249, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 172)
Conflict at state: 249, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 249, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 249, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 249, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 152)
Conflict at state: 249, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 151)
Conflict at state: 249, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: RBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: COMMA
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: RBRACK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 249, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 249, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 158)
Conflict at state: 249, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 159)
Conflict at state: 249, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 249, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 249, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 249, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 249, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 249, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 249, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 163)
Conflict at state: 249, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 249, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 165)
Conflict at state: 249, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 249, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 249, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 249, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 249, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 249, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 249, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 249, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 249, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 249, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 249, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 249, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 249, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 249, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 249, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 249, token: COLON
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: LBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: ENUM
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: INTERFACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: CLASS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: NATIVE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: PROTECTED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: PRIVATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: PUBLIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: VOLATILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: TRANSIENT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: STRICTFP
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: ABSTRACT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: FINAL
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: STATIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: AT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: TEMPLATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: BANG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: TILDE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: NEW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: DOUBLE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: FLOAT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: LONG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: INT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: SHORT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: BYTE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: CHAR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: BOOLEAN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: VOID
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: NullLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: BooleanLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: StringLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: CharacterLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: FloatingPointLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: IntegerLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: SUPER
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: THIS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: Identifier
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: CONTINUE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: BREAK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: THROW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: RETURN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: SYNCHRONIZED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: SWITCH
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: TRY
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: DO
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: WHILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: FOR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: IF
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: ASSERT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: ELSE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: DEFAULT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 249, token: CASE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression mulDivOrMod expression
Conflict at state: 250, token: DOT
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 151)
Conflict at state: 250, token: LBRACK
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 152)
Conflict at state: 250, token: LPAREN
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 154)
Conflict at state: 250, token: INC
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 170)
Conflict at state: 250, token: DEC
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 171)
Conflict at state: 250, token: MUL
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 172)
Conflict at state: 250, token: DIV
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 173)
Conflict at state: 250, token: MOD
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 174)
Conflict at state: 250, token: ADD
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 175)
Conflict at state: 250, token: SUB
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 176)
Conflict at state: 250, token: LSHIFT
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 158)
Conflict at state: 250, token: GT
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 159)
Conflict at state: 250, token: LE
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 177)
Conflict at state: 250, token: GE
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 178)
Conflict at state: 250, token: LT
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 179)
Conflict at state: 250, token: INSTANCEOF
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 161)
Conflict at state: 250, token: EQUAL
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 180)
Conflict at state: 250, token: NOTEQUAL
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 181)
Conflict at state: 250, token: BITAND
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 163)
Conflict at state: 250, token: CARET
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 164)
Conflict at state: 250, token: BITOR
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 165)
Conflict at state: 250, token: AND
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 166)
Conflict at state: 250, token: OR
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 167)
Conflict at state: 250, token: QUESTION
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 168)
Conflict at state: 250, token: ASSIGN
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 182)
Conflict at state: 250, token: ADD_ASSIGN
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 183)
Conflict at state: 250, token: SUB_ASSIGN
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 184)
Conflict at state: 250, token: MUL_ASSIGN
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 185)
Conflict at state: 250, token: DIV_ASSIGN
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 186)
Conflict at state: 250, token: AND_ASSIGN
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 187)
Conflict at state: 250, token: OR_ASSIGN
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 188)
Conflict at state: 250, token: XOR_ASSIGN
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 189)
Conflict at state: 250, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 190)
Conflict at state: 250, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 191)
Conflict at state: 250, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 192)
Conflict at state: 250, token: MOD_ASSIGN
  reduce by rule: expression -> expression addOrSub expression
  shift token (then go to state 193)
Conflict at state: 250, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 250, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 250, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 250, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 250, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 172)
Conflict at state: 250, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 250, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 250, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 250, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 152)
Conflict at state: 250, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 151)
Conflict at state: 250, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: RBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: COMMA
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: RBRACK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 158)
Conflict at state: 250, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 159)
Conflict at state: 250, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 250, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 250, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 250, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 250, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 250, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 250, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 163)
Conflict at state: 250, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 250, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 165)
Conflict at state: 250, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 250, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 250, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 250, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 250, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 250, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 250, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 250, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 250, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 250, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 250, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 250, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 250, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 250, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 250, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 250, token: COLON
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: LBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: ENUM
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: INTERFACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: CLASS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: NATIVE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: PROTECTED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: PRIVATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: PUBLIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: VOLATILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: TRANSIENT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: STRICTFP
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: ABSTRACT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: FINAL
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: STATIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: AT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: TEMPLATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: BANG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: TILDE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: NEW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: DOUBLE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: FLOAT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: LONG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: INT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: SHORT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: BYTE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: CHAR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: BOOLEAN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: VOID
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: NullLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: BooleanLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: StringLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: CharacterLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: FloatingPointLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: IntegerLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: SUPER
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: THIS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: Identifier
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: CONTINUE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: BREAK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: THROW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: RETURN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: SYNCHRONIZED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: SWITCH
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: TRY
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: DO
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: WHILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: FOR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: IF
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: ASSERT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: ELSE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: DEFAULT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 250, token: CASE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression addOrSub expression
Conflict at state: 251, token: DOT
  reduce by rule: expression -> expression LSHIFT expression
  shift token (then go to state 151)
Conflict at state: 251, token: LBRACK
  reduce by rule: expression -> expression LSHIFT expression
  shift token (then go to state 152)
Conflict at state: 251, token: LPAREN
  reduce by rule: expression -> expression LSHIFT expression
  shift token (then go to state 154)
Conflict at state: 251, token: INC
  reduce by rule: expression -> expression LSHIFT expression
  shift token (then go to state 170)
Conflict at state: 251, token: DEC
  reduce by rule: expression -> expression LSHIFT expression
  shift token (then go to state 171)
Conflict at state: 251, token: GT
  reduce by rule: expression -> expression LSHIFT expression
  shift token (then go to state 159)
Conflict at state: 251, token: LE
  reduce by rule: expression -> expression LSHIFT expression
  shift token (then go to state 177)
Conflict at state: 251, token: GE
  reduce by rule: expression -> expression LSHIFT expression
  shift token (then go to state 178)
Conflict at state: 251, token: LT
  reduce by rule: expression -> expression LSHIFT expression
  shift token (then go to state 179)
Conflict at state: 251, token: INSTANCEOF
  reduce by rule: expression -> expression LSHIFT expression
  shift token (then go to state 161)
Conflict at state: 251, token: EQUAL
  reduce by rule: expression -> expression LSHIFT expression
  shift token (then go to state 180)
Conflict at state: 251, token: NOTEQUAL
  reduce by rule: expression -> expression LSHIFT expression
  shift token (then go to state 181)
Conflict at state: 251, token: BITAND
  reduce by rule: expression -> expression LSHIFT expression
  shift token (then go to state 163)
Conflict at state: 251, token: CARET
  reduce by rule: expression -> expression LSHIFT expression
  shift token (then go to state 164)
Conflict at state: 251, token: BITOR
  reduce by rule: expression -> expression LSHIFT expression
  shift token (then go to state 165)
Conflict at state: 251, token: AND
  reduce by rule: expression -> expression LSHIFT expression
  shift token (then go to state 166)
Conflict at state: 251, token: OR
  reduce by rule: expression -> expression LSHIFT expression
  shift token (then go to state 167)
Conflict at state: 251, token: QUESTION
  reduce by rule: expression -> expression LSHIFT expression
  shift token (then go to state 168)
Conflict at state: 251, token: LSHIFT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 251, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 251, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 251, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 251, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 172)
Conflict at state: 251, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 251, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 251, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 251, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 152)
Conflict at state: 251, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 151)
Conflict at state: 251, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: RBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: COMMA
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: RBRACK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 159)
Conflict at state: 251, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 251, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 251, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 251, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 251, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 251, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 251, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 163)
Conflict at state: 251, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 251, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 165)
Conflict at state: 251, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 251, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 251, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 251, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 251, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 251, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 251, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 251, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 251, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 251, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 251, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 251, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 251, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 251, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 251, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 251, token: COLON
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: LBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: ENUM
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: INTERFACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: CLASS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: NATIVE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: PROTECTED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: PRIVATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: PUBLIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: VOLATILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: TRANSIENT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: STRICTFP
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: ABSTRACT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: FINAL
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: STATIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: AT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: TEMPLATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: BANG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: TILDE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: NEW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: DOUBLE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: FLOAT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: LONG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: INT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: SHORT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: BYTE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: CHAR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: BOOLEAN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: VOID
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: NullLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: BooleanLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: StringLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: CharacterLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: FloatingPointLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: IntegerLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: SUPER
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: THIS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: Identifier
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: CONTINUE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: BREAK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: THROW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: RETURN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: SYNCHRONIZED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: SWITCH
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: TRY
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: DO
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: WHILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: FOR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: IF
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: ASSERT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: ELSE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: DEFAULT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 251, token: CASE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression LSHIFT expression
Conflict at state: 253, token: DOT
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 151)
Conflict at state: 253, token: LBRACK
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 152)
Conflict at state: 253, token: LPAREN
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 154)
Conflict at state: 253, token: INC
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 170)
Conflict at state: 253, token: DEC
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 171)
Conflict at state: 253, token: MUL
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 172)
Conflict at state: 253, token: DIV
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 173)
Conflict at state: 253, token: MOD
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 174)
Conflict at state: 253, token: ADD
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 175)
Conflict at state: 253, token: SUB
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 176)
Conflict at state: 253, token: LSHIFT
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 158)
Conflict at state: 253, token: GT
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 159)
Conflict at state: 253, token: LE
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 177)
Conflict at state: 253, token: GE
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 178)
Conflict at state: 253, token: LT
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 179)
Conflict at state: 253, token: INSTANCEOF
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 161)
Conflict at state: 253, token: EQUAL
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 180)
Conflict at state: 253, token: NOTEQUAL
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 181)
Conflict at state: 253, token: BITAND
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 163)
Conflict at state: 253, token: CARET
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 164)
Conflict at state: 253, token: BITOR
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 165)
Conflict at state: 253, token: AND
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 166)
Conflict at state: 253, token: OR
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 167)
Conflict at state: 253, token: QUESTION
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 168)
Conflict at state: 253, token: ASSIGN
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 182)
Conflict at state: 253, token: ADD_ASSIGN
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 183)
Conflict at state: 253, token: SUB_ASSIGN
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 184)
Conflict at state: 253, token: MUL_ASSIGN
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 185)
Conflict at state: 253, token: DIV_ASSIGN
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 186)
Conflict at state: 253, token: AND_ASSIGN
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 187)
Conflict at state: 253, token: OR_ASSIGN
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 188)
Conflict at state: 253, token: XOR_ASSIGN
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 189)
Conflict at state: 253, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 190)
Conflict at state: 253, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 191)
Conflict at state: 253, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 192)
Conflict at state: 253, token: MOD_ASSIGN
  reduce by rule: expression -> expression lE_GE_LT_GT expression
  shift token (then go to state 193)
Conflict at state: 253, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 253, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 253, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 253, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 159)
Conflict at state: 253, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 158)
Conflict at state: 253, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 253, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 253, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 253, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 253, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 172)
Conflict at state: 253, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 253, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 253, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 253, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 152)
Conflict at state: 253, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 151)
Conflict at state: 253, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: RBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: COMMA
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: RBRACK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 253, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 253, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 253, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 163)
Conflict at state: 253, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 253, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 165)
Conflict at state: 253, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 253, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 253, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 253, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 253, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 253, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 253, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 253, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 253, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 253, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 253, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 253, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 253, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 253, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 253, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 253, token: COLON
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: LBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: ENUM
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: INTERFACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: CLASS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: NATIVE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: PROTECTED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: PRIVATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: PUBLIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: VOLATILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: TRANSIENT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: STRICTFP
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: ABSTRACT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: FINAL
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: STATIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: AT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: TEMPLATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: BANG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: TILDE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: NEW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: DOUBLE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: FLOAT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: LONG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: INT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: SHORT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: BYTE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: CHAR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: BOOLEAN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: VOID
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: NullLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: BooleanLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: StringLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: CharacterLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: FloatingPointLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: IntegerLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: SUPER
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: THIS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: Identifier
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: CONTINUE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: BREAK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: THROW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: RETURN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: SYNCHRONIZED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: SWITCH
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: TRY
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: DO
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: WHILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: FOR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: IF
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: ASSERT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: ELSE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: DEFAULT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 253, token: CASE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression lE_GE_LT_GT expression
Conflict at state: 255, token: DOT
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 151)
Conflict at state: 255, token: LBRACK
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 152)
Conflict at state: 255, token: LPAREN
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 154)
Conflict at state: 255, token: INC
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 170)
Conflict at state: 255, token: DEC
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 171)
Conflict at state: 255, token: MUL
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 172)
Conflict at state: 255, token: DIV
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 173)
Conflict at state: 255, token: MOD
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 174)
Conflict at state: 255, token: ADD
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 175)
Conflict at state: 255, token: SUB
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 176)
Conflict at state: 255, token: LSHIFT
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 158)
Conflict at state: 255, token: GT
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 159)
Conflict at state: 255, token: LE
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 177)
Conflict at state: 255, token: GE
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 178)
Conflict at state: 255, token: LT
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 179)
Conflict at state: 255, token: INSTANCEOF
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 161)
Conflict at state: 255, token: EQUAL
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 180)
Conflict at state: 255, token: NOTEQUAL
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 181)
Conflict at state: 255, token: BITAND
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 163)
Conflict at state: 255, token: CARET
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 164)
Conflict at state: 255, token: BITOR
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 165)
Conflict at state: 255, token: AND
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 166)
Conflict at state: 255, token: OR
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 167)
Conflict at state: 255, token: QUESTION
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 168)
Conflict at state: 255, token: ASSIGN
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 182)
Conflict at state: 255, token: ADD_ASSIGN
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 183)
Conflict at state: 255, token: SUB_ASSIGN
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 184)
Conflict at state: 255, token: MUL_ASSIGN
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 185)
Conflict at state: 255, token: DIV_ASSIGN
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 186)
Conflict at state: 255, token: AND_ASSIGN
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 187)
Conflict at state: 255, token: OR_ASSIGN
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 188)
Conflict at state: 255, token: XOR_ASSIGN
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 189)
Conflict at state: 255, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 190)
Conflict at state: 255, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 191)
Conflict at state: 255, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 192)
Conflict at state: 255, token: MOD_ASSIGN
  reduce by rule: expression -> expression equals_NotEqual expression
  shift token (then go to state 193)
Conflict at state: 255, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 255, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 255, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 255, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 255, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 255, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 255, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 159)
Conflict at state: 255, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 158)
Conflict at state: 255, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 255, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 255, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 255, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 255, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 172)
Conflict at state: 255, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 255, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 255, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 255, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 152)
Conflict at state: 255, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 151)
Conflict at state: 255, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: RBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: COMMA
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: RBRACK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 163)
Conflict at state: 255, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 255, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 165)
Conflict at state: 255, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 255, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 255, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 255, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 255, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 255, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 255, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 255, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 255, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 255, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 255, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 255, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 255, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 255, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 255, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 255, token: COLON
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: LBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: ENUM
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: INTERFACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: CLASS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: NATIVE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: PROTECTED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: PRIVATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: PUBLIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: VOLATILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: TRANSIENT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: STRICTFP
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: ABSTRACT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: FINAL
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: STATIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: AT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: TEMPLATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: BANG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: TILDE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: NEW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: DOUBLE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: FLOAT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: LONG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: INT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: SHORT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: BYTE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: CHAR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: BOOLEAN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: VOID
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: NullLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: BooleanLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: StringLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: CharacterLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: FloatingPointLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: IntegerLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: SUPER
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: THIS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: Identifier
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: CONTINUE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: BREAK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: THROW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: RETURN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: SYNCHRONIZED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: SWITCH
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: TRY
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: DO
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: WHILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: FOR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: IF
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: ASSERT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: ELSE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: DEFAULT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 255, token: CASE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression equals_NotEqual expression
Conflict at state: 256, token: DOT
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 151)
Conflict at state: 256, token: LBRACK
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 152)
Conflict at state: 256, token: LPAREN
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 154)
Conflict at state: 256, token: INC
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 170)
Conflict at state: 256, token: DEC
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 171)
Conflict at state: 256, token: MUL
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 172)
Conflict at state: 256, token: DIV
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 173)
Conflict at state: 256, token: MOD
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 174)
Conflict at state: 256, token: ADD
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 175)
Conflict at state: 256, token: SUB
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 176)
Conflict at state: 256, token: LSHIFT
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 158)
Conflict at state: 256, token: GT
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 159)
Conflict at state: 256, token: LE
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 177)
Conflict at state: 256, token: GE
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 178)
Conflict at state: 256, token: LT
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 179)
Conflict at state: 256, token: INSTANCEOF
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 161)
Conflict at state: 256, token: EQUAL
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 180)
Conflict at state: 256, token: NOTEQUAL
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 181)
Conflict at state: 256, token: BITAND
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 163)
Conflict at state: 256, token: CARET
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 164)
Conflict at state: 256, token: BITOR
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 165)
Conflict at state: 256, token: AND
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 166)
Conflict at state: 256, token: OR
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 167)
Conflict at state: 256, token: QUESTION
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 168)
Conflict at state: 256, token: ASSIGN
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 182)
Conflict at state: 256, token: ADD_ASSIGN
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 183)
Conflict at state: 256, token: SUB_ASSIGN
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 184)
Conflict at state: 256, token: MUL_ASSIGN
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 185)
Conflict at state: 256, token: DIV_ASSIGN
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 186)
Conflict at state: 256, token: AND_ASSIGN
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 187)
Conflict at state: 256, token: OR_ASSIGN
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 188)
Conflict at state: 256, token: XOR_ASSIGN
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 189)
Conflict at state: 256, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 190)
Conflict at state: 256, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 191)
Conflict at state: 256, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 192)
Conflict at state: 256, token: MOD_ASSIGN
  reduce by rule: expression -> expression BITAND expression
  shift token (then go to state 193)
Conflict at state: 256, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 163)
Conflict at state: 256, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 256, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 256, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 256, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 256, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 256, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 256, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 159)
Conflict at state: 256, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 158)
Conflict at state: 256, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 256, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 256, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 256, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 256, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 172)
Conflict at state: 256, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 256, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 256, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 256, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 152)
Conflict at state: 256, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 151)
Conflict at state: 256, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: RBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: COMMA
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: RBRACK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 256, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 165)
Conflict at state: 256, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 256, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 256, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 256, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 256, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 256, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 256, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 256, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 256, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 256, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 256, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 256, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 256, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 256, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 256, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 256, token: COLON
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: LBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: ENUM
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: INTERFACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: CLASS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: NATIVE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: PROTECTED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: PRIVATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: PUBLIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: VOLATILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: TRANSIENT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: STRICTFP
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: ABSTRACT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: FINAL
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: STATIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: AT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: TEMPLATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: BANG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: TILDE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: NEW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: DOUBLE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: FLOAT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: LONG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: INT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: SHORT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: BYTE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: CHAR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: BOOLEAN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: VOID
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: NullLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: BooleanLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: StringLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: CharacterLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: FloatingPointLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: IntegerLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: SUPER
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: THIS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: Identifier
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: CONTINUE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: BREAK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: THROW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: RETURN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: SYNCHRONIZED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: SWITCH
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: TRY
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: DO
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: WHILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: FOR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: IF
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: ASSERT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: ELSE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: DEFAULT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 256, token: CASE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITAND expression
Conflict at state: 257, token: DOT
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 151)
Conflict at state: 257, token: LBRACK
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 152)
Conflict at state: 257, token: LPAREN
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 154)
Conflict at state: 257, token: INC
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 170)
Conflict at state: 257, token: DEC
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 171)
Conflict at state: 257, token: MUL
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 172)
Conflict at state: 257, token: DIV
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 173)
Conflict at state: 257, token: MOD
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 174)
Conflict at state: 257, token: ADD
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 175)
Conflict at state: 257, token: SUB
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 176)
Conflict at state: 257, token: LSHIFT
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 158)
Conflict at state: 257, token: GT
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 159)
Conflict at state: 257, token: LE
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 177)
Conflict at state: 257, token: GE
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 178)
Conflict at state: 257, token: LT
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 179)
Conflict at state: 257, token: INSTANCEOF
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 161)
Conflict at state: 257, token: EQUAL
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 180)
Conflict at state: 257, token: NOTEQUAL
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 181)
Conflict at state: 257, token: BITAND
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 163)
Conflict at state: 257, token: CARET
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 164)
Conflict at state: 257, token: BITOR
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 165)
Conflict at state: 257, token: AND
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 166)
Conflict at state: 257, token: OR
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 167)
Conflict at state: 257, token: QUESTION
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 168)
Conflict at state: 257, token: ASSIGN
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 182)
Conflict at state: 257, token: ADD_ASSIGN
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 183)
Conflict at state: 257, token: SUB_ASSIGN
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 184)
Conflict at state: 257, token: MUL_ASSIGN
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 185)
Conflict at state: 257, token: DIV_ASSIGN
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 186)
Conflict at state: 257, token: AND_ASSIGN
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 187)
Conflict at state: 257, token: OR_ASSIGN
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 188)
Conflict at state: 257, token: XOR_ASSIGN
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 189)
Conflict at state: 257, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 190)
Conflict at state: 257, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 191)
Conflict at state: 257, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 192)
Conflict at state: 257, token: MOD_ASSIGN
  reduce by rule: expression -> expression CARET expression
  shift token (then go to state 193)
Conflict at state: 257, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 257, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 163)
Conflict at state: 257, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 257, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 257, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 257, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 257, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 257, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 257, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 159)
Conflict at state: 257, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 158)
Conflict at state: 257, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 257, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 257, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 257, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 257, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 172)
Conflict at state: 257, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 257, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 257, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 257, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 152)
Conflict at state: 257, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 151)
Conflict at state: 257, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: RBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: COMMA
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: RBRACK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 165)
Conflict at state: 257, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 257, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 257, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 257, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 257, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 257, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 257, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 257, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 257, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 257, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 257, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 257, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 257, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 257, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 257, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 257, token: COLON
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: LBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: ENUM
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: INTERFACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: CLASS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: NATIVE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: PROTECTED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: PRIVATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: PUBLIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: VOLATILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: TRANSIENT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: STRICTFP
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: ABSTRACT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: FINAL
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: STATIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: AT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: TEMPLATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: BANG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: TILDE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: NEW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: DOUBLE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: FLOAT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: LONG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: INT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: SHORT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: BYTE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: CHAR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: BOOLEAN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: VOID
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: NullLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: BooleanLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: StringLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: CharacterLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: FloatingPointLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: IntegerLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: SUPER
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: THIS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: Identifier
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: CONTINUE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: BREAK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: THROW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: RETURN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: SYNCHRONIZED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: SWITCH
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: TRY
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: DO
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: WHILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: FOR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: IF
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: ASSERT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: ELSE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: DEFAULT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 257, token: CASE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression CARET expression
Conflict at state: 258, token: DOT
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 151)
Conflict at state: 258, token: LBRACK
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 152)
Conflict at state: 258, token: LPAREN
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 154)
Conflict at state: 258, token: INC
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 170)
Conflict at state: 258, token: DEC
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 171)
Conflict at state: 258, token: MUL
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 172)
Conflict at state: 258, token: DIV
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 173)
Conflict at state: 258, token: MOD
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 174)
Conflict at state: 258, token: ADD
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 175)
Conflict at state: 258, token: SUB
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 176)
Conflict at state: 258, token: LSHIFT
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 158)
Conflict at state: 258, token: GT
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 159)
Conflict at state: 258, token: LE
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 177)
Conflict at state: 258, token: GE
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 178)
Conflict at state: 258, token: LT
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 179)
Conflict at state: 258, token: INSTANCEOF
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 161)
Conflict at state: 258, token: EQUAL
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 180)
Conflict at state: 258, token: NOTEQUAL
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 181)
Conflict at state: 258, token: BITAND
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 163)
Conflict at state: 258, token: CARET
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 164)
Conflict at state: 258, token: BITOR
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 165)
Conflict at state: 258, token: AND
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 166)
Conflict at state: 258, token: OR
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 167)
Conflict at state: 258, token: QUESTION
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 168)
Conflict at state: 258, token: ASSIGN
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 182)
Conflict at state: 258, token: ADD_ASSIGN
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 183)
Conflict at state: 258, token: SUB_ASSIGN
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 184)
Conflict at state: 258, token: MUL_ASSIGN
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 185)
Conflict at state: 258, token: DIV_ASSIGN
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 186)
Conflict at state: 258, token: AND_ASSIGN
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 187)
Conflict at state: 258, token: OR_ASSIGN
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 188)
Conflict at state: 258, token: XOR_ASSIGN
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 189)
Conflict at state: 258, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 190)
Conflict at state: 258, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 191)
Conflict at state: 258, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 192)
Conflict at state: 258, token: MOD_ASSIGN
  reduce by rule: expression -> expression BITOR expression
  shift token (then go to state 193)
Conflict at state: 258, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 165)
Conflict at state: 258, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 258, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 163)
Conflict at state: 258, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 258, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 258, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 258, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 258, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 258, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 258, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 159)
Conflict at state: 258, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 158)
Conflict at state: 258, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 258, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 258, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 258, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 258, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 172)
Conflict at state: 258, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 258, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 258, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 258, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 152)
Conflict at state: 258, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 151)
Conflict at state: 258, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: RBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: COMMA
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: RBRACK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 258, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 258, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 258, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 258, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 258, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 258, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 258, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 258, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 258, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 258, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 258, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 258, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 258, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 258, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 258, token: COLON
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: LBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: ENUM
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: INTERFACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: CLASS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: NATIVE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: PROTECTED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: PRIVATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: PUBLIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: VOLATILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: TRANSIENT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: STRICTFP
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: ABSTRACT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: FINAL
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: STATIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: AT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: TEMPLATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: BANG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: TILDE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: NEW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: DOUBLE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: FLOAT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: LONG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: INT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: SHORT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: BYTE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: CHAR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: BOOLEAN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: VOID
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: NullLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: BooleanLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: StringLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: CharacterLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: FloatingPointLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: IntegerLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: SUPER
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: THIS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: Identifier
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: CONTINUE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: BREAK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: THROW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: RETURN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: SYNCHRONIZED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: SWITCH
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: TRY
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: DO
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: WHILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: FOR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: IF
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: ASSERT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: ELSE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: DEFAULT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 258, token: CASE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression BITOR expression
Conflict at state: 259, token: DOT
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 151)
Conflict at state: 259, token: LBRACK
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 152)
Conflict at state: 259, token: LPAREN
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 154)
Conflict at state: 259, token: INC
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 170)
Conflict at state: 259, token: DEC
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 171)
Conflict at state: 259, token: MUL
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 172)
Conflict at state: 259, token: DIV
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 173)
Conflict at state: 259, token: MOD
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 174)
Conflict at state: 259, token: ADD
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 175)
Conflict at state: 259, token: SUB
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 176)
Conflict at state: 259, token: LSHIFT
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 158)
Conflict at state: 259, token: GT
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 159)
Conflict at state: 259, token: LE
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 177)
Conflict at state: 259, token: GE
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 178)
Conflict at state: 259, token: LT
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 179)
Conflict at state: 259, token: INSTANCEOF
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 161)
Conflict at state: 259, token: EQUAL
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 180)
Conflict at state: 259, token: NOTEQUAL
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 181)
Conflict at state: 259, token: BITAND
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 163)
Conflict at state: 259, token: CARET
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 164)
Conflict at state: 259, token: BITOR
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 165)
Conflict at state: 259, token: AND
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 166)
Conflict at state: 259, token: OR
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 167)
Conflict at state: 259, token: QUESTION
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 168)
Conflict at state: 259, token: ASSIGN
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 182)
Conflict at state: 259, token: ADD_ASSIGN
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 183)
Conflict at state: 259, token: SUB_ASSIGN
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 184)
Conflict at state: 259, token: MUL_ASSIGN
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 185)
Conflict at state: 259, token: DIV_ASSIGN
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 186)
Conflict at state: 259, token: AND_ASSIGN
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 187)
Conflict at state: 259, token: OR_ASSIGN
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 188)
Conflict at state: 259, token: XOR_ASSIGN
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 189)
Conflict at state: 259, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 190)
Conflict at state: 259, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 191)
Conflict at state: 259, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 192)
Conflict at state: 259, token: MOD_ASSIGN
  reduce by rule: expression -> expression AND expression
  shift token (then go to state 193)
Conflict at state: 259, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 259, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 165)
Conflict at state: 259, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 259, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 163)
Conflict at state: 259, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 259, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 259, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 259, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 259, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 259, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 259, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 159)
Conflict at state: 259, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 158)
Conflict at state: 259, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 259, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 259, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 259, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 259, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 172)
Conflict at state: 259, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 259, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 259, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 259, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 152)
Conflict at state: 259, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 151)
Conflict at state: 259, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: RBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: COMMA
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: RBRACK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 259, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 259, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 259, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 259, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 259, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 259, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 259, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 259, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 259, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 259, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 259, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 259, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 259, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 259, token: COLON
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: LBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: ENUM
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: INTERFACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: CLASS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: NATIVE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: PROTECTED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: PRIVATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: PUBLIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: VOLATILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: TRANSIENT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: STRICTFP
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: ABSTRACT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: FINAL
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: STATIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: AT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: TEMPLATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: BANG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: TILDE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: NEW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: DOUBLE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: FLOAT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: LONG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: INT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: SHORT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: BYTE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: CHAR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: BOOLEAN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: VOID
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: NullLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: BooleanLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: StringLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: CharacterLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: FloatingPointLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: IntegerLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: SUPER
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: THIS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: Identifier
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: CONTINUE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: BREAK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: THROW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: RETURN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: SYNCHRONIZED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: SWITCH
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: TRY
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: DO
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: WHILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: FOR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: IF
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: ASSERT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: ELSE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: DEFAULT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 259, token: CASE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression AND expression
Conflict at state: 260, token: DOT
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 151)
Conflict at state: 260, token: LBRACK
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 152)
Conflict at state: 260, token: LPAREN
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 154)
Conflict at state: 260, token: INC
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 170)
Conflict at state: 260, token: DEC
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 171)
Conflict at state: 260, token: MUL
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 172)
Conflict at state: 260, token: DIV
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 173)
Conflict at state: 260, token: MOD
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 174)
Conflict at state: 260, token: ADD
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 175)
Conflict at state: 260, token: SUB
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 176)
Conflict at state: 260, token: LSHIFT
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 158)
Conflict at state: 260, token: GT
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 159)
Conflict at state: 260, token: LE
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 177)
Conflict at state: 260, token: GE
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 178)
Conflict at state: 260, token: LT
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 179)
Conflict at state: 260, token: INSTANCEOF
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 161)
Conflict at state: 260, token: EQUAL
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 180)
Conflict at state: 260, token: NOTEQUAL
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 181)
Conflict at state: 260, token: BITAND
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 163)
Conflict at state: 260, token: CARET
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 164)
Conflict at state: 260, token: BITOR
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 165)
Conflict at state: 260, token: AND
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 166)
Conflict at state: 260, token: OR
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 167)
Conflict at state: 260, token: QUESTION
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 168)
Conflict at state: 260, token: ASSIGN
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 182)
Conflict at state: 260, token: ADD_ASSIGN
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 183)
Conflict at state: 260, token: SUB_ASSIGN
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 184)
Conflict at state: 260, token: MUL_ASSIGN
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 185)
Conflict at state: 260, token: DIV_ASSIGN
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 186)
Conflict at state: 260, token: AND_ASSIGN
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 187)
Conflict at state: 260, token: OR_ASSIGN
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 188)
Conflict at state: 260, token: XOR_ASSIGN
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 189)
Conflict at state: 260, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 190)
Conflict at state: 260, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 191)
Conflict at state: 260, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 192)
Conflict at state: 260, token: MOD_ASSIGN
  reduce by rule: expression -> expression OR expression
  shift token (then go to state 193)
Conflict at state: 260, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 260, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 260, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 165)
Conflict at state: 260, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 260, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 163)
Conflict at state: 260, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 260, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 260, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 260, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 260, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 260, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 260, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 159)
Conflict at state: 260, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 158)
Conflict at state: 260, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 260, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 260, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 260, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 260, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 172)
Conflict at state: 260, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 260, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 260, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 260, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 152)
Conflict at state: 260, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 151)
Conflict at state: 260, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: RBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: COMMA
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: RBRACK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 260, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 260, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 260, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 260, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 260, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 260, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 260, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 260, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 260, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 260, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 260, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 260, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 260, token: COLON
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: LBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: ENUM
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: INTERFACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: CLASS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: NATIVE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: PROTECTED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: PRIVATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: PUBLIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: VOLATILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: TRANSIENT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: STRICTFP
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: ABSTRACT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: FINAL
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: STATIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: AT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: TEMPLATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: BANG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: TILDE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: NEW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: DOUBLE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: FLOAT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: LONG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: INT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: SHORT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: BYTE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: CHAR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: BOOLEAN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: VOID
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: NullLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: BooleanLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: StringLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: CharacterLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: FloatingPointLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: IntegerLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: SUPER
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: THIS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: Identifier
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: CONTINUE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: BREAK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: THROW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: RETURN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: SYNCHRONIZED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: SWITCH
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: TRY
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: DO
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: WHILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: FOR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: IF
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: ASSERT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: ELSE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: DEFAULT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 260, token: CASE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression OR expression
Conflict at state: 261, token: COLON
  reduce by rule: expression -> expression
  shift token (then go to state 350)
Conflict at state: 261, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 151)
Conflict at state: 261, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 152)
Conflict at state: 261, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 261, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 261, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 261, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 172)
Conflict at state: 261, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 261, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 261, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 261, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 261, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 158)
Conflict at state: 261, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 159)
Conflict at state: 261, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 261, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 261, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 261, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 261, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 261, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 261, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 163)
Conflict at state: 261, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 261, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 165)
Conflict at state: 261, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 261, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 261, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 261, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 261, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 261, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 261, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 261, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 261, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 261, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 261, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 261, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 261, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 261, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 261, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 262, token: DOT
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 151)
Conflict at state: 262, token: LBRACK
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 152)
Conflict at state: 262, token: LPAREN
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 154)
Conflict at state: 262, token: INC
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 170)
Conflict at state: 262, token: DEC
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 171)
Conflict at state: 262, token: MUL
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 172)
Conflict at state: 262, token: DIV
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 173)
Conflict at state: 262, token: MOD
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 174)
Conflict at state: 262, token: ADD
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 175)
Conflict at state: 262, token: SUB
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 176)
Conflict at state: 262, token: LSHIFT
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 158)
Conflict at state: 262, token: GT
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 159)
Conflict at state: 262, token: LE
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 177)
Conflict at state: 262, token: GE
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 178)
Conflict at state: 262, token: LT
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 179)
Conflict at state: 262, token: INSTANCEOF
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 161)
Conflict at state: 262, token: EQUAL
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 180)
Conflict at state: 262, token: NOTEQUAL
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 181)
Conflict at state: 262, token: BITAND
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 163)
Conflict at state: 262, token: CARET
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 164)
Conflict at state: 262, token: BITOR
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 165)
Conflict at state: 262, token: AND
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 166)
Conflict at state: 262, token: OR
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 167)
Conflict at state: 262, token: QUESTION
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 168)
Conflict at state: 262, token: ASSIGN
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 182)
Conflict at state: 262, token: ADD_ASSIGN
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 183)
Conflict at state: 262, token: SUB_ASSIGN
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 184)
Conflict at state: 262, token: MUL_ASSIGN
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 185)
Conflict at state: 262, token: DIV_ASSIGN
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 186)
Conflict at state: 262, token: AND_ASSIGN
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 187)
Conflict at state: 262, token: OR_ASSIGN
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 188)
Conflict at state: 262, token: XOR_ASSIGN
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 189)
Conflict at state: 262, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 190)
Conflict at state: 262, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 191)
Conflict at state: 262, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 192)
Conflict at state: 262, token: MOD_ASSIGN
  reduce by rule: expression -> expression assignmentToken expression
  shift token (then go to state 193)
Conflict at state: 262, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 262, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 262, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 262, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 262, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 262, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 262, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 262, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 262, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 262, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 262, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 262, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 262, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 262, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 262, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 262, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 165)
Conflict at state: 262, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 262, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 163)
Conflict at state: 262, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 262, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 262, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 262, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 262, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 262, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 262, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 159)
Conflict at state: 262, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 158)
Conflict at state: 262, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 262, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 262, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 262, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 262, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 172)
Conflict at state: 262, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 262, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 262, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 262, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 152)
Conflict at state: 262, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 151)
Conflict at state: 262, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: RBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: COMMA
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: RBRACK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: COLON
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: LBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: ENUM
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: INTERFACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: CLASS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: NATIVE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: PROTECTED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: PRIVATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: PUBLIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: VOLATILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: TRANSIENT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: STRICTFP
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: ABSTRACT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: FINAL
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: STATIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: AT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: TEMPLATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: BANG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: TILDE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: NEW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: DOUBLE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: FLOAT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: LONG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: INT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: SHORT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: BYTE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: CHAR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: BOOLEAN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: VOID
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: NullLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: BooleanLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: StringLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: CharacterLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: FloatingPointLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: IntegerLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: SUPER
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: THIS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: Identifier
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: CONTINUE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: BREAK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: THROW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: RETURN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: SYNCHRONIZED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: SWITCH
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: TRY
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: DO
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: WHILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: FOR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: IF
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: ASSERT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: ELSE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: DEFAULT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 262, token: CASE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression assignmentToken expression
Conflict at state: 266, token: DOT
  reduce by rule: expression -> qualifiedName DOT SUPER
  shift token (then go to state 351)
Conflict at state: 273, token: RBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 354)
Conflict at state: 273, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 151)
Conflict at state: 273, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 152)
Conflict at state: 273, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 273, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 273, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 273, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 172)
Conflict at state: 273, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 273, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 273, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 273, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 273, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 158)
Conflict at state: 273, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 159)
Conflict at state: 273, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 273, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 273, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 273, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 273, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 273, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 273, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 163)
Conflict at state: 273, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 273, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 165)
Conflict at state: 273, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 273, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 273, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 273, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 273, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 273, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 273, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 273, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 273, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 273, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 273, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 273, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 273, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 273, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 273, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 284, token: RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: LPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: Identifier
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: THIS
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: SUPER
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: IntegerLiteral
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: FloatingPointLiteral
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: CharacterLiteral
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: StringLiteral
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: BooleanLiteral
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: NullLiteral
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: VOID
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: BOOLEAN
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: CHAR
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: BYTE
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: SHORT
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: INT
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: LONG
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: FLOAT
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: DOUBLE
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: NEW
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: ADD
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: SUB
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: INC
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: DEC
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: TILDE
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: BANG
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: TEMPLATE
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: COMMA
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: MOD_ASSIGN
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: LSHIFT_ASSIGN
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: URSHIFT_ASSIGN
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: RSHIFT_ASSIGN
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: XOR_ASSIGN
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: OR_ASSIGN
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: AND_ASSIGN
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: DIV_ASSIGN
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: MUL_ASSIGN
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: SUB_ASSIGN
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: ADD_ASSIGN
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: ASSIGN
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: QUESTION
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: OR
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: AND
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: BITOR
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: CARET
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: BITAND
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: NOTEQUAL
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: EQUAL
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: INSTANCEOF
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: LT
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: GE
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: LE
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: GT
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: LSHIFT
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: MOD
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: DIV
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: MUL
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: LBRACK
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: DOT
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: RBRACE
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: COLON
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: SEMI
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: RBRACK
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: WHILE
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: ASSERT
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: IF
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: FOR
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: DO
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: TRY
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: SWITCH
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: SYNCHRONIZED
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: RETURN
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: THROW
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: BREAK
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: CONTINUE
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: AT
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: STATIC
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: FINAL
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: ABSTRACT
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: STRICTFP
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: TRANSIENT
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: VOLATILE
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: PUBLIC
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: PRIVATE
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: PROTECTED
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: NATIVE
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: CLASS
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: INTERFACE
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: ENUM
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: LBRACE
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: DEFAULT
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: CASE
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 284, token: ELSE
  reduce by rule: parExpression -> LPAREN expression RPAREN
  reduce by rule: parExpression -> LPAREN expression RPAREN
Conflict at state: 294, token: LBRACK
  reduce by rule: arrayDimensionBracks -> 
  shift token (then go to state 366)
Conflict at state: 295, token: LBRACE
  reduce by rule: classCreatorRest -> arguments
  shift token (then go to state 317)
Conflict at state: 343, token: Identifier
  reduce by rule: optionalNonWildcardTypeArguments -> nonWildcardTypeArguments
  shift token (then go to state 49)
Conflict at state: 348, token: DOT
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 151)
Conflict at state: 348, token: LBRACK
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 152)
Conflict at state: 348, token: LPAREN
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 154)
Conflict at state: 348, token: INC
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 170)
Conflict at state: 348, token: DEC
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 171)
Conflict at state: 348, token: MUL
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 172)
Conflict at state: 348, token: DIV
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 173)
Conflict at state: 348, token: MOD
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 174)
Conflict at state: 348, token: ADD
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 175)
Conflict at state: 348, token: SUB
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 176)
Conflict at state: 348, token: LSHIFT
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 158)
Conflict at state: 348, token: GT
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 159)
Conflict at state: 348, token: LE
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 177)
Conflict at state: 348, token: GE
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 178)
Conflict at state: 348, token: LT
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 179)
Conflict at state: 348, token: INSTANCEOF
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 161)
Conflict at state: 348, token: EQUAL
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 180)
Conflict at state: 348, token: NOTEQUAL
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 181)
Conflict at state: 348, token: BITAND
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 163)
Conflict at state: 348, token: CARET
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 164)
Conflict at state: 348, token: BITOR
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 165)
Conflict at state: 348, token: AND
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 166)
Conflict at state: 348, token: OR
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 167)
Conflict at state: 348, token: QUESTION
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 168)
Conflict at state: 348, token: ASSIGN
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 182)
Conflict at state: 348, token: ADD_ASSIGN
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 183)
Conflict at state: 348, token: SUB_ASSIGN
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 184)
Conflict at state: 348, token: MUL_ASSIGN
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 185)
Conflict at state: 348, token: DIV_ASSIGN
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 186)
Conflict at state: 348, token: AND_ASSIGN
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 187)
Conflict at state: 348, token: OR_ASSIGN
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 188)
Conflict at state: 348, token: XOR_ASSIGN
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 189)
Conflict at state: 348, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 190)
Conflict at state: 348, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 191)
Conflict at state: 348, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 192)
Conflict at state: 348, token: MOD_ASSIGN
  reduce by rule: expression -> expression GT GT expression
  shift token (then go to state 193)
Conflict at state: 348, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 159)
Conflict at state: 348, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 158)
Conflict at state: 348, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 348, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 348, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 348, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 348, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 172)
Conflict at state: 348, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 348, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 348, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 348, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 152)
Conflict at state: 348, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 151)
Conflict at state: 348, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: RBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: COMMA
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: RBRACK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 348, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 348, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 348, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 348, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 348, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 348, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 163)
Conflict at state: 348, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 348, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 165)
Conflict at state: 348, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 348, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 348, token: COLON
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 348, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 348, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 348, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 348, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 348, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 348, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 348, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 348, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 348, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 348, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 348, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 348, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 348, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: LBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: ENUM
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: INTERFACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: CLASS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: NATIVE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: PROTECTED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: PRIVATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: PUBLIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: VOLATILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: TRANSIENT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: STRICTFP
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: ABSTRACT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: FINAL
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: STATIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: AT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: TEMPLATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: BANG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: TILDE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: NEW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: DOUBLE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: FLOAT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: LONG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: INT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: SHORT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: BYTE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: CHAR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: BOOLEAN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: VOID
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: NullLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: BooleanLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: StringLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: CharacterLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: FloatingPointLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: IntegerLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: SUPER
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: THIS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: Identifier
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: CONTINUE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: BREAK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: THROW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: RETURN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: SYNCHRONIZED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: SWITCH
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: TRY
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: DO
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: WHILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: FOR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: IF
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: ASSERT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: ELSE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: DEFAULT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 348, token: CASE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT expression
Conflict at state: 357, token: LPAREN
  reduce by rule: superSuffix -> DOT Identifier
  shift token (then go to state 279)
Conflict at state: 364, token: RBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 434)
Conflict at state: 364, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 151)
Conflict at state: 364, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 152)
Conflict at state: 364, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 364, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 364, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 364, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 172)
Conflict at state: 364, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 364, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 364, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 364, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 364, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 158)
Conflict at state: 364, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 159)
Conflict at state: 364, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 364, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 364, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 364, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 364, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 364, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 364, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 163)
Conflict at state: 364, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 364, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 165)
Conflict at state: 364, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 364, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 364, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 364, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 364, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 364, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 364, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 364, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 364, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 364, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 364, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 364, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 364, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 364, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 364, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 368, token: LBRACE
  reduce by rule: classCreatorRest -> LPAREN RPAREN
  shift token (then go to state 317)
Conflict at state: 368, token: RPAREN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: DOT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: LBRACK
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: LPAREN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: RBRACE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: DEC
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: INC
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: RBRACK
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: MOD
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: DIV
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: MUL
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: SUB
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: ADD
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: LSHIFT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: LT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: GE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: LE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: GT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: NOTEQUAL
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: EQUAL
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: INSTANCEOF
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: BITAND
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: CARET
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: BITOR
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: AND
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: OR
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: COLON
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: MOD_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: LSHIFT_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: URSHIFT_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: RSHIFT_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: XOR_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: OR_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: AND_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: DIV_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: MUL_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: SUB_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: ADD_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: QUESTION
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: COMMA
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: SEMI
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: WHILE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: ASSERT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: IF
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: FOR
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: DO
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: TRY
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: SWITCH
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: SYNCHRONIZED
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: RETURN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: THROW
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: BREAK
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: CONTINUE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: Identifier
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: THIS
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: SUPER
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: IntegerLiteral
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: FloatingPointLiteral
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: CharacterLiteral
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: StringLiteral
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: BooleanLiteral
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: NullLiteral
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: VOID
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: BOOLEAN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: CHAR
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: BYTE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: SHORT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: INT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: LONG
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: FLOAT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: DOUBLE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: NEW
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: TILDE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: BANG
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: TEMPLATE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: AT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: STATIC
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: FINAL
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: ABSTRACT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: STRICTFP
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: TRANSIENT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: VOLATILE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: PUBLIC
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: PRIVATE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: PROTECTED
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: NATIVE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: CLASS
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: INTERFACE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: ENUM
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: LBRACE
  reduce by rule: arguments -> LPAREN RPAREN
  shift token (then go to state 317)
Conflict at state: 368, token: DEFAULT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: CASE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 368, token: ELSE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: classCreatorRest -> LPAREN RPAREN
Conflict at state: 422, token: DOT
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 151)
Conflict at state: 422, token: LBRACK
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 152)
Conflict at state: 422, token: LPAREN
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 154)
Conflict at state: 422, token: INC
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 170)
Conflict at state: 422, token: DEC
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 171)
Conflict at state: 422, token: MUL
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 172)
Conflict at state: 422, token: DIV
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 173)
Conflict at state: 422, token: MOD
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 174)
Conflict at state: 422, token: ADD
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 175)
Conflict at state: 422, token: SUB
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 176)
Conflict at state: 422, token: LSHIFT
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 158)
Conflict at state: 422, token: GT
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 159)
Conflict at state: 422, token: LE
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 177)
Conflict at state: 422, token: GE
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 178)
Conflict at state: 422, token: LT
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 179)
Conflict at state: 422, token: INSTANCEOF
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 161)
Conflict at state: 422, token: EQUAL
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 180)
Conflict at state: 422, token: NOTEQUAL
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 181)
Conflict at state: 422, token: BITAND
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 163)
Conflict at state: 422, token: CARET
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 164)
Conflict at state: 422, token: BITOR
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 165)
Conflict at state: 422, token: AND
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 166)
Conflict at state: 422, token: OR
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 167)
Conflict at state: 422, token: QUESTION
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 168)
Conflict at state: 422, token: ASSIGN
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 182)
Conflict at state: 422, token: ADD_ASSIGN
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 183)
Conflict at state: 422, token: SUB_ASSIGN
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 184)
Conflict at state: 422, token: MUL_ASSIGN
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 185)
Conflict at state: 422, token: DIV_ASSIGN
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 186)
Conflict at state: 422, token: AND_ASSIGN
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 187)
Conflict at state: 422, token: OR_ASSIGN
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 188)
Conflict at state: 422, token: XOR_ASSIGN
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 189)
Conflict at state: 422, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 190)
Conflict at state: 422, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 191)
Conflict at state: 422, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 192)
Conflict at state: 422, token: MOD_ASSIGN
  reduce by rule: expression -> expression DOT SUPER DOT expression
  shift token (then go to state 193)
Conflict at state: 422, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 151)
Conflict at state: 422, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: RBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 152)
Conflict at state: 422, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 422, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 422, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 422, token: COMMA
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: RBRACK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 172)
Conflict at state: 422, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 422, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 422, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 422, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 422, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 158)
Conflict at state: 422, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 159)
Conflict at state: 422, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 422, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 422, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 422, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 422, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 422, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 422, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 163)
Conflict at state: 422, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 422, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 165)
Conflict at state: 422, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 422, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 422, token: COLON
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 422, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 422, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 422, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 422, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 422, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 422, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 422, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 422, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 422, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 422, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 422, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 422, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 422, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: LBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: ENUM
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: INTERFACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: CLASS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: NATIVE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: PROTECTED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: PRIVATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: PUBLIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: VOLATILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: TRANSIENT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: STRICTFP
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: ABSTRACT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: FINAL
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: STATIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: AT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: TEMPLATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: BANG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: TILDE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: NEW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: DOUBLE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: FLOAT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: LONG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: INT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: SHORT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: BYTE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: CHAR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: BOOLEAN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: VOID
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: NullLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: BooleanLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: StringLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: CharacterLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: FloatingPointLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: IntegerLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: SUPER
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: THIS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: Identifier
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: CONTINUE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: BREAK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: THROW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: RETURN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: SYNCHRONIZED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: SWITCH
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: TRY
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: DO
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: WHILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: FOR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: IF
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: ASSERT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: ELSE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: DEFAULT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 422, token: CASE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression DOT SUPER DOT expression
Conflict at state: 423, token: DOT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: RPAREN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: RBRACE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: LBRACK
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: LPAREN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: INC
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: DEC
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: COMMA
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: RBRACK
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: MUL
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: DIV
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: MOD
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: ADD
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: SUB
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: LSHIFT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: GT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: LE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: GE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: LT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: INSTANCEOF
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: EQUAL
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: NOTEQUAL
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: BITAND
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: CARET
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: BITOR
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: AND
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: OR
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: COLON
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: QUESTION
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: ADD_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: SUB_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: MUL_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: DIV_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: AND_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: OR_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: XOR_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: RSHIFT_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: URSHIFT_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: LSHIFT_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: MOD_ASSIGN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: SEMI
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: LBRACE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: ENUM
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: INTERFACE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: CLASS
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: NATIVE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: PROTECTED
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: PRIVATE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: PUBLIC
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: VOLATILE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: TRANSIENT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: STRICTFP
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: ABSTRACT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: FINAL
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: STATIC
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: AT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: TEMPLATE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: BANG
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: TILDE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: NEW
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: DOUBLE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: FLOAT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: LONG
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: INT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: SHORT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: BYTE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: CHAR
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: BOOLEAN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: VOID
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: NullLiteral
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: BooleanLiteral
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: StringLiteral
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: CharacterLiteral
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: FloatingPointLiteral
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: IntegerLiteral
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: SUPER
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: THIS
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: Identifier
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: CONTINUE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: BREAK
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: THROW
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: RETURN
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: SYNCHRONIZED
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: SWITCH
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: TRY
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: DO
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: WHILE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: FOR
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: IF
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: ASSERT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: ELSE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: DEFAULT
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 423, token: CASE
  reduce by rule: arguments -> LPAREN RPAREN
  reduce by rule: expression -> expression DOT SUPER LPAREN RPAREN
Conflict at state: 427, token: COMMA
  reduce by rule: expression -> expression
  reduce by rule: expressionList -> expressionList COMMA expression
Conflict at state: 427, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: expressionList -> expressionList COMMA expression
Conflict at state: 427, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 151)
Conflict at state: 427, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 152)
Conflict at state: 427, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 427, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 427, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 427, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 172)
Conflict at state: 427, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 427, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 427, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 427, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 427, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 158)
Conflict at state: 427, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 159)
Conflict at state: 427, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 427, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 427, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 427, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 427, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 427, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 427, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 163)
Conflict at state: 427, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 427, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 165)
Conflict at state: 427, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 427, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 427, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 427, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 427, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 427, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 427, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 427, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 427, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 427, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 427, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 427, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 427, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 427, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 427, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 427, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: expressionList -> expressionList COMMA expression
Conflict at state: 428, token: DOT
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 151)
Conflict at state: 428, token: LBRACK
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 152)
Conflict at state: 428, token: LPAREN
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 154)
Conflict at state: 428, token: INC
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 170)
Conflict at state: 428, token: DEC
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 171)
Conflict at state: 428, token: MUL
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 172)
Conflict at state: 428, token: DIV
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 173)
Conflict at state: 428, token: MOD
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 174)
Conflict at state: 428, token: ADD
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 175)
Conflict at state: 428, token: SUB
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 176)
Conflict at state: 428, token: LSHIFT
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 158)
Conflict at state: 428, token: GT
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 159)
Conflict at state: 428, token: LE
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 177)
Conflict at state: 428, token: GE
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 178)
Conflict at state: 428, token: LT
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 179)
Conflict at state: 428, token: INSTANCEOF
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 161)
Conflict at state: 428, token: EQUAL
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 180)
Conflict at state: 428, token: NOTEQUAL
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 181)
Conflict at state: 428, token: BITAND
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 163)
Conflict at state: 428, token: CARET
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 164)
Conflict at state: 428, token: BITOR
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 165)
Conflict at state: 428, token: AND
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 166)
Conflict at state: 428, token: OR
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 167)
Conflict at state: 428, token: QUESTION
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 168)
Conflict at state: 428, token: ASSIGN
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 182)
Conflict at state: 428, token: ADD_ASSIGN
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 183)
Conflict at state: 428, token: SUB_ASSIGN
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 184)
Conflict at state: 428, token: MUL_ASSIGN
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 185)
Conflict at state: 428, token: DIV_ASSIGN
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 186)
Conflict at state: 428, token: AND_ASSIGN
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 187)
Conflict at state: 428, token: OR_ASSIGN
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 188)
Conflict at state: 428, token: XOR_ASSIGN
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 189)
Conflict at state: 428, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 190)
Conflict at state: 428, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 191)
Conflict at state: 428, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 192)
Conflict at state: 428, token: MOD_ASSIGN
  reduce by rule: expression -> expression GT GT GT expression
  shift token (then go to state 193)
Conflict at state: 428, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 159)
Conflict at state: 428, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 158)
Conflict at state: 428, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 428, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 428, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 428, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 428, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 172)
Conflict at state: 428, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 428, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 428, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 428, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 152)
Conflict at state: 428, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 151)
Conflict at state: 428, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: RBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: COMMA
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: RBRACK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 428, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 428, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 428, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 428, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 428, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 428, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 163)
Conflict at state: 428, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 428, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 165)
Conflict at state: 428, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 428, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 428, token: COLON
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 428, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 428, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 428, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 428, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 428, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 428, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 428, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 428, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 428, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 428, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 428, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 428, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 428, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: LBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: ENUM
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: INTERFACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: CLASS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: NATIVE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: PROTECTED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: PRIVATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: PUBLIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: VOLATILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: TRANSIENT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: STRICTFP
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: ABSTRACT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: FINAL
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: STATIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: AT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: TEMPLATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: BANG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: TILDE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: NEW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: DOUBLE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: FLOAT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: LONG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: INT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: SHORT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: BYTE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: CHAR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: BOOLEAN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: VOID
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: NullLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: BooleanLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: StringLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: CharacterLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: FloatingPointLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: IntegerLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: SUPER
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: THIS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: Identifier
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: CONTINUE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: BREAK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: THROW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: RETURN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: SYNCHRONIZED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: SWITCH
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: TRY
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: DO
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: WHILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: FOR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: IF
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: ASSERT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: ELSE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: DEFAULT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 428, token: CASE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression GT GT GT expression
Conflict at state: 429, token: DOT
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 151)
Conflict at state: 429, token: LBRACK
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 152)
Conflict at state: 429, token: LPAREN
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 154)
Conflict at state: 429, token: INC
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 170)
Conflict at state: 429, token: DEC
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 171)
Conflict at state: 429, token: MUL
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 172)
Conflict at state: 429, token: DIV
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 173)
Conflict at state: 429, token: MOD
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 174)
Conflict at state: 429, token: ADD
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 175)
Conflict at state: 429, token: SUB
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 176)
Conflict at state: 429, token: LSHIFT
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 158)
Conflict at state: 429, token: GT
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 159)
Conflict at state: 429, token: LE
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 177)
Conflict at state: 429, token: GE
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 178)
Conflict at state: 429, token: LT
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 179)
Conflict at state: 429, token: INSTANCEOF
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 161)
Conflict at state: 429, token: EQUAL
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 180)
Conflict at state: 429, token: NOTEQUAL
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 181)
Conflict at state: 429, token: BITAND
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 163)
Conflict at state: 429, token: CARET
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 164)
Conflict at state: 429, token: BITOR
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 165)
Conflict at state: 429, token: AND
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 166)
Conflict at state: 429, token: OR
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 167)
Conflict at state: 429, token: QUESTION
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 168)
Conflict at state: 429, token: ASSIGN
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 182)
Conflict at state: 429, token: ADD_ASSIGN
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 183)
Conflict at state: 429, token: SUB_ASSIGN
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 184)
Conflict at state: 429, token: MUL_ASSIGN
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 185)
Conflict at state: 429, token: DIV_ASSIGN
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 186)
Conflict at state: 429, token: AND_ASSIGN
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 187)
Conflict at state: 429, token: OR_ASSIGN
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 188)
Conflict at state: 429, token: XOR_ASSIGN
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 189)
Conflict at state: 429, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 190)
Conflict at state: 429, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 191)
Conflict at state: 429, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 192)
Conflict at state: 429, token: MOD_ASSIGN
  reduce by rule: expression -> expression QUESTION expression COLON expression
  shift token (then go to state 193)
Conflict at state: 429, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 429, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 429, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 429, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 165)
Conflict at state: 429, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 429, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 163)
Conflict at state: 429, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 429, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 429, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 429, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 429, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 429, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 429, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 159)
Conflict at state: 429, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 158)
Conflict at state: 429, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 429, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 429, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 429, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 429, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 172)
Conflict at state: 429, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 429, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 429, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 429, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 152)
Conflict at state: 429, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 151)
Conflict at state: 429, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: RBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: COMMA
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: RBRACK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: COLON
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 429, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 429, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 429, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 429, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 429, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 429, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 429, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 429, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 429, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 429, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 429, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 429, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: LBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: ENUM
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: INTERFACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: CLASS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: NATIVE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: PROTECTED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: PRIVATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: PUBLIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: VOLATILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: TRANSIENT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: STRICTFP
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: ABSTRACT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: FINAL
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: STATIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: AT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: TEMPLATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: BANG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: TILDE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: NEW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: DOUBLE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: FLOAT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: LONG
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: INT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: SHORT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: BYTE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: CHAR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: BOOLEAN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: VOID
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: NullLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: BooleanLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: StringLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: CharacterLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: FloatingPointLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: IntegerLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: SUPER
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: THIS
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: Identifier
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: CONTINUE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: BREAK
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: THROW
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: RETURN
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: SYNCHRONIZED
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: SWITCH
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: TRY
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: DO
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: WHILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: FOR
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: IF
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: ASSERT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: ELSE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: DEFAULT
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 429, token: CASE
  reduce by rule: expression -> expression
  reduce by rule: expression -> expression QUESTION expression COLON expression
Conflict at state: 430, token: DOT
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 151)
Conflict at state: 430, token: LBRACK
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 152)
Conflict at state: 430, token: LPAREN
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 154)
Conflict at state: 430, token: INC
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 170)
Conflict at state: 430, token: DEC
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 171)
Conflict at state: 430, token: MUL
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 172)
Conflict at state: 430, token: DIV
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 173)
Conflict at state: 430, token: MOD
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 174)
Conflict at state: 430, token: ADD
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 175)
Conflict at state: 430, token: SUB
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 176)
Conflict at state: 430, token: LSHIFT
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 158)
Conflict at state: 430, token: GT
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 159)
Conflict at state: 430, token: LE
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 177)
Conflict at state: 430, token: GE
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 178)
Conflict at state: 430, token: LT
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 179)
Conflict at state: 430, token: INSTANCEOF
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 161)
Conflict at state: 430, token: EQUAL
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 180)
Conflict at state: 430, token: NOTEQUAL
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 181)
Conflict at state: 430, token: BITAND
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 163)
Conflict at state: 430, token: CARET
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 164)
Conflict at state: 430, token: BITOR
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 165)
Conflict at state: 430, token: AND
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 166)
Conflict at state: 430, token: OR
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 167)
Conflict at state: 430, token: QUESTION
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 168)
Conflict at state: 430, token: ASSIGN
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 182)
Conflict at state: 430, token: ADD_ASSIGN
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 183)
Conflict at state: 430, token: SUB_ASSIGN
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 184)
Conflict at state: 430, token: MUL_ASSIGN
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 185)
Conflict at state: 430, token: DIV_ASSIGN
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 186)
Conflict at state: 430, token: AND_ASSIGN
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 187)
Conflict at state: 430, token: OR_ASSIGN
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 188)
Conflict at state: 430, token: XOR_ASSIGN
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 189)
Conflict at state: 430, token: RSHIFT_ASSIGN
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 190)
Conflict at state: 430, token: URSHIFT_ASSIGN
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 191)
Conflict at state: 430, token: LSHIFT_ASSIGN
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 192)
Conflict at state: 430, token: MOD_ASSIGN
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
  shift token (then go to state 193)
Conflict at state: 430, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 151)
Conflict at state: 430, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: RBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 152)
Conflict at state: 430, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 430, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 430, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 430, token: COMMA
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: RBRACK
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 172)
Conflict at state: 430, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 430, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 430, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 430, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 430, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 158)
Conflict at state: 430, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 159)
Conflict at state: 430, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 430, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 430, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 430, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 430, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 430, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 430, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 163)
Conflict at state: 430, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 430, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 165)
Conflict at state: 430, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 430, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 430, token: COLON
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 430, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 430, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 430, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 430, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 430, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 430, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 430, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 430, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 430, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 430, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 430, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 430, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 430, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: LBRACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: ENUM
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: INTERFACE
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: CLASS
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: NATIVE
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: PROTECTED
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: PRIVATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: PUBLIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: VOLATILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: TRANSIENT
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: STRICTFP
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: ABSTRACT
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: FINAL
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: STATIC
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: AT
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: TEMPLATE
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: BANG
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: TILDE
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: NEW
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: DOUBLE
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: FLOAT
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: LONG
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: INT
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: SHORT
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: BYTE
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: CHAR
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: BOOLEAN
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: VOID
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: NullLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: BooleanLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: StringLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: CharacterLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: FloatingPointLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: IntegerLiteral
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: SUPER
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: THIS
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: Identifier
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: CONTINUE
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: BREAK
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: THROW
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: RETURN
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: SYNCHRONIZED
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: SWITCH
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: TRY
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: DO
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: WHILE
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: FOR
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: IF
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: ASSERT
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: ELSE
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: DEFAULT
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 430, token: CASE
  reduce by rule: expression -> expression
  reduce by rule: expression -> qualifiedName DOT SUPER DOT expression
Conflict at state: 435, token: RBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 511)
Conflict at state: 435, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 151)
Conflict at state: 435, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 152)
Conflict at state: 435, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 435, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 435, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 435, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 172)
Conflict at state: 435, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 435, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 435, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 435, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 435, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 158)
Conflict at state: 435, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 159)
Conflict at state: 435, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 435, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 435, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 435, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 435, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 435, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 435, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 163)
Conflict at state: 435, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 435, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 165)
Conflict at state: 435, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 435, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 435, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 435, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 435, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 435, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 435, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 435, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 435, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 435, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 435, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 435, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 435, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 435, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 435, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 481, token: SEMI
  reduce by rule: expression -> expression
  shift token (then go to state 563)
Conflict at state: 481, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 151)
Conflict at state: 481, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 152)
Conflict at state: 481, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 481, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 481, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 481, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 172)
Conflict at state: 481, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 481, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 481, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 481, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 481, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 158)
Conflict at state: 481, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 159)
Conflict at state: 481, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 481, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 481, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 481, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 481, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 481, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 481, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 163)
Conflict at state: 481, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 481, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 165)
Conflict at state: 481, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 481, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 481, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 481, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 481, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 481, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 481, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 481, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 481, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 481, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 481, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 481, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 481, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 481, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 481, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 484, token: DOT
  reduce by rule: expression -> qualifiedName
  shift token (then go to state 198)
Conflict at state: 484, token: LBRACK
  reduce by rule: expression -> qualifiedName
  shift token (then go to state 200)
Conflict at state: 494, token: SEMI
  reduce by rule: commentReturn -> 
  reduce by rule: arrayDimensionBracks -> 
Conflict at state: 494, token: THROWS
  reduce by rule: commentReturn -> 
  reduce by rule: arrayDimensionBracks -> 
Conflict at state: 497, token: SEMI
  reduce by rule: commentReturn -> 
  reduce by rule: arrayDimensionBracks -> 
Conflict at state: 497, token: THROWS
  reduce by rule: commentReturn -> 
  reduce by rule: arrayDimensionBracks -> 
Conflict at state: 520, token: DEC
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 171)
Conflict at state: 520, token: INC
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 170)
Conflict at state: 520, token: SUB
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 176)
Conflict at state: 520, token: ADD
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 175)
Conflict at state: 520, token: LPAREN
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 154)
Conflict at state: 520, token: DOT
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 151)
Conflict at state: 520, token: LBRACK
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 152)
Conflict at state: 520, token: MUL
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 172)
Conflict at state: 520, token: DIV
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 173)
Conflict at state: 520, token: MOD
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 174)
Conflict at state: 520, token: LSHIFT
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 158)
Conflict at state: 520, token: GT
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 159)
Conflict at state: 520, token: LE
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 177)
Conflict at state: 520, token: GE
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 178)
Conflict at state: 520, token: LT
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 179)
Conflict at state: 520, token: INSTANCEOF
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 161)
Conflict at state: 520, token: EQUAL
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 180)
Conflict at state: 520, token: NOTEQUAL
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 181)
Conflict at state: 520, token: BITAND
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 163)
Conflict at state: 520, token: CARET
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 164)
Conflict at state: 520, token: BITOR
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 165)
Conflict at state: 520, token: AND
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 166)
Conflict at state: 520, token: OR
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 167)
Conflict at state: 520, token: QUESTION
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 168)
Conflict at state: 520, token: ASSIGN
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 182)
Conflict at state: 520, token: ADD_ASSIGN
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 183)
Conflict at state: 520, token: SUB_ASSIGN
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 184)
Conflict at state: 520, token: MUL_ASSIGN
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 185)
Conflict at state: 520, token: DIV_ASSIGN
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 186)
Conflict at state: 520, token: AND_ASSIGN
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 187)
Conflict at state: 520, token: OR_ASSIGN
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 188)
Conflict at state: 520, token: XOR_ASSIGN
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 189)
Conflict at state: 520, token: RSHIFT_ASSIGN
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 190)
Conflict at state: 520, token: URSHIFT_ASSIGN
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 191)
Conflict at state: 520, token: LSHIFT_ASSIGN
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 192)
Conflict at state: 520, token: MOD_ASSIGN
  reduce by rule: variableInitializer -> expression
  shift token (then go to state 193)
Conflict at state: 520, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: COMMA
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: RBRACE
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: LBRACE
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: ENUM
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: INTERFACE
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: CLASS
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: NATIVE
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: PROTECTED
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: PRIVATE
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: PUBLIC
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: VOLATILE
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: TRANSIENT
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: STRICTFP
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: ABSTRACT
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: FINAL
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: STATIC
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: AT
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: TEMPLATE
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: BANG
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: TILDE
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 520, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 520, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 520, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 520, token: NEW
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: DOUBLE
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: FLOAT
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: LONG
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: INT
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: SHORT
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: BYTE
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: CHAR
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: BOOLEAN
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: VOID
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: NullLiteral
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: BooleanLiteral
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: StringLiteral
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: CharacterLiteral
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: FloatingPointLiteral
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: IntegerLiteral
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: SUPER
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: THIS
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 520, token: Identifier
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: CONTINUE
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: BREAK
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: THROW
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: RETURN
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: SYNCHRONIZED
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: SWITCH
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: TRY
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: DO
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: WHILE
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: FOR
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: IF
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: ASSERT
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: ELSE
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: DEFAULT
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: CASE
  reduce by rule: expression -> expression
  reduce by rule: variableInitializer -> expression
Conflict at state: 520, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 151)
Conflict at state: 520, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 152)
Conflict at state: 520, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 172)
Conflict at state: 520, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 520, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 520, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 158)
Conflict at state: 520, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 159)
Conflict at state: 520, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 520, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 520, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 520, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 520, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 520, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 520, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 163)
Conflict at state: 520, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 520, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 165)
Conflict at state: 520, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 520, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 520, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 520, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 520, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 520, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 520, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 520, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 520, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 520, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 520, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 520, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 520, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 520, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 520, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 524, token: LBRACE
  reduce by rule: commentReturn -> 
  reduce by rule: arrayDimensionBracks -> 
Conflict at state: 524, token: THROWS
  reduce by rule: commentReturn -> 
  reduce by rule: arrayDimensionBracks -> 
Conflict at state: 524, token: SEMI
  reduce by rule: commentReturn -> 
  reduce by rule: arrayDimensionBracks -> 
Conflict at state: 525, token: LBRACE
  reduce by rule: commentReturn -> 
  reduce by rule: arrayDimensionBracks -> 
Conflict at state: 525, token: THROWS
  reduce by rule: commentReturn -> 
  reduce by rule: arrayDimensionBracks -> 
Conflict at state: 525, token: SEMI
  reduce by rule: commentReturn -> 
  reduce by rule: arrayDimensionBracks -> 
Conflict at state: 546, token: COLON
  reduce by rule: assertExpression -> expression
  shift token (then go to state 613)
Conflict at state: 546, token: DOT
  reduce by rule: assertExpression -> expression
  shift token (then go to state 151)
Conflict at state: 546, token: LBRACK
  reduce by rule: assertExpression -> expression
  shift token (then go to state 152)
Conflict at state: 546, token: LPAREN
  reduce by rule: assertExpression -> expression
  shift token (then go to state 154)
Conflict at state: 546, token: INC
  reduce by rule: assertExpression -> expression
  shift token (then go to state 170)
Conflict at state: 546, token: DEC
  reduce by rule: assertExpression -> expression
  shift token (then go to state 171)
Conflict at state: 546, token: MUL
  reduce by rule: assertExpression -> expression
  shift token (then go to state 172)
Conflict at state: 546, token: DIV
  reduce by rule: assertExpression -> expression
  shift token (then go to state 173)
Conflict at state: 546, token: MOD
  reduce by rule: assertExpression -> expression
  shift token (then go to state 174)
Conflict at state: 546, token: ADD
  reduce by rule: assertExpression -> expression
  shift token (then go to state 175)
Conflict at state: 546, token: SUB
  reduce by rule: assertExpression -> expression
  shift token (then go to state 176)
Conflict at state: 546, token: LSHIFT
  reduce by rule: assertExpression -> expression
  shift token (then go to state 158)
Conflict at state: 546, token: GT
  reduce by rule: assertExpression -> expression
  shift token (then go to state 159)
Conflict at state: 546, token: LE
  reduce by rule: assertExpression -> expression
  shift token (then go to state 177)
Conflict at state: 546, token: GE
  reduce by rule: assertExpression -> expression
  shift token (then go to state 178)
Conflict at state: 546, token: LT
  reduce by rule: assertExpression -> expression
  shift token (then go to state 179)
Conflict at state: 546, token: INSTANCEOF
  reduce by rule: assertExpression -> expression
  shift token (then go to state 161)
Conflict at state: 546, token: EQUAL
  reduce by rule: assertExpression -> expression
  shift token (then go to state 180)
Conflict at state: 546, token: NOTEQUAL
  reduce by rule: assertExpression -> expression
  shift token (then go to state 181)
Conflict at state: 546, token: BITAND
  reduce by rule: assertExpression -> expression
  shift token (then go to state 163)
Conflict at state: 546, token: CARET
  reduce by rule: assertExpression -> expression
  shift token (then go to state 164)
Conflict at state: 546, token: BITOR
  reduce by rule: assertExpression -> expression
  shift token (then go to state 165)
Conflict at state: 546, token: AND
  reduce by rule: assertExpression -> expression
  shift token (then go to state 166)
Conflict at state: 546, token: OR
  reduce by rule: assertExpression -> expression
  shift token (then go to state 167)
Conflict at state: 546, token: QUESTION
  reduce by rule: assertExpression -> expression
  shift token (then go to state 168)
Conflict at state: 546, token: ASSIGN
  reduce by rule: assertExpression -> expression
  shift token (then go to state 182)
Conflict at state: 546, token: ADD_ASSIGN
  reduce by rule: assertExpression -> expression
  shift token (then go to state 183)
Conflict at state: 546, token: SUB_ASSIGN
  reduce by rule: assertExpression -> expression
  shift token (then go to state 184)
Conflict at state: 546, token: MUL_ASSIGN
  reduce by rule: assertExpression -> expression
  shift token (then go to state 185)
Conflict at state: 546, token: DIV_ASSIGN
  reduce by rule: assertExpression -> expression
  shift token (then go to state 186)
Conflict at state: 546, token: AND_ASSIGN
  reduce by rule: assertExpression -> expression
  shift token (then go to state 187)
Conflict at state: 546, token: OR_ASSIGN
  reduce by rule: assertExpression -> expression
  shift token (then go to state 188)
Conflict at state: 546, token: XOR_ASSIGN
  reduce by rule: assertExpression -> expression
  shift token (then go to state 189)
Conflict at state: 546, token: RSHIFT_ASSIGN
  reduce by rule: assertExpression -> expression
  shift token (then go to state 190)
Conflict at state: 546, token: URSHIFT_ASSIGN
  reduce by rule: assertExpression -> expression
  shift token (then go to state 191)
Conflict at state: 546, token: LSHIFT_ASSIGN
  reduce by rule: assertExpression -> expression
  shift token (then go to state 192)
Conflict at state: 546, token: MOD_ASSIGN
  reduce by rule: assertExpression -> expression
  shift token (then go to state 193)
Conflict at state: 546, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: assertExpression -> expression
Conflict at state: 546, token: COLON
  reduce by rule: expression -> expression
  shift token (then go to state 613)
Conflict at state: 546, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 151)
Conflict at state: 546, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 152)
Conflict at state: 546, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 546, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 546, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 546, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 172)
Conflict at state: 546, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 546, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 546, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 546, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 546, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 158)
Conflict at state: 546, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 159)
Conflict at state: 546, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 546, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 546, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 546, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 546, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 546, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 546, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 163)
Conflict at state: 546, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 546, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 165)
Conflict at state: 546, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 546, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 546, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 546, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 546, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 546, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 546, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 546, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 546, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 546, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 546, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 546, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 546, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 546, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 546, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 557, token: SEMI
  reduce by rule: expression -> expression
  shift token (then go to state 640)
Conflict at state: 557, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 151)
Conflict at state: 557, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 152)
Conflict at state: 557, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 557, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 557, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 557, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 172)
Conflict at state: 557, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 557, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 557, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 557, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 557, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 158)
Conflict at state: 557, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 159)
Conflict at state: 557, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 557, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 557, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 557, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 557, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 557, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 557, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 163)
Conflict at state: 557, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 557, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 165)
Conflict at state: 557, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 557, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 557, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 557, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 557, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 557, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 557, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 557, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 557, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 557, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 557, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 557, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 557, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 557, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 557, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 558, token: SEMI
  reduce by rule: expression -> expression
  shift token (then go to state 641)
Conflict at state: 558, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 151)
Conflict at state: 558, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 152)
Conflict at state: 558, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 558, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 558, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 558, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 172)
Conflict at state: 558, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 558, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 558, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 558, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 558, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 158)
Conflict at state: 558, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 159)
Conflict at state: 558, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 558, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 558, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 558, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 558, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 558, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 558, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 163)
Conflict at state: 558, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 558, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 165)
Conflict at state: 558, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 558, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 558, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 558, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 558, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 558, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 558, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 558, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 558, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 558, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 558, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 558, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 558, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 558, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 558, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 574, token: SEMI
  reduce by rule: commentReturn -> 
  reduce by rule: throwsList -> 
Conflict at state: 578, token: SEMI
  reduce by rule: commentReturn -> 
  reduce by rule: throwsList -> 
Conflict at state: 580, token: SEMI
  reduce by rule: commentReturn -> 
  reduce by rule: arrayDimensionBracks -> 
Conflict at state: 580, token: THROWS
  reduce by rule: commentReturn -> 
  reduce by rule: arrayDimensionBracks -> 
Conflict at state: 581, token: SEMI
  reduce by rule: commentReturn -> 
  reduce by rule: arrayDimensionBracks -> 
Conflict at state: 581, token: THROWS
  reduce by rule: commentReturn -> 
  reduce by rule: arrayDimensionBracks -> 
Conflict at state: 593, token: LBRACE
  reduce by rule: commentReturn -> 
  reduce by rule: throwsList -> 
Conflict at state: 593, token: SEMI
  reduce by rule: commentReturn -> 
  reduce by rule: throwsList -> 
Conflict at state: 595, token: LBRACE
  reduce by rule: commentReturn -> 
  reduce by rule: throwsList -> 
Conflict at state: 595, token: SEMI
  reduce by rule: commentReturn -> 
  reduce by rule: throwsList -> 
Conflict at state: 598, token: LBRACE
  reduce by rule: commentReturn -> 
  reduce by rule: arrayDimensionBracks -> 
Conflict at state: 598, token: THROWS
  reduce by rule: commentReturn -> 
  reduce by rule: arrayDimensionBracks -> 
Conflict at state: 598, token: SEMI
  reduce by rule: commentReturn -> 
  reduce by rule: arrayDimensionBracks -> 
Conflict at state: 599, token: LBRACE
  reduce by rule: commentReturn -> 
  reduce by rule: arrayDimensionBracks -> 
Conflict at state: 599, token: THROWS
  reduce by rule: commentReturn -> 
  reduce by rule: arrayDimensionBracks -> 
Conflict at state: 599, token: SEMI
  reduce by rule: commentReturn -> 
  reduce by rule: arrayDimensionBracks -> 
Conflict at state: 614, token: RPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 686)
Conflict at state: 614, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 151)
Conflict at state: 614, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 152)
Conflict at state: 614, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 614, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 614, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 614, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 172)
Conflict at state: 614, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 614, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 614, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 614, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 614, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 158)
Conflict at state: 614, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 159)
Conflict at state: 614, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 614, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 614, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 614, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 614, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 614, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 614, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 163)
Conflict at state: 614, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 614, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 165)
Conflict at state: 614, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 614, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 614, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 614, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 614, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 614, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 614, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 614, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 614, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 614, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 614, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 614, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 614, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 614, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 614, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 624, token: RPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 695)
Conflict at state: 624, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 151)
Conflict at state: 624, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 152)
Conflict at state: 624, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 624, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 624, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 624, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 172)
Conflict at state: 624, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 624, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 624, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 624, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 624, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 158)
Conflict at state: 624, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 159)
Conflict at state: 624, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 624, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 624, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 624, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 624, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 624, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 624, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 163)
Conflict at state: 624, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 624, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 165)
Conflict at state: 624, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 624, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 624, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 624, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 624, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 624, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 624, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 624, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 624, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 624, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 624, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 624, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 624, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 624, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 624, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 638, token: RPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 709)
Conflict at state: 638, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 151)
Conflict at state: 638, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 152)
Conflict at state: 638, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 638, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 638, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 638, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 172)
Conflict at state: 638, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 638, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 638, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 638, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 638, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 158)
Conflict at state: 638, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 159)
Conflict at state: 638, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 638, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 638, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 638, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 638, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 638, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 638, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 163)
Conflict at state: 638, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 638, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 165)
Conflict at state: 638, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 638, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 638, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 638, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 638, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 638, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 638, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 638, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 638, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 638, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 638, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 638, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 638, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 638, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 638, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 639, token: RPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 710)
Conflict at state: 639, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 151)
Conflict at state: 639, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 152)
Conflict at state: 639, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 639, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 639, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 639, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 172)
Conflict at state: 639, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 639, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 639, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 639, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 639, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 158)
Conflict at state: 639, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 159)
Conflict at state: 639, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 639, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 639, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 639, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 639, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 639, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 639, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 163)
Conflict at state: 639, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 639, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 165)
Conflict at state: 639, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 639, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 639, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 639, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 639, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 639, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 639, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 639, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 639, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 639, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 639, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 639, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 639, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 639, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 639, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 654, token: SEMI
  reduce by rule: commentReturn -> 
  reduce by rule: throwsList -> 
Conflict at state: 656, token: SEMI
  reduce by rule: commentReturn -> 
  reduce by rule: throwsList -> 
Conflict at state: 673, token: LBRACE
  reduce by rule: commentReturn -> 
  reduce by rule: throwsList -> 
Conflict at state: 673, token: SEMI
  reduce by rule: commentReturn -> 
  reduce by rule: throwsList -> 
Conflict at state: 675, token: LBRACE
  reduce by rule: commentReturn -> 
  reduce by rule: throwsList -> 
Conflict at state: 675, token: SEMI
  reduce by rule: commentReturn -> 
  reduce by rule: throwsList -> 
Conflict at state: 685, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: assertExpression -> expression COLON expression
Conflict at state: 685, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 151)
Conflict at state: 685, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 152)
Conflict at state: 685, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 685, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 685, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 685, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 172)
Conflict at state: 685, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 685, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 685, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 685, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 685, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 158)
Conflict at state: 685, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 159)
Conflict at state: 685, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 685, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 685, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 685, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 685, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 685, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 685, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 163)
Conflict at state: 685, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 685, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 165)
Conflict at state: 685, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 685, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 685, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 685, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 685, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 685, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 685, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 685, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 685, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 685, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 685, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 685, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 685, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 685, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 685, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 690, token: DOT
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 151)
Conflict at state: 690, token: LBRACK
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 152)
Conflict at state: 690, token: LPAREN
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 154)
Conflict at state: 690, token: INC
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 170)
Conflict at state: 690, token: DEC
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 171)
Conflict at state: 690, token: MUL
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 172)
Conflict at state: 690, token: DIV
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 173)
Conflict at state: 690, token: MOD
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 174)
Conflict at state: 690, token: ADD
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 175)
Conflict at state: 690, token: SUB
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 176)
Conflict at state: 690, token: LSHIFT
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 158)
Conflict at state: 690, token: GT
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 159)
Conflict at state: 690, token: LE
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 177)
Conflict at state: 690, token: GE
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 178)
Conflict at state: 690, token: LT
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 179)
Conflict at state: 690, token: INSTANCEOF
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 161)
Conflict at state: 690, token: EQUAL
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 180)
Conflict at state: 690, token: NOTEQUAL
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 181)
Conflict at state: 690, token: BITAND
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 163)
Conflict at state: 690, token: CARET
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 164)
Conflict at state: 690, token: BITOR
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 165)
Conflict at state: 690, token: AND
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 166)
Conflict at state: 690, token: OR
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 167)
Conflict at state: 690, token: QUESTION
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 168)
Conflict at state: 690, token: ASSIGN
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 182)
Conflict at state: 690, token: ADD_ASSIGN
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 183)
Conflict at state: 690, token: SUB_ASSIGN
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 184)
Conflict at state: 690, token: MUL_ASSIGN
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 185)
Conflict at state: 690, token: DIV_ASSIGN
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 186)
Conflict at state: 690, token: AND_ASSIGN
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 187)
Conflict at state: 690, token: OR_ASSIGN
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 188)
Conflict at state: 690, token: XOR_ASSIGN
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 189)
Conflict at state: 690, token: RSHIFT_ASSIGN
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 190)
Conflict at state: 690, token: URSHIFT_ASSIGN
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 191)
Conflict at state: 690, token: LSHIFT_ASSIGN
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 192)
Conflict at state: 690, token: MOD_ASSIGN
  reduce by rule: optionalExpression -> expression
  shift token (then go to state 193)
Conflict at state: 690, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: optionalExpression -> expression
Conflict at state: 690, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 151)
Conflict at state: 690, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 152)
Conflict at state: 690, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 690, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 690, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 690, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 172)
Conflict at state: 690, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 690, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 690, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 690, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 690, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 158)
Conflict at state: 690, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 159)
Conflict at state: 690, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 690, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 690, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 690, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 690, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 690, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 690, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 163)
Conflict at state: 690, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 690, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 165)
Conflict at state: 690, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 690, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 690, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 690, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 690, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 690, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 690, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 690, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 690, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 690, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 690, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 690, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 690, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 690, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 690, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 702, token: RBRACE
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: LBRACE
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: SEMI
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: ENUM
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: INTERFACE
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: CLASS
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: NATIVE
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: PROTECTED
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: PRIVATE
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: PUBLIC
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: VOLATILE
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: TRANSIENT
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: STRICTFP
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: ABSTRACT
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: FINAL
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: STATIC
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: AT
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: TEMPLATE
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: BANG
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: TILDE
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: DEC
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: INC
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: SUB
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: ADD
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: NEW
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: DOUBLE
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: FLOAT
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: LONG
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: INT
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: SHORT
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: BYTE
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: CHAR
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: BOOLEAN
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: VOID
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: NullLiteral
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: BooleanLiteral
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: StringLiteral
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: CharacterLiteral
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: FloatingPointLiteral
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: IntegerLiteral
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: SUPER
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: THIS
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: LPAREN
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: Identifier
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: CONTINUE
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: BREAK
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: THROW
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: RETURN
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: SYNCHRONIZED
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: SWITCH
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: TRY
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: DO
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: WHILE
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: FOR
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: IF
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: ASSERT
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: ELSE
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: DEFAULT
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 702, token: CASE
  reduce by rule: optionalFinallyBlock -> 
  reduce by rule: statement -> TRY resourceSpecification block catchClauses
Conflict at state: 742, token: ELSE
  reduce by rule: optionalElseStatement -> 
  shift token (then go to state 778)
Conflict at state: 749, token: RPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 785)
Conflict at state: 749, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 151)
Conflict at state: 749, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 152)
Conflict at state: 749, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 749, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 749, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 749, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 172)
Conflict at state: 749, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 749, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 749, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 749, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 749, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 158)
Conflict at state: 749, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 159)
Conflict at state: 749, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 749, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 749, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 749, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 749, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 749, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 749, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 163)
Conflict at state: 749, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 749, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 165)
Conflict at state: 749, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 749, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 749, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 749, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 749, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 749, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 749, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 749, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 749, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 749, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 749, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 749, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 749, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 749, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 749, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 758, token: CASE
  reduce by rule: switchBlockStatementGroups -> 
  shift token (then go to state 796)
Conflict at state: 758, token: DEFAULT
  reduce by rule: switchBlockStatementGroups -> 
  shift token (then go to state 797)
Conflict at state: 784, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: enhancedForControl -> type variableDeclaratorId COLON expression
Conflict at state: 784, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 151)
Conflict at state: 784, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 152)
Conflict at state: 784, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 784, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 784, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 784, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 172)
Conflict at state: 784, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 784, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 784, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 784, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 784, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 158)
Conflict at state: 784, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 159)
Conflict at state: 784, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 784, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 784, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 784, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 784, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 784, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 784, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 163)
Conflict at state: 784, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 784, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 165)
Conflict at state: 784, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 784, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 784, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 784, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 784, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 784, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 784, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 784, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 784, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 784, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 784, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 784, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 784, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 784, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 784, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 790, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: resource -> classOrInterfaceType variableDeclaratorId ASSIGN expression
Conflict at state: 790, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: resource -> classOrInterfaceType variableDeclaratorId ASSIGN expression
Conflict at state: 790, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 151)
Conflict at state: 790, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 152)
Conflict at state: 790, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 790, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 790, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 790, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 172)
Conflict at state: 790, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 790, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 790, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 790, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 790, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 158)
Conflict at state: 790, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 159)
Conflict at state: 790, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 790, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 790, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 790, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 790, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 790, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 790, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 163)
Conflict at state: 790, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 790, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 165)
Conflict at state: 790, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 790, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 790, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 790, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 790, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 790, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 790, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 790, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 790, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 790, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 790, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 790, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 790, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 790, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 790, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 792, token: CASE
  reduce by rule: switchBlockStatementGroups -> switchBlockStatementGroupL
  shift token (then go to state 796)
Conflict at state: 792, token: DEFAULT
  reduce by rule: switchBlockStatementGroups -> switchBlockStatementGroupL
  shift token (then go to state 797)
Conflict at state: 794, token: CASE
  reduce by rule: switchBlockStatementGroup -> switchLabelL
  shift token (then go to state 796)
Conflict at state: 794, token: DEFAULT
  reduce by rule: switchBlockStatementGroup -> switchLabelL
  shift token (then go to state 797)
Conflict at state: 806, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: enhancedForControl -> modifierL type variableDeclaratorId COLON expression
Conflict at state: 806, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 151)
Conflict at state: 806, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 152)
Conflict at state: 806, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 806, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 806, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 806, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 172)
Conflict at state: 806, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 806, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 806, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 806, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 806, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 158)
Conflict at state: 806, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 159)
Conflict at state: 806, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 806, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 806, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 806, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 806, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 806, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 806, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 163)
Conflict at state: 806, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 806, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 165)
Conflict at state: 806, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 806, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 806, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 806, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 806, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 806, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 806, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 806, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 806, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 806, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 806, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 806, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 806, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 806, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 806, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 811, token: RPAREN
  reduce by rule: expression -> expression
  reduce by rule: resource -> variableModifiers classOrInterfaceType variableDeclaratorId ASSIGN expression
Conflict at state: 811, token: SEMI
  reduce by rule: expression -> expression
  reduce by rule: resource -> variableModifiers classOrInterfaceType variableDeclaratorId ASSIGN expression
Conflict at state: 811, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 151)
Conflict at state: 811, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 152)
Conflict at state: 811, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 811, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 811, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 811, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 172)
Conflict at state: 811, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 811, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 811, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 811, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 811, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 158)
Conflict at state: 811, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 159)
Conflict at state: 811, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 811, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 811, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 811, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 811, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 811, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 811, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 163)
Conflict at state: 811, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 811, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 165)
Conflict at state: 811, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 811, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 811, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 811, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 811, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 811, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 811, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 811, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 811, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 811, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 811, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 811, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 811, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 811, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 811, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)
Conflict at state: 817, token: COLON
  reduce by rule: expression -> expression
  shift token (then go to state 822)
Conflict at state: 817, token: DOT
  reduce by rule: expression -> expression
  shift token (then go to state 151)
Conflict at state: 817, token: LBRACK
  reduce by rule: expression -> expression
  shift token (then go to state 152)
Conflict at state: 817, token: LPAREN
  reduce by rule: expression -> expression
  shift token (then go to state 154)
Conflict at state: 817, token: INC
  reduce by rule: expression -> expression
  shift token (then go to state 170)
Conflict at state: 817, token: DEC
  reduce by rule: expression -> expression
  shift token (then go to state 171)
Conflict at state: 817, token: MUL
  reduce by rule: expression -> expression
  shift token (then go to state 172)
Conflict at state: 817, token: DIV
  reduce by rule: expression -> expression
  shift token (then go to state 173)
Conflict at state: 817, token: MOD
  reduce by rule: expression -> expression
  shift token (then go to state 174)
Conflict at state: 817, token: ADD
  reduce by rule: expression -> expression
  shift token (then go to state 175)
Conflict at state: 817, token: SUB
  reduce by rule: expression -> expression
  shift token (then go to state 176)
Conflict at state: 817, token: LSHIFT
  reduce by rule: expression -> expression
  shift token (then go to state 158)
Conflict at state: 817, token: GT
  reduce by rule: expression -> expression
  shift token (then go to state 159)
Conflict at state: 817, token: LE
  reduce by rule: expression -> expression
  shift token (then go to state 177)
Conflict at state: 817, token: GE
  reduce by rule: expression -> expression
  shift token (then go to state 178)
Conflict at state: 817, token: LT
  reduce by rule: expression -> expression
  shift token (then go to state 179)
Conflict at state: 817, token: INSTANCEOF
  reduce by rule: expression -> expression
  shift token (then go to state 161)
Conflict at state: 817, token: EQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 180)
Conflict at state: 817, token: NOTEQUAL
  reduce by rule: expression -> expression
  shift token (then go to state 181)
Conflict at state: 817, token: BITAND
  reduce by rule: expression -> expression
  shift token (then go to state 163)
Conflict at state: 817, token: CARET
  reduce by rule: expression -> expression
  shift token (then go to state 164)
Conflict at state: 817, token: BITOR
  reduce by rule: expression -> expression
  shift token (then go to state 165)
Conflict at state: 817, token: AND
  reduce by rule: expression -> expression
  shift token (then go to state 166)
Conflict at state: 817, token: OR
  reduce by rule: expression -> expression
  shift token (then go to state 167)
Conflict at state: 817, token: QUESTION
  reduce by rule: expression -> expression
  shift token (then go to state 168)
Conflict at state: 817, token: ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 182)
Conflict at state: 817, token: ADD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 183)
Conflict at state: 817, token: SUB_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 184)
Conflict at state: 817, token: MUL_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 185)
Conflict at state: 817, token: DIV_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 186)
Conflict at state: 817, token: AND_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 187)
Conflict at state: 817, token: OR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 188)
Conflict at state: 817, token: XOR_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 189)
Conflict at state: 817, token: RSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 190)
Conflict at state: 817, token: URSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 191)
Conflict at state: 817, token: LSHIFT_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 192)
Conflict at state: 817, token: MOD_ASSIGN
  reduce by rule: expression -> expression
  shift token (then go to state 193)

4334 Conflict(s) found in grammar.
Done.
