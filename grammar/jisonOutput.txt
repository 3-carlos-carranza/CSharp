Processing grammar.
$accept(0)
$end(1)
error(2)
compilationUnit(3)
es(4)
EOF(5)
e(6)
IF(7)
Unicode_escape_sequence(8)
REAL_LITERAL(9)
INTEGER_LITERAL(10)
OPEN_BRACE(11)
DOT(12)
IDENTIFIER(13)

Item sets
------

item set 0 
$accept -> .compilationUnit $end #lookaheads= $end
compilationUnit -> .es EOF
es -> .e
es -> .es e
e -> .IF
e -> .Unicode_escape_sequence
e -> .REAL_LITERAL
e -> .INTEGER_LITERAL
e -> .OPEN_BRACE
e -> .DOT
e -> .IDENTIFIER
e -> . 
transitions ->  {"compilationUnit":1,"es":2,"e":3,"IF":4,"Unicode_escape_sequence":5,"REAL_LITERAL":6,"INTEGER_LITERAL":7,"OPEN_BRACE":8,"DOT":9,"IDENTIFIER":10}

item set 1 
$accept -> compilationUnit .$end #lookaheads= $end 
transitions ->  {}

item set 2 
compilationUnit -> es .EOF
es -> es .e
e -> .IF
e -> .Unicode_escape_sequence
e -> .REAL_LITERAL
e -> .INTEGER_LITERAL
e -> .OPEN_BRACE
e -> .DOT
e -> .IDENTIFIER
e -> . 
transitions ->  {"EOF":11,"e":12,"IF":4,"Unicode_escape_sequence":5,"REAL_LITERAL":6,"INTEGER_LITERAL":7,"OPEN_BRACE":8,"DOT":9,"IDENTIFIER":10}

item set 3 
es -> e . 
transitions ->  {}

item set 4 
e -> IF . 
transitions ->  {}

item set 5 
e -> Unicode_escape_sequence . 
transitions ->  {}

item set 6 
e -> REAL_LITERAL . 
transitions ->  {}

item set 7 
e -> INTEGER_LITERAL . 
transitions ->  {}

item set 8 
e -> OPEN_BRACE . 
transitions ->  {}

item set 9 
e -> DOT . 
transitions ->  {}

item set 10 
e -> IDENTIFIER . 
transitions ->  {}

item set 11 
compilationUnit -> es EOF . 
transitions ->  {}

item set 12 
es -> es e . 
transitions ->  {}
13 states.
Building lookahead grammar.
Computing lookaheads.
Building parse table.
Conflict at state: 0, token: IDENTIFIER
  reduce by rule: e -> 
  shift token (then go to state 10)
Conflict at state: 0, token: DOT
  reduce by rule: e -> 
  shift token (then go to state 9)
Conflict at state: 0, token: OPEN_BRACE
  reduce by rule: e -> 
  shift token (then go to state 8)
Conflict at state: 0, token: INTEGER_LITERAL
  reduce by rule: e -> 
  shift token (then go to state 7)
Conflict at state: 0, token: REAL_LITERAL
  reduce by rule: e -> 
  shift token (then go to state 6)
Conflict at state: 0, token: Unicode_escape_sequence
  reduce by rule: e -> 
  shift token (then go to state 5)
Conflict at state: 0, token: IF
  reduce by rule: e -> 
  shift token (then go to state 4)
Conflict at state: 2, token: IDENTIFIER
  reduce by rule: e -> 
  shift token (then go to state 10)
Conflict at state: 2, token: DOT
  reduce by rule: e -> 
  shift token (then go to state 9)
Conflict at state: 2, token: OPEN_BRACE
  reduce by rule: e -> 
  shift token (then go to state 8)
Conflict at state: 2, token: INTEGER_LITERAL
  reduce by rule: e -> 
  shift token (then go to state 7)
Conflict at state: 2, token: REAL_LITERAL
  reduce by rule: e -> 
  shift token (then go to state 6)
Conflict at state: 2, token: Unicode_escape_sequence
  reduce by rule: e -> 
  shift token (then go to state 5)
Conflict at state: 2, token: IF
  reduce by rule: e -> 
  shift token (then go to state 4)
Conflict at state: 2, token: EOF
  reduce by rule: e -> 
  shift token (then go to state 11)

15 Conflict(s) found in grammar.
Done.
